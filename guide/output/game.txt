structure:
- game
    - Menu.unity
    - Menu.unity.meta
    - Prefabs.meta
    - Scripts.meta
    - game.unity
    - game.unity.meta
    - game_Blocks.meta
  - Prefabs
      - ChestStory.prefab
      - ChestStory.prefab.meta
      - GameManager.prefab
      - GameManager.prefab.meta
      - NetworkManager.prefab
      - NetworkManager.prefab.meta
      - PlayerChest.prefab
      - PlayerChest.prefab.meta
      - Resources.meta
      - Wind.prefab
      - Wind.prefab.meta
      - WindManager.prefab
      - WindManager.prefab.meta
    - Resources
        - LeaderboardCard.prefab
        - LeaderboardCard.prefab.meta
  - Scripts
      - ChestGame.asmdef
      - ChestGame.asmdef.meta
      - ChestGameManager.cs
      - ChestGameManager.cs.meta
      - ChestMultiplayerExtension.cs
      - ChestMultiplayerExtension.cs.meta
      - ChestStory.cs
      - ChestStory.cs.meta
      - DeprecatedChestStory.cs
      - DeprecatedChestStory.cs.meta
      - Leaderboard.meta
      - Menu.meta
      - MenuStory.cs
      - MenuStory.cs.meta
      - OnlinePlayerData.cs
      - OnlinePlayerData.cs.meta
      - RaycastGunMultiplayer.cs
      - RaycastGunMultiplayer.cs.meta
      - RespawnScreen.cs
      - RespawnScreen.cs.meta
      - SanityStory.cs
      - SanityStory.cs.meta
    - Leaderboard
        - Leaderboard.cs
        - Leaderboard.cs.meta
        - LeaderboardCard.cs
        - LeaderboardCard.cs.meta
        - LeaderboardPlayerName.cs
        - LeaderboardPlayerName.cs.meta
        - LeaderboardPlayerScore.cs
        - LeaderboardPlayerScore.cs.meta
    - Menu
        - AuthenticationRequests.cs
        - AuthenticationRequests.cs.meta
        - PlayerWindManager.cs
        - PlayerWindManager.cs.meta
        - UsernameAuthenticator.cs
        - UsernameAuthenticator.cs.meta
        - Wind.cs
        - Wind.cs.meta
        - WindManager.cs
        - WindManager.cs.meta
  - game_Blocks
      - ChestStory_327234129.txt
      - ChestStory_327234129.txt.meta
      - Directional Light_1986876465.txt
      - Directional Light_1986876465.txt.meta
      - Ground_1080898241.txt
      - Ground_1080898241.txt.meta
      - Main Camera_871945103.txt
      - Main Camera_871945103.txt.meta
      - MultiplayerManager_1362299543.txt
      - MultiplayerManager_1362299543.txt.meta
      - NetworkManager_961643926.txt
      - NetworkManager_961643926.txt.meta
      - Prefab Indexer_267534158.txt
      - Prefab Indexer_267534158.txt.meta
      - SpawnPoint_2102920421.txt
      - SpawnPoint_2102920421.txt.meta
      - __Footer.txt
      - __Footer.txt.meta
      - __Header.txt
      - __Header.txt.meta
      - __SceneSettings.txt
      - __SceneSettings.txt.meta
      - bruh_614428138.txt
      - bruh_614428138.txt.meta

```Scripts\ChestGameManager.cs
using System.Collections.Generic;
using FishNet.Object;
using UnityEngine;

public class ChestGameManager : NetworkBehaviour
{
    #region LeaderboardSetup
    
    private Dictionary<string, int> _cachedLeaderboard = new();
    
    [ObserversRpc]
    public void RebuildLeaderboardRpc(Dictionary<string, int> leaderboard)
    {
        Debug.Log($"Leaderboard Rebuild Requested for {leaderboard.Count} Players.");
        Leaderboard.Instance.RebuildLeaderboard(leaderboard);

        // Copy to avoid the reference sent over the RPC
        _cachedLeaderboard = new Dictionary<string, int>(leaderboard);
    }

    /// <summary>
    /// Sometimes the network object will not spawn in time,
    /// so we request leaderboard rebuild once we know the object is ready.
    /// </summary>
    public override void OnStartClient()
    {
        base.OnStartClient();
        
        RequestLeaderboardRebuild();
    }

    [ServerRpc(RequireOwnership = false)]
    private void RequestLeaderboardRebuild()
    {
        if (!IsServerStarted)
            return;
        
        Debug.Log($"Leaderboard Rebuild Requested. using cached with {_cachedLeaderboard.Count} Players.");
        RebuildLeaderboardRpc(_cachedLeaderboard);
    }

    #endregion

    #region LeaderboardUpdate

    [ObserversRpc]
    public void UpdateLeaderboardScoreRpc(string shooting, string shot, int shootingKillCount)
    {
        Debug.Log($"{shooting} shot {shot}.");
        Leaderboard.Instance.UpdateCount(shooting, shootingKillCount);
    }

    #endregion
}
```

```Scripts\ChestMultiplayerExtension.cs
using FishNet.Connection;
using FishNet.Object;
using UnityEngine;

public class ChestMultiplayerExtension : NetworkBehaviour
{
    #region Setup

    [TargetRpc]
    public void SetupFPSPlayerRpc(NetworkConnection conn)
    {
        // give authority
        var player = GetComponent<Player>();
        player.PlayerId = OwnerId;
        player.SetAuthority(true);
        player.EnablePlayerBehaviors();
        
        // Load State
        player.Awake();
        player.OnEnable();
        player.Start();
        
        player.SwapPlayerState<cc_fpState, FP_CameraState>();
        
        // load extensions too
        GetComponent<RaycastGunMultiplayer>().OnEnablePlayer();
        
        FindFirstObjectByType<RespawnScreen>().HideScreen();
    }

    /// <summary>
    /// for all clients, updates the username on this player.
    /// </summary>
    [ObserversRpc]
    public void UpdateUsernameOnPlayer(string username)
    {
        
    }

    #endregion

    #region GameCycle

    // On Death
    [TargetRpc]
    public void NeutralizePlayerRpc(NetworkConnection conn)
    {
        var player = GetComponent<Player>();
        player.GetComponent<InputDirector>().DisableInput();
        player.DisablePlayerBehaviors();
        FindFirstObjectByType<RespawnScreen>().ShowScreen();
        
        // respond
        ConfirmNeutralizedRpc();
    }
    
    [ServerRpc(RequireOwnership = true)]
    private void ConfirmNeutralizedRpc()
    {
        if (!IsServerStarted)
            return;
        
        var story = FindFirstObjectByType<ChestStory>();
        story.ConfirmNeutralized(GetComponent<Player>().PlayerId);
    }

    #endregion
}
```

```Scripts\ChestStory.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishNet.Transporting;
using UnityEngine;

public class ChestStory : MonoBehaviour
{
    ///<summary>data about each player via ClientId</summary>
    private Dictionary<int, OnlinePlayerData> _players = new();

    ///<summary>Network Communication Handler for the game</summary>
    private ChestGameManager _gameManager;

    #region NetworkEvents

    [SerializeField] private ChestGameManager chestGameManagerPrefab;

    void Start()
    {
        _players = new Dictionary<int, OnlinePlayerData>();

        InstanceFinder.SceneManager.OnClientLoadedStartScenes += SceneManager_OnOnClientLoadedStartScenes;
        InstanceFinder.ServerManager.OnRemoteConnectionState += ServerManager_OnOnRemoteConnectionState;
    }

    private void ServerManager_OnOnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs args)
    {
        // player left this game scene
        if (args.ConnectionState == RemoteConnectionState.Stopped)
        {
            _players.Remove(conn.ClientId);
        }
    }

    private void OnDestroy()
    {
        if (InstanceFinder.SceneManager)
            InstanceFinder.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnOnClientLoadedStartScenes;
    }


    /// <summary>
    /// This function sets up new clients that join.
    /// can be called on the client when they finished connecting
    /// here I only run code from the server (I know the new client finished connecting here)
    /// - so I can set the new client up and start sending rpc's to it.
    /// </summary>
    private void SceneManager_OnOnClientLoadedStartScenes(NetworkConnection conn, bool isServer)
    {
        Debug.Log($"New connection {conn.ClientId} joined - Scene load finished.");

        if (!isServer)
        {
            Debug.Log("connection with server loading, not running setup as server.");
            return;
        }

        // verify Host
        bool isHost = InstanceFinder.ClientManager.Connection.IsHost
                      && conn.IsLocalClient;
        Debug.Log($"Setting up scene for {(isHost ? "Host" : "Regular Player")}");

        // spawn scene network objects
        _gameManager = Instantiate(chestGameManagerPrefab);
        InstanceFinder.ServerManager.Spawn(_gameManager);

        // Setup Game
        SetupNewPlayer(conn);
    }

    #endregion

    #region GameSetup

    [SerializeField] private NetworkObject playerPrefab;
    [SerializeField] private Transform[] spawnPoints;

    private void SetupNewPlayer(NetworkConnection conn)
    {
        // verify new
        if (_players.ContainsKey(conn.ClientId))
        {
            Debug.LogWarning($"Client {conn.ClientId} already setup. skipping.");
            return;
        }
        
        // Add new to players list
        OnlinePlayerData newPlayerData = new OnlinePlayerData()
        {
            ClientConnection = conn,
            Score = 0,
        };
        _players.Add(conn.ClientId, newPlayerData);

        // Spawn Player
        var newPlayer = SpawnPlayerToGame(conn);
        var newPlayerReference = newPlayer.GetComponent<Player>();
        var newPlayerUsername = Wind.Instance.GetUsernameForId(conn.ClientId);
        newPlayerReference.PlayerId = conn.ClientId;
        
        // Update Username of all players
        _players[conn.ClientId].Username = newPlayerUsername;
        foreach (var playerHandler in _players.Values)
            playerHandler.ChestMultiplayerExtension.UpdateUsernameOnPlayer(newPlayerUsername);

        // Leaderboard
        var leaderboardDict = _players.ToDictionary(
            k => k.Value.Username,
            v => v.Value.Score);

        _gameManager.RebuildLeaderboardRpc(leaderboardDict); // Update leaderboard for all players
    }

    /// <summary>
    /// Call to spawn a player to the game
    /// </summary>
    /// <param name="connection">Connection to own the player</param>
    /// <returns></returns>
    private ChestMultiplayerExtension SpawnPlayerToGame(NetworkConnection connection)
    {
        // choose random spawn point to start at
        var spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)];

        // spawn new player online
        var spawnedPlayer = SpawnPlayerOnline(
            connection,
            spawnPoint.position,
            Quaternion.identity);

        spawnedPlayer.PlayerId = connection.ClientId;
        var newPlayer = spawnedPlayer.GetComponent<ChestMultiplayerExtension>();

        // save player data
        _players[connection.ClientId].PlayerReference = spawnedPlayer;
        _players[connection.ClientId].ChestMultiplayerExtension = newPlayer;
        
        // tell the client to set itself up locally
        newPlayer.SetupFPSPlayerRpc(connection);
        
        // also set up it's username for everyone
        var newPlayerUsername = Wind.Instance.GetUsernameForId(connection.ClientId);
        newPlayer.UpdateUsernameOnPlayer(newPlayerUsername);
        
        return newPlayer;
    }

    #endregion

    #region PlayerSpawning

    /// <summary>
    /// Used to spawn a new player in the scene.
    /// Should not be called without handling further game context.
    /// </summary>
    /// <returns>Player runner</returns>
    private Player SpawnPlayerOnline(
        NetworkConnection spawningClientConnection,
        Vector3 position,
        Quaternion rotation)
    {
        if (!playerPrefab || spawningClientConnection == null) return null;
        Debug.Log($"Spawning Player for client {spawningClientConnection.ClientId}");

        NetworkObject spawnedPlayer = Instantiate(playerPrefab, position, rotation);
        InstanceFinder.ServerManager.Spawn(spawnedPlayer, spawningClientConnection);

        // Self Authority is given locally.

        return spawnedPlayer.GetComponent<Player>();
    }

    public void DespawnPlayer(Player player)
    {
        if (player == null) return;
        Debug.Log($"Despawning Player for client {player.PlayerId}");

        InstanceFinder.ServerManager.Despawn(player.gameObject);
    }

    #endregion

    #region GameCycle

    [SerializeField] private float respawnTime = 5f;

    public void HandlePlayerKilled(int shooterPlayerId, int killedPlayerId)
    {
        // verify killed player
        if (!_players.TryGetValue(killedPlayerId, out var killedPlayer))
            return;

        // update leaderboard
        _players[shooterPlayerId].Score += 1;
        var playerShooterScore = _players[shooterPlayerId].Score;
        var playerShooterUsername = Wind.Instance.GetUsernameForId(shooterPlayerId);
        var playerKilledUsername = Wind.Instance.GetUsernameForId(killedPlayerId);

        _gameManager.UpdateLeaderboardScoreRpc(
            playerShooterUsername,
            playerKilledUsername,
            playerShooterScore);

        // Neutralize killed player
        var handler = killedPlayer.ChestMultiplayerExtension;
        handler.NeutralizePlayerRpc(killedPlayer.ClientConnection);
    }

    public void ConfirmNeutralized(int playerId)
    {
        var handler = _players[playerId].ChestMultiplayerExtension;
        var owner = _players[playerId].ClientConnection;

        Debug.Log("what");
        
        Debug.Log(_players[playerId].ChestMultiplayerExtension);
        Debug.Log(_players[playerId].ChestMultiplayerExtension.IsSpawned);
        Debug.Log(_players[playerId].ChestMultiplayerExtension == null);
        Debug.Log(_players[playerId].ChestMultiplayerExtension.isActiveAndEnabled);
        
        InstanceFinder.ServerManager.Despawn(handler);
        Debug.Log("not it, right");
        StartCoroutine(RespawnClient(owner));
    }

    private IEnumerator RespawnClient(NetworkConnection conn)
    {
        // respawn cooldown
        yield return new WaitForSeconds(respawnTime);
        
        Debug.Log("wait");
        // spawn new player
        SpawnPlayerToGame(conn);
    }

#endregion
}
```

```Scripts\DeprecatedChestStory.cs
using System.Collections;
using System.Collections.Generic;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using OverallTimers;
using UnityEngine;

public class DeprecatedChestStory : NetworkBehaviour
{
    // ---- Network Connection ----
    [SerializeField] private NetworkObject playerPrefab;
    [SerializeField] private Transform[] spawnPoints;
    [SerializeField] private float respawnTime = 5f;
    private MultiplayerManager _mm;
    
    private bool _playerInitialized;
    
    // ---- Combat ----
    private readonly Dictionary<string, int> _playerScores = new ();

    private void Start()
    {
        // var netManager = InstanceFinder.NetworkManager;
        // Debug.Log("isclient " + netManager.IsServerStarted);
        // Debug.Log("isserver " + netManager.IsServerStarted);
        // Debug.Log("ishost " + netManager.IsHostStarted);
        // Debug.Log("is authenticated " + netManager.ClientManager.Connection.IsAuthenticated);
        
        InstanceFinder.SceneManager.OnClientLoadedStartScenes += SceneManagerOnOnClientLoadedStartScenes;
        
        
        Debug.Log("cheststory start");
        // _playerInitialized = false;
        //
        // // subscribe to client connection events
        _mm = MultiplayerManager.Instance;
        // _mm.OnClientLoaded += OnClientLoaded;
        // _mm.OnClientDisconnected += OnClientDisconnected;
        
        // setup for host
        // StartCoroutine(SceneLoaded(NetworkManager.ClientManager.Connection));
    }
    
    private void SceneManagerOnOnClientLoadedStartScenes(NetworkConnection conn, bool isServer)
    {
        Debug.Log("am I server? " + isServer);
        Debug.Log("now authenticated? " + InstanceFinder.ClientManager.Connection.IsAuthenticated);
        Debug.Log("Does this know if I am a host? " + InstanceFinder.ClientManager.Connection.IsHost);
    }

    private IEnumerator SceneLoaded(NetworkConnection conn)
    {
        Debug.Log("isclient " + NetworkManager.IsServerStarted);
        Debug.Log("isserver " + NetworkManager.IsServerStarted);
        Debug.Log("ishost " + NetworkManager.IsHostStarted);
        Debug.Log("is authenticated " + conn.IsAuthenticated);
        
        while (!conn.IsAuthenticated)
        {
            Debug.Log("bro what:");
            Debug.Log(InstanceFinder.ClientManager.Connection.IsAuthenticated);
            yield return null;
        }
        while (!conn.LoadedStartScenes())
        {
            yield return null;
        }
        
        if (!NetworkManager.IsHostStarted)
        {
            Debug.Log("good");
            yield break;
        }

        OnHostConnected(NetworkManager.ClientManager.Connection);
    }

    private void OnDestroy()
    {
        // unsubscribe client connection events
        _mm.OnClientLoaded -= OnClientLoaded;
        _mm.OnClientDisconnected -= OnClientDisconnected;
    }

    /// <summary>
    /// this gets called for anyone that joins but host.
    /// </summary>
    /// <param name="connection"></param>
    private void OnClientLoaded(NetworkConnection connection)
    {
        Debug.Log("I am Host and I loaded: " + connection.IsHost);
        
        Debug.Log("loading client");
        if (_playerInitialized)
            return;
        _playerInitialized = true;
        Debug.Log("client loaded");
        
        // Setup new player
        var newPlayer = SpawnPlayer(connection);
        Debug.Log("Great!");
        // Leaderboard
        // if (Wind.Instance.TryGetUsernameForId(connection.ClientId, out var newPlayerUsername))
        // {
        //     _playerScores.Add(newPlayerUsername, 0);                       // update on server
        //     AddPlayerToLeaderboardRpc(newPlayerUsername);                  // update on existing clients
        //     newPlayer.FetchExistingLeaderboard(connection, _playerScores); // update on connected client
        // }
        // else
        //     Debug.LogError("username not found for id: " + connection.ClientId);
    }

    private void OnHostConnected(NetworkConnection connection)
    {
        Debug.Log("loading host");
        if (_playerInitialized)
            return;
        _playerInitialized = true;
        Debug.Log("host loaded");
        
        // Setup new player
        SpawnPlayer(connection);
    }

    private void OnClientDisconnected(NetworkConnection connection)
    {
        // despawn the leaving client object for everyone when he disconnects
        var players = FindObjectsByType<Player>(FindObjectsSortMode.InstanceID);
        
        foreach (var player in players)
        {
            if (player.PlayerId != connection.ClientId)
                continue;
            
            _mm.DespawnPlayer(player);
            return;
        }
    }
    
    private ChestMultiplayerExtension SpawnPlayer(NetworkConnection connection)
    {
        // choose random spawn point to start at
        var spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)];
        
        // spawn new player for everyone when joins (like middle of a match with no timer)
        var spawnedPlayer = _mm.SpawnPlayer(
            connection,
            playerPrefab,
            spawnPoint.position,
            Quaternion.identity);
        
        spawnedPlayer.PlayerId = connection.ClientId;

        var newPlayer = spawnedPlayer.GetComponent<ChestMultiplayerExtension>();
        
        // tell the client to set itself up locally
        newPlayer.SetupFPSPlayerRpc(connection);

        return newPlayer;
    }
    
    // --------------------------
    // Player combat events
    // --------------------------
    [Server]
    public void HandlePlayerKilled(int shootingPlayerId, int killedPlayerId)
    {
        var player = Player.GetPlayer(killedPlayerId);
        if (!player)
            return;
        
        // if (!Wind.Instance.TryGetUsernameForId(shootingPlayerId, out var shootingPlayerUsername)
        //     || !Wind.Instance.TryGetUsernameForId(shootingPlayerId, out var shotPlayerUsername))
        //     return;
        
        // _playerScores[shootingPlayerUsername] += 1;
        //
        // UpdateLeaderboardScoreRpc(
        //     shootingPlayerUsername,
        //     shotPlayerUsername,
        //     _playerScores[shootingPlayerUsername]);

        // disable player input on the client
        var handler = player.GetComponent<ChestMultiplayerExtension>();
        handler.NeutralizePlayerRpc(handler.Owner);
    }

    [ObserversRpc]
    private void UpdateLeaderboardScoreRpc(string shooting, string shot, int shootingKillCount)
    {
        Debug.Log($"{shooting} shot {shot}.");
        Leaderboard.Instance.UpdateCount(shooting, shootingKillCount);
    }

    public void RespondRespawn(int playerId)
    {
        if (!IsServerStarted)
            return;
        
        var player = Player.GetPlayer(playerId);
        if (!player)
            return;

        var handler = player.GetComponent<ChestMultiplayerExtension>();
        var owner = handler.Owner;

        handler.Despawn();
        StartRespawn(owner);
    }
    
    private void StartRespawn(NetworkConnection conn)
    {
        var timer = new CountdownTimer(respawnTime);
        timer.OnTimerStop += () => RespawnPlayer(conn);
        timer.Start();

        // tick from story
        StartCoroutine(TickTimer(timer));
    }
    
    private IEnumerator TickTimer(CountdownTimer timer)
    {
        while (!timer.IsFinished)
        {
            timer.Tick(Time.deltaTime);
            yield return null;
        }
    }

    private void RespawnPlayer(NetworkConnection conn)
    {
        Debug.Log($"Respawning player {conn.ClientId}");
        SpawnPlayer(conn);
    }
    
    // --------------------------
    // Leaderboard
    // --------------------------
    
    // for existing players
    [ObserversRpc]
    private void AddPlayerToLeaderboardRpc(string playerUsername)
    {
        // Leaderboard.Instance.AddPlayerToLeaderboard(playerUsername);
    }
}
```

```Scripts\MenuStory.cs
using System.Collections;
using System.Net;
using System.Net.Sockets;
using FishNet;
using FishNet.Managing;
using FishNet.Managing.Scened;
using FishNet.Object;
using FishNet.Transporting;
using UnityEngine;
using UnityEngine.LowLevelPhysics;

public class MenuStory : MonoBehaviour
{
    [SerializeField] private TMPro.TMP_InputField ipField;
    [SerializeField] private TMPro.TMP_InputField usernameField;
    [SerializeField] private TMPro.TextMeshProUGUI usernameErrorText;
    
    [SerializeField] private TMPro.TextMeshProUGUI displayIpText;

    [SerializeField] private WindManager windManagerPrefab;
    
    private NetworkManager _networkManager;
    
    private string _chosenUsername;
    private bool _isConnecting;

    private void Awake()
    {
        _networkManager = InstanceFinder.NetworkManager;
        usernameErrorText.text = "";
        displayIpText.text = "";
        
        _networkManager.GetComponent<UsernameAuthenticator>()
            .StoryOnAuthenticationResult.AddListener(OnUsernameResult);
    }

    public void StartHost()
    {
        // server initialized
        _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnOnServerConnectionState;
        
        // Start Host Connection
        _networkManager.ServerManager.StartConnection();
        
        // Show Ip
        displayIpText.text = $"IP: {GetLocalIPv4()}";
        
        // Start Client Connection
        StartClient();
    }

    private void ServerManager_OnOnServerConnectionState(ServerConnectionStateArgs args)
    {
        if (args.ConnectionState != LocalConnectionState.Started)
            return;
        
        // Load game scene for all clients
        SceneLoadData sceneLoadData = new SceneLoadData("game") {
            ReplaceScenes = ReplaceOption.All
        };
        _networkManager.SceneManager.LoadGlobalScenes(sceneLoadData);
    }

    public void StartClient()
    {
        // Guard connection attempt
        if (_isConnecting) return;
        _isConnecting = true;
        
        // collect ip and username data
        string ip = ipField.text;
        if (string.IsNullOrEmpty(ip))
        {
            Debug.Log("ip can't be empty!");
            return;
        }
        _chosenUsername = usernameField.text.Trim();
        usernameErrorText.text = "";

        // verify username
        if (string.IsNullOrEmpty(_chosenUsername))
        {
            usernameErrorText.text = "Username is empty.";
            _isConnecting = false;
            return;
        }
        
        // request username from server
        _networkManager.ClientManager.OnClientConnectionState += OnClientConnectionState;
        _networkManager.ClientManager.StartConnection(ip);
    }

    private void OnClientConnectionState(ClientConnectionStateArgs args)
    {
        if (args.ConnectionState == LocalConnectionState.Started)
        {
            // auto approve host
            if (InstanceFinder.IsHostStarted)
            {
                Debug.Log("oh, host! auto approved.");
                return;
            }
            
            // send username request to server
            UsernameRequest req = new() { Username = _chosenUsername };
            InstanceFinder.ClientManager.Broadcast(req);
        }
        else if (args.ConnectionState == LocalConnectionState.Stopped)
        {
            Debug.Log("Disconnected (probably rejected)");
        }
    }

    private void OnUsernameResult(bool available, string message)
    {
        _isConnecting = false;

        if (!available)
        {
            usernameErrorText.text = message;
            
            // disconnect if username is bad
            if (_networkManager != null)
                _networkManager.ClientManager.StopConnection();
        }
        
        if (available)
        {
            // Confirm username locally
            PlayerWindManager.ChosenUsername = usernameField.text.Trim();
            usernameErrorText.text = "Connection Successful";
        }
    }

    private static string GetLocalIPv4()
    {
        foreach (var ip in Dns.GetHostEntry(Dns.GetHostName()).AddressList)
        {
            if (ip.AddressFamily == AddressFamily.InterNetwork)
                return ip.ToString();
        }
        return "Unknown";
    }
}
```

```Scripts\OnlinePlayerData.cs
using FishNet.Connection;

public class OnlinePlayerData
{
    public NetworkConnection ClientConnection;
    
    public Player PlayerReference;
    public ChestMultiplayerExtension ChestMultiplayerExtension;

    public string Username;
    public int Score;
}
```

```Scripts\RaycastGunMultiplayer.cs
ï»¿using FishNet.Connection;
using FishNet.Object;
using OverallTimers;
using UnityEngine;

/// <summary>
/// This does not work with the original offline gun extensions.
/// requires its own on hit detections.
/// </summary>
public class RaycastGunMultiplayer : NetworkBehaviour, IPlayerBehavior
{
    [Header("Gun Stats")]
    [SerializeField] private float damage = 10f;
    [SerializeField] private float maxCooldown = 0.5f;

    private CountdownTimer cooldownTimer;
    private Transform cam;
    private Player _player;
    private InputDirector _director;
    
    [Header("Raycast Gun Settings")]
    [SerializeField] private float maxRange = 100f;
    [SerializeField] private LayerMask hitLayers;
    private AnimationsManager _animationsManager;

    [Header("Multiplayer Settings")]
    private CountdownTimer respawnTimer;
    private float respawnTime = 5f;
    private int localPlayerId = -1;
    
    public void OnEnablePlayer()
    {
        // Multiplayer Guard
        _player = GetComponent<Player>();
        if (!_player.HasAuthority)
            return;
        
        // Get Assignables
        _animationsManager = GetComponent<AnimationsManager>();
        cam = _player.GetCamera().transform;
        _director = GetComponent<InputDirector>();
        localPlayerId = _player.PlayerId;
        
        // Subscribe to input events
        _director.OnFirePressed += OnFirePressed;

        // Reset cooldown
        cooldownTimer = new CountdownTimer(maxCooldown);
    }

    public void OnDestroy()
    {
        if (!_director)
            return;
        
        _director.OnFirePressed -= OnFirePressed;
    }

    public void UpdatePlayer()
    {
        // Multiplayer Guard
        if (!_player.HasAuthority)
            return;
        
        respawnTimer?.Tick(Time.deltaTime);
        cooldownTimer?.Tick(Time.deltaTime);
    }
    
    private void OnFirePressed()
    {
        // Multiplayer Guard
        if (!_player.HasAuthority)
            return;
        
        // If there's still cooldown, don't shoot
        if (!cooldownTimer.IsFinished) return;
        cooldownTimer.Reset();
        cooldownTimer.Start();

        PerformShoot();
    }

    private void PerformShoot()
    {
        if (cam == null)
        {
            Debug.LogWarning("RaycastGun: Missing camera reference.");
            return;
        }

        // Player animations
        // if (_animationsManager != null)
        // {
        //     _animationsManager.Play("Shoot");
        // }

        // request shoot from server
        OnPlayerShootRpc(localPlayerId, cam.position, cam.forward);
    }

    [ServerRpc(RequireOwnership = true)]
    private void OnPlayerShootRpc(int localId, Vector3 camPosition, Vector3 camForward)
    {
        // calculate on server shoot result
        if (!IsServerStarted)
            return;
        
        Debug.Log($"Shooting requested. from {camPosition} to {camForward}");
        
        // using raycast gun
        Vector3 origin = camPosition + camForward * 0.65f; // to not hit self
        Ray ray = new Ray(origin, camForward);

        if (Physics.Raycast(ray, out var hit, maxRange))
        {
            // We hit a player
            if (hit.collider.TryGetComponent(out Player playerHit))
                KillPlayer(localId, playerHit);
        }
    }

    private void KillPlayer(int shootingPlayerId, Player playerHit)
    {
        // Despawn player
        var story = FindFirstObjectByType<ChestStory>();
        story.HandlePlayerKilled(shootingPlayerId, playerHit.PlayerId);
    }
}
```

```Scripts\RespawnScreen.cs
using UnityEngine;

public class RespawnScreen : MonoBehaviour
{
    [SerializeField] private GameObject screen;
    
    public void ShowScreen() => screen.SetActive(true);
    public void HideScreen() => screen.SetActive(false);
}
```

```Scripts\SanityStory.cs
using System.Collections;
using System.Collections.Generic;
using FishNet;
using FishNet.Connection;
using FishNet.Managing;
using UnityEngine;

public class SanityStory : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        Debug.Log("Start always gets called");
        Debug.Log("authenticated " + InstanceFinder.ClientManager.Connection.IsAuthenticated);
        
        InstanceFinder.SceneManager.OnClientLoadedStartScenes += SceneManagerOnOnClientLoadedStartScenes;
        // var netManager = InstanceFinder.NetworkManager;
        // Debug.Log("isclient " + netManager.IsServerStarted);
        // Debug.Log("isserver " + netManager.IsServerStarted);
        // Debug.Log("ishost " + netManager.IsHostStarted);
        // Debug.Log("is authenticated " + netManager.ClientManager.Connection.IsAuthenticated);
    }

    private void SceneManagerOnOnClientLoadedStartScenes(NetworkConnection conn, bool isServer)
    {
        Debug.Log("am I server? " + isServer);
        Debug.Log("now authenticated? " + InstanceFinder.ClientManager.Connection.IsAuthenticated);
        Debug.Log("Does this know if I am a host? " + InstanceFinder.ClientManager.Connection.IsHost);
    }
}
```

```Scripts\Leaderboard\Leaderboard.cs
using System.Collections.Generic;
using UnityEngine;

public class Leaderboard : MonoBehaviour
{
    // leaderboard: username, score
    private readonly Dictionary<string, LeaderboardCard> _cards = new ();
    
    #region Singleton
    
    public static Leaderboard Instance;
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    #endregion

    /// <summary>
    /// add new player to the leaderboard
    /// </summary>
    /// <param name="playerUsername">new player username</param>
    private void AddPlayerToLeaderboard(string playerUsername)
    {
        var cardObject = Resources.Load<LeaderboardCard>("LeaderboardCard");
        if (!cardObject)
        {
            Debug.LogError($"{nameof(Leaderboard)}: Card Object not found.");
            return;
        }
        
        var spawnedCard = Instantiate(cardObject, transform);
        spawnedCard.SetPlayerNameText(playerUsername);
        spawnedCard.SetPlayerScoreText("0");
        
        _cards.Add(playerUsername, spawnedCard);
    }

    /// <summary>
    /// for the new player, give the full leaderboard including himself.
    /// </summary>
    /// <param name="updatedBoard">all connected players, including myself (new player)</param>
    public void RebuildLeaderboard(Dictionary<string, int> updatedBoard)
    {
        // Clean Leaderboard
        foreach (var card in _cards)
            Destroy(card.Value.gameObject);
        _cards.Clear();
        
        // Rebuild Leaderboard
        foreach (var player in updatedBoard)
        {
            AddPlayerToLeaderboard(player.Key);
            UpdateCount(player.Key, player.Value);
        }
    }
    
    public void UpdateCount(string playerUsername, int count)
    {
        if (!_cards.TryGetValue(playerUsername, out var card))
        {
            Debug.LogError($"{nameof(Leaderboard)}: Player {playerUsername} not found.");
            return;
        }
        
        card.SetPlayerScoreText(count.ToString());
    }
}
```

```Scripts\Leaderboard\LeaderboardCard.cs
using System;
using UnityEngine;
using TMPro;

public class LeaderboardCard : MonoBehaviour
{
    private TextMeshProUGUI _playerNameText;
    private TextMeshProUGUI _playerScoreText;

    private void Awake()
    {
        _playerNameText = GetComponentInChildren<LeaderboardPlayerName>().GetComponent<TextMeshProUGUI>();
        _playerScoreText = GetComponentInChildren<LeaderboardPlayerScore>().GetComponent<TextMeshProUGUI>();
    }

    public void SetPlayerNameText(string playerName)
    {
        _playerNameText.text = playerName;
    }
    
    public void SetPlayerScoreText(string playerScore)
    {
        _playerScoreText.text = playerScore;
    }
}
```

```Scripts\Leaderboard\LeaderboardPlayerName.cs
using UnityEngine;

public class LeaderboardPlayerName : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
```

```Scripts\Leaderboard\LeaderboardPlayerScore.cs
    using UnityEngine;

public class LeaderboardPlayerScore : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
```

```Scripts\Menu\AuthenticationRequests.cs
using FishNet.Broadcast;
using FishNet.Serializing;

[System.Serializable]
public struct UsernameRequest : IBroadcast
{
    public string Username;
}

[System.Serializable]
public struct UsernameResponse : IBroadcast
{
    public bool Success;
    public string Message;
}
```

```Scripts\Menu\PlayerWindManager.cs
using System;
using UnityEngine;

/// <summary>
/// What moves between scenes locally
/// (not attached to network behavior or anything multiplayer)
/// </summary>
public class PlayerWindManager : MonoBehaviour
{
    public static PlayerWindManager Instance { get; private set; }

    #region Singleton

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
    }

    private void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    #endregion

    public static string ChosenUsername = "";
}
```

```Scripts\Menu\UsernameAuthenticator.cs
using System;
using System.Collections.Generic;
using FishNet;
using FishNet.Authenticating;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Transporting;
using UnityEngine;
using UnityEngine.Events;

public class UsernameAuthenticator : Authenticator
{
    public override event Action<NetworkConnection, bool> OnAuthenticationResult;
    public UnityEvent<bool, string> StoryOnAuthenticationResult = new ();
    
    private readonly HashSet<string> _takenUsernames = new (StringComparer.OrdinalIgnoreCase);

    private void Awake()
    {
        _takenUsernames.Clear();
        StoryOnAuthenticationResult.RemoveAllListeners();
        
        DontDestroyOnLoad(gameObject);
    }

    public override void InitializeOnce(NetworkManager networkManager)
    {
        base.InitializeOnce(networkManager);
        
        // Server: listen for username requests
        networkManager.ServerManager.RegisterBroadcast<UsernameRequest>(OnReceiveUsernameRequest, false);
        
        // client: listen for result
        networkManager.ClientManager.RegisterBroadcast<UsernameResponse>(OnReceiveResponse);
    }
    
    /// <summary>
    /// Server: receives username request from client
    /// </summary>
    private void OnReceiveUsernameRequest(NetworkConnection conn, UsernameRequest request, Channel channel)
    {
        // can't be already authenticated
        if (conn.IsAuthenticated)
        {
            Debug.LogError("connection already authenticated? possible attack.");
            conn.Disconnect(true);
            return;
        }
        
        // verify username
        string username = request.Username?.Trim();
        bool success = !string.IsNullOrWhiteSpace(username) && !_takenUsernames.Contains(username);
        if (success)
        {
            _takenUsernames.Add(username);
            conn.CustomData = username;
            Wind.Instance.AddPlayer(conn.ClientId, username);
        }
        
        string message = success ? "Connection Success"  : "Username taken or invalid!";
        
        // response with the result
        UsernameResponse response = new () { Success = success, Message = message };
        InstanceFinder.ServerManager.Broadcast(conn, response, false);
        
        // approve / reject connection
        OnAuthenticationResult?.Invoke(conn, success);
    }
    
    // client: receives result
    private void OnReceiveResponse(UsernameResponse response, Channel channel)
    {
        if (response.Success)
            Debug.Log(response.Message);
        else
            Debug.LogWarning($"Login failed: {response.Message}");
        
        StoryOnAuthenticationResult?.Invoke(response.Success, response.Message);
    }
    
    // cleanup for disconnect
    private void OnEnable()
    {
        InstanceFinder.ServerManager.OnRemoteConnectionState += ServerManager_OnOnRemoteConnectionState;
    }

    private void OnDisable()
    {
        if (InstanceFinder.ServerManager != null)
            InstanceFinder.ServerManager.OnRemoteConnectionState -= ServerManager_OnOnRemoteConnectionState;
    }

    private void ServerManager_OnOnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs args)
    {
        if (args.ConnectionState == RemoteConnectionState.Stopped && conn.CustomData is string username)
        {
            _takenUsernames.Remove(username);
            Wind.Instance.RemovePlayer(conn.ClientId);
        }
    }
}
```

```Scripts\Menu\Wind.cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Moves player data between scenes
/// </summary>
public class Wind : MonoBehaviour
{
    #region Singleton

    public static Wind Instance { get; private set; }
    
    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    #endregion

    public UnityEvent<string> OnClientApproved = new ();
    public UnityEvent<int> OnClientLeave = new ();

    private readonly Dictionary<int, string> _playerUsernames = new();

    public void AddPlayer(int id, string username)
    {
        if (!_playerUsernames.TryAdd(id, username))
            Debug.LogError("id already exists in Wind's usernames!");
        
        OnClientApproved?.Invoke(username);
    }

    public void RemovePlayer(int id)
    {
        if (!_playerUsernames.Remove(id))
            Debug.LogError("id does not exist in Wind's usernames!");
        
        OnClientLeave?.Invoke(id);
    }

    public string GetUsernameForId(int playerId)
    {
        if (_playerUsernames.TryGetValue(playerId, out var username))
            return username;
        
        throw new KeyNotFoundException($"Wind: can't find username for player id: {playerId}");
    }
}
```

```Scripts\Menu\WindManager.cs
using System.Collections.Generic;
using FishNet.Object;

/// <summary>
/// What goes between scenes in a multiplayer environment
/// </summary>
public class WindManager : NetworkBehaviour
{
    private readonly HashSet<string> _usernames = new();
    public static WindManager Instance { get; private set; }

    #region Singleton

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
    }

    public override void OnStopNetwork()
    {
        base.OnStopNetwork();
        
        if (Instance == this) Instance = null;
    }

    #endregion
    
    public void AddUsername(string username) => _usernames.Add(username);
    
    public void RemoveUsername(string username) => _usernames.Remove(username);
}
```

