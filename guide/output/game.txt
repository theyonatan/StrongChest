structure:
- game
    - Menu.unity
    - Menu.unity.meta
    - Prefabs.meta
    - Scripts.meta
    - game.unity
    - game.unity.meta
    - game_Blocks.meta
  - Prefabs
      - ChestStory.prefab
      - ChestStory.prefab.meta
      - PlayerChest.prefab
      - PlayerChest.prefab.meta
      - Resources.meta
      - Wind.prefab
      - Wind.prefab.meta
      - WindManager.prefab
      - WindManager.prefab.meta
    - Resources
        - LeaderboardCard.prefab
        - LeaderboardCard.prefab.meta
  - Scripts
      - ChestGame.asmdef
      - ChestGame.asmdef.meta
      - ChestMultiplayerExtension.cs
      - ChestMultiplayerExtension.cs.meta
      - ChestStory.cs
      - ChestStory.cs.meta
      - Leaderboard.meta
      - Menu.meta
      - MenuStory.cs
      - MenuStory.cs.meta
      - RaycastGunMultiplayer.cs
      - RaycastGunMultiplayer.cs.meta
      - RespawnScreen.cs
      - RespawnScreen.cs.meta
    - Leaderboard
        - Leaderboard.cs
        - Leaderboard.cs.meta
        - LeaderboardCard.cs
        - LeaderboardCard.cs.meta
        - LeaderboardPlayerName.cs
        - LeaderboardPlayerName.cs.meta
        - LeaderboardPlayerScore.cs
        - LeaderboardPlayerScore.cs.meta
    - Menu
        - AuthenticationRequests.cs
        - AuthenticationRequests.cs.meta
        - PlayerWindManager.cs
        - PlayerWindManager.cs.meta
        - UsernameAuthenticator.cs
        - UsernameAuthenticator.cs.meta
        - Wind.cs
        - Wind.cs.meta
        - WindManager.cs
        - WindManager.cs.meta
  - game_Blocks
      - ChestStory_327234129.txt
      - ChestStory_327234129.txt.meta
      - Directional Light_1986876465.txt
      - Directional Light_1986876465.txt.meta
      - Ground_1080898241.txt
      - Ground_1080898241.txt.meta
      - Main Camera_871945103.txt
      - Main Camera_871945103.txt.meta
      - MultiplayerManager_1362299543.txt
      - MultiplayerManager_1362299543.txt.meta
      - NetworkManager_961643926.txt
      - NetworkManager_961643926.txt.meta
      - Prefab Indexer_267534158.txt
      - Prefab Indexer_267534158.txt.meta
      - SpawnPoint_2102920421.txt
      - SpawnPoint_2102920421.txt.meta
      - __Footer.txt
      - __Footer.txt.meta
      - __Header.txt
      - __Header.txt.meta
      - __SceneSettings.txt
      - __SceneSettings.txt.meta
      - bruh_614428138.txt
      - bruh_614428138.txt.meta

```Scripts\ChestMultiplayerExtension.cs
using System.Collections.Generic;
using FishNet.Connection;
using FishNet.Object;

public class ChestMultiplayerExtension : NetworkBehaviour
{
    public string Username;
    
    [TargetRpc]
    public void SetupFPSPlayerRpc(NetworkConnection conn)
    {
        // give authority
        var player = GetComponent<Player>();
        player.PlayerId = OwnerId;
        player.SetAuthority(true);
        player.EnablePlayerBehaviors();
        
        // Load State
        player.Awake();
        player.OnEnable();
        player.Start();
        
        player.SwapPlayerState<cc_fpState, FP_CameraState>();
        
        // load extensions too
        GetComponent<RaycastGunMultiplayer>().OnEnablePlayer();
        
        FindFirstObjectByType<RespawnScreen>().HideScreen();
    }
    
    // On Join Game
    [TargetRpc]
    public void FetchExistingLeaderboard(NetworkConnection conn, Dictionary<string, int> leaderboard)
    {
        Leaderboard.Instance.UpdateLeaderboard(leaderboard);
    }
    
    // On Death
    [TargetRpc]
    public void NeutrilizePlayerRpc(NetworkConnection conn)
    {
        var player = GetComponent<Player>();
        player.GetComponent<InputDirector>().DisableInput();
        player.DisablePlayerBehaviors();
        FindFirstObjectByType<RespawnScreen>().ShowScreen();
        
        // respond
        RespondRespawnServerRpc();
    }
    
    [ServerRpc(RequireOwnership = true)]
    private void RespondRespawnServerRpc()
    {
        var story = FindFirstObjectByType<ChestStory>();
        story.RespondRespawn(GetComponent<Player>().PlayerId);
    }
}
```

```Scripts\ChestStory.cs
using System.Collections.Generic;
using FishNet.Connection;
using FishNet.Object;
using OverallTimers;
using UnityEngine;

public class ChestStory : NetworkBehaviour
{
    // ---- Network Connection ----
    [SerializeField] private NetworkObject playerPrefab;
    [SerializeField] private Transform[] spawnPoints;
    [SerializeField] private float respawnTime = 5f;
    private MultiplayerManager _mm;
    
    // ---- Combat ----
    private readonly Dictionary<string, int> _playerScores = new ();

    private void Start()
    {
        // subscribe to client connection events
        _mm = MultiplayerManager.Instance;
        _mm.OnClientLoaded += OnClientLoaded;
        _mm.OnClientDisconnected += OnClientDisconnected;
        
        // setup for host
        if (NetworkManager.IsHostStarted)
        {
            NetworkManager.ClientManager.Connection.OnLoadedStartScenes += (connection, b) =>
                OnHostConnected(NetworkManager.ClientManager.Connection);
        }
    }

    private void OnDestroy()
    {
        // unsubscribe client connection events
        _mm.OnClientLoaded -= OnClientLoaded;
        _mm.OnClientDisconnected -= OnClientDisconnected;
    }

    /// <summary>
    /// this gets called for anyone that joins but host.
    /// </summary>
    /// <param name="connection"></param>
    private void OnClientLoaded(NetworkConnection connection)
    {
        // Setup new player
        var newPlayer = SpawnPlayer(connection);
        
        // Leaderboard
        if (Wind.Instance.TryGetUsernameForId(connection.ClientId, out var newPlayerUsername))
        {
            _playerScores.Add(newPlayerUsername, 0);                       // update on server
            AddPlayerToLeaderboardRpc(newPlayerUsername);                  // update on existing clients
            newPlayer.FetchExistingLeaderboard(connection, _playerScores); // update on connected client
        }
        else
            Debug.LogError("username not found for id: " + connection.ClientId);
    }

    private void OnHostConnected(NetworkConnection connection)
    {
        // Setup new player
        SpawnPlayer(connection);
        
        // Leaderboard
        if (Wind.Instance.TryGetUsernameForId(connection.ClientId, out var newPlayerUsername))
        {
            _playerScores.Add(newPlayerUsername, 0);                       // update on server
            AddPlayerToLeaderboardRpc(newPlayerUsername);                  // update on host
        }
        else
            Debug.LogError("username not found for id: " + connection.ClientId);
    }

    private void OnClientDisconnected(NetworkConnection connection)
    {
        // despawn the leaving client object for everyone when he disconnects
        var players = FindObjectsByType<Player>(FindObjectsSortMode.InstanceID);
        
        foreach (var player in players)
        {
            if (player.PlayerId != connection.ClientId)
                continue;
            
            _mm.DespawnPlayer(player);
            return;
        }
    }
    
    private ChestMultiplayerExtension SpawnPlayer(NetworkConnection connection)
    {
        // choose random spawn point to start at
        var spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)];
        
        // spawn new player for everyone when joins (like middle of a match with no timer)
        var spawnedPlayer = _mm.SpawnPlayer(
            connection,
            playerPrefab,
            spawnPoint.position,
            Quaternion.identity);
        
        spawnedPlayer.PlayerId = connection.ClientId;

        var newPlayer = spawnedPlayer.GetComponent<ChestMultiplayerExtension>();
        
        // tell the client to set itself up locally
        newPlayer.SetupFPSPlayerRpc(connection);

        return newPlayer;
    }
    
    // --------------------------
    // Player combat events
    // --------------------------
    [Server]
    public void HandlePlayerKilled(int shootingPlayerId, int killedPlayerId)
    {
        var player = Player.GetPlayer(killedPlayerId);
        if (!player)
            return;
        
        if (!Wind.Instance.TryGetUsernameForId(shootingPlayerId, out var shootingPlayerUsername)
            || !Wind.Instance.TryGetUsernameForId(shootingPlayerId, out var shotPlayerUsername))
            return;
        
        _playerScores[shootingPlayerUsername] += 1;
        
        UpdateLeaderboardScoreRpc(
            shootingPlayerUsername,
            shotPlayerUsername,
            _playerScores[shootingPlayerUsername]);

        // disable player input on the client
        var handler = player.GetComponent<ChestMultiplayerExtension>();
        handler.NeutrilizePlayerRpc(handler.Owner);
    }

    [ObserversRpc]
    private void UpdateLeaderboardScoreRpc(string shooting, string shot, int shootingKillCount)
    {
        Debug.Log($"{shooting} shot {shot}.");
        Leaderboard.Instance.UpdateCount(shooting, shootingKillCount);
    }

    public void RespondRespawn(int playerId)
    {
        if (!IsServerStarted)
            return;
        
        var player = Player.GetPlayer(playerId);
        if (!player)
            return;

        var handler = player.GetComponent<ChestMultiplayerExtension>();
        var owner = handler.Owner;

        handler.Despawn();
        StartRespawn(owner);
    }
    
    private void StartRespawn(NetworkConnection conn)
    {
        var timer = new CountdownTimer(respawnTime);
        timer.OnTimerStop += () => RespawnPlayer(conn);
        timer.Start();

        // tick from story
        StartCoroutine(TickTimer(timer));
    }
    
    private System.Collections.IEnumerator TickTimer(CountdownTimer timer)
    {
        while (!timer.IsFinished)
        {
            timer.Tick(Time.deltaTime);
            yield return null;
        }
    }

    private void RespawnPlayer(NetworkConnection conn)
    {
        Debug.Log($"Respawning player {conn.ClientId}");
        SpawnPlayer(conn);
    }
    
    // --------------------------
    // Leaderboard
    // --------------------------
    
    // for existing players
    [ObserversRpc]
    private void AddPlayerToLeaderboardRpc(string playerUsername)
    {
        Leaderboard.Instance.AddPlayerToLeaderboard(playerUsername);
    }
}
```

```Scripts\MenuStory.cs
using System.Collections;
using System.Net;
using System.Net.Sockets;
using FishNet;
using FishNet.Managing;
using FishNet.Managing.Scened;
using FishNet.Object;
using FishNet.Transporting;
using UnityEngine;
using UnityEngine.LowLevelPhysics;

public class MenuStory : MonoBehaviour
{
    [SerializeField] private TMPro.TMP_InputField ipField;
    [SerializeField] private TMPro.TMP_InputField usernameField;
    [SerializeField] private TMPro.TextMeshProUGUI usernameErrorText;
    
    [SerializeField] private TMPro.TextMeshProUGUI displayIpText;

    [SerializeField] private WindManager windManagerPrefab;
    
    private NetworkManager _networkManager;
    
    private string _chosenUsername;
    private bool _isConnecting;

    private void Awake()
    {
        _networkManager = InstanceFinder.NetworkManager;
        usernameErrorText.text = "";
        displayIpText.text = "";
        
        _networkManager.GetComponent<UsernameAuthenticator>()
            .StoryOnAuthenticationResult.AddListener(OnUsernameResult);
    }

    public void StartHost()
    {
        // server initialized
        _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnOnServerConnectionState;
        
        // Start Host Connection
        _networkManager.ServerManager.StartConnection();
        
        // Show Ip
        displayIpText.text = $"IP: {GetLocalIPv4()}";
        
        // Start Client Connection
        StartClient();
    }

    private void ServerManager_OnOnServerConnectionState(ServerConnectionStateArgs args)
    {
        if (args.ConnectionState != LocalConnectionState.Started)
            return;
        
        // Load game scene for all clients
        SceneLoadData sceneLoadData = new SceneLoadData("game") {
            ReplaceScenes = ReplaceOption.All
        };
        _networkManager.SceneManager.LoadGlobalScenes(sceneLoadData);
    }

    public void StartClient()
    {
        // Guard connection attempt
        if (_isConnecting) return;
        _isConnecting = true;
        
        // collect ip and username data
        string ip = ipField.text;
        if (string.IsNullOrEmpty(ip))
        {
            Debug.Log("ip can't be empty!");
            return;
        }
        _chosenUsername = usernameField.text.Trim();
        usernameErrorText.text = "";

        // verify username
        if (string.IsNullOrEmpty(_chosenUsername))
        {
            usernameErrorText.text = "Username is empty.";
            _isConnecting = false;
            return;
        }
        
        // request username from server
        _networkManager.ClientManager.OnClientConnectionState += OnClientConnectionState;
        _networkManager.ClientManager.StartConnection(ip);
    }

    private void OnClientConnectionState(ClientConnectionStateArgs args)
    {
        if (args.ConnectionState == LocalConnectionState.Started)
        {
            // auto approve host
            if (InstanceFinder.IsHostStarted)
            {
                Debug.Log("oh, host! auto approved.");
                return;
            }
            
            // send username request to server
            UsernameRequest req = new() { Username = _chosenUsername };
            InstanceFinder.ClientManager.Broadcast(req);
        }
        else if (args.ConnectionState == LocalConnectionState.Stopped)
        {
            Debug.Log("Disconnected (probably rejected)");
        }
    }

    private void OnUsernameResult(bool available, string message)
    {
        _isConnecting = false;

        if (!available)
        {
            usernameErrorText.text = message;
            
            // disconnect if username is bad
            if (_networkManager != null)
                _networkManager.ClientManager.StopConnection();
        }
        
        if (available)
        {
            // Confirm username locally
            PlayerWindManager.ChosenUsername = usernameField.text.Trim();
            usernameErrorText.text = "Connection Successful";
        }
    }

    private static string GetLocalIPv4()
    {
        foreach (var ip in Dns.GetHostEntry(Dns.GetHostName()).AddressList)
        {
            if (ip.AddressFamily == AddressFamily.InterNetwork)
                return ip.ToString();
        }
        return "Unknown";
    }
}
```

```Scripts\RaycastGunMultiplayer.cs
ï»¿using FishNet.Connection;
using FishNet.Object;
using OverallTimers;
using UnityEngine;

/// <summary>
/// This does not work with the original offline gun extensions.
/// requires its own on hit detections.
/// </summary>
public class RaycastGunMultiplayer : NetworkBehaviour, IPlayerBehavior
{
    [Header("Gun Stats")]
    [SerializeField] private float damage = 10f;
    [SerializeField] private float maxCooldown = 0.5f;

    private CountdownTimer cooldownTimer;
    private Transform cam;
    private Player _player;
    private InputDirector _director;
    
    [Header("Raycast Gun Settings")]
    [SerializeField] private float maxRange = 100f;
    [SerializeField] private LayerMask hitLayers;
    private AnimationsManager _animationsManager;

    [Header("Multiplayer Settings")]
    private CountdownTimer respawnTimer;
    private float respawnTime = 5f;
    private int localPlayerId = -1;
    
    public void OnEnablePlayer()
    {
        // Multiplayer Guard
        _player = GetComponent<Player>();
        if (!_player.HasAuthority)
            return;
        
        // Get Assignables
        _animationsManager = GetComponent<AnimationsManager>();
        cam = _player.GetCamera().transform;
        _director = GetComponent<InputDirector>();
        localPlayerId = _player.PlayerId;
        
        // Subscribe to input events
        _director.OnFirePressed += OnFirePressed;

        // Reset cooldown
        cooldownTimer = new CountdownTimer(maxCooldown);
    }

    public void UpdatePlayer()
    {
        // Multiplayer Guard
        if (!_player.HasAuthority)
            return;
        
        respawnTimer?.Tick(Time.deltaTime);
        cooldownTimer?.Tick(Time.deltaTime);
    }

    private void PerformShoot()
    {
        if (cam == null)
        {
            Debug.LogWarning("RaycastGun: Missing camera reference.");
            return;
        }

        // Player animations
        // if (_animationsManager != null)
        // {
        //     _animationsManager.Play("Shoot");
        // }

        // send rpc to server
        OnPlayerShootRpc(localPlayerId, cam.position, cam.forward);
    }
    
    private void OnFirePressed()
    {
        // Multiplayer Guard
        if (!_player.HasAuthority)
            return;
        
        // If there's still cooldown, don't shoot
        if (!cooldownTimer.IsFinished) return;
        cooldownTimer.Reset();
        cooldownTimer.Start();

        PerformShoot();
    }

    [ServerRpc(RequireOwnership = true)]
    private void OnPlayerShootRpc(int localId, Vector3 camPosition, Vector3 camForward)
    {
        if (!IsServerStarted)
            return;
        
        // log for self
        Debug.Log($"Doing some calculations. from {camPosition} to {camForward}");
        
        // rpc
        Vector3 origin = camPosition + camForward * 0.65f; // to not hit self
        Ray ray = new Ray(origin, camForward);

        if (Physics.Raycast(ray, out var hit, maxRange))
        {
            // We hit a player
            if (hit.collider.TryGetComponent(out Player playerHit))
                KillPlayer(localId, playerHit);
        }
    }

    private void KillPlayer(int shootingPlayerId, Player playerHit)
    {
        // Despawn player
        var story = FindFirstObjectByType<ChestStory>();
        story.HandlePlayerKilled(shootingPlayerId, playerHit.PlayerId);
    }
}
```

```Scripts\RespawnScreen.cs
using UnityEngine;

public class RespawnScreen : MonoBehaviour
{
    [SerializeField] private GameObject screen;
    
    public void ShowScreen() => screen.SetActive(true);
    public void HideScreen() => screen.SetActive(false);
}
```

```Scripts\Leaderboard\Leaderboard.cs
using System.Collections.Generic;
using UnityEngine;

public class Leaderboard : MonoBehaviour
{
    // leaderboard: username, score
    private readonly Dictionary<string, LeaderboardCard> _cards = new ();
    
    #region Singleton
    
    public static Leaderboard Instance;
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    #endregion

    /// <summary>
    /// For existing players, add this new player to the leaderboard
    /// </summary>
    /// <param name="playerUsername">new player username</param>
    public void AddPlayerToLeaderboard(string playerUsername)
    {
        var cardObject = Resources.Load<LeaderboardCard>("LeaderboardCard");
        if (!cardObject)
        {
            Debug.LogError($"{nameof(Leaderboard)}: Card Object not found.");
            return;
        }
        
        var spawnedCard = Instantiate(cardObject, transform);
        spawnedCard.SetPlayerNameText(playerUsername);
        spawnedCard.SetPlayerScoreText("0");
        
        _cards.Add(playerUsername, spawnedCard);
    }

    /// <summary>
    /// for the new player, give the full leaderboard including himself.
    /// </summary>
    /// <param name="updatedBoard">all connected players, including myself (new player)</param>
    public void UpdateLeaderboard(Dictionary<string, int> updatedBoard)
    {
        // add existing
        foreach (var player in updatedBoard)
        {
            AddPlayerToLeaderboard(player.Key);
            UpdateCount(player.Key, player.Value);
        }
    }
    
    public void UpdateCount(string playerUsername, int count)
    {
        if (!_cards.TryGetValue(playerUsername, out var card))
        {
            Debug.LogError($"{nameof(Leaderboard)}: Player {playerUsername} not found.");
            return;
        }
        
        card.SetPlayerScoreText(count.ToString());
    }
}
```

```Scripts\Leaderboard\LeaderboardCard.cs
using System;
using UnityEngine;
using TMPro;

public class LeaderboardCard : MonoBehaviour
{
    private TextMeshProUGUI _playerNameText;
    private TextMeshProUGUI _playerScoreText;

    private void Awake()
    {
        _playerNameText = GetComponentInChildren<LeaderboardPlayerName>().GetComponent<TextMeshProUGUI>();
        _playerScoreText = GetComponentInChildren<LeaderboardPlayerScore>().GetComponent<TextMeshProUGUI>();
    }

    public void SetPlayerNameText(string playerName)
    {
        _playerNameText.text = playerName;
    }
    
    public void SetPlayerScoreText(string playerScore)
    {
        _playerScoreText.text = playerScore;
    }
}
```

```Scripts\Leaderboard\LeaderboardPlayerName.cs
using UnityEngine;

public class LeaderboardPlayerName : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
```

```Scripts\Leaderboard\LeaderboardPlayerScore.cs
    using UnityEngine;

public class LeaderboardPlayerScore : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
```

```Scripts\Menu\AuthenticationRequests.cs
using FishNet.Broadcast;
using FishNet.Serializing;

[System.Serializable]
public struct UsernameRequest : IBroadcast
{
    public string Username;
}

[System.Serializable]
public struct UsernameResponse : IBroadcast
{
    public bool Success;
    public string Message;
}
```

```Scripts\Menu\PlayerWindManager.cs
using System;
using UnityEngine;

/// <summary>
/// What moves between scenes locally
/// (not attached to network behavior or anything multiplayer)
/// </summary>
public class PlayerWindManager : MonoBehaviour
{
    public static PlayerWindManager Instance { get; private set; }

    #region Singleton

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
    }

    private void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    #endregion

    public static string ChosenUsername = "";
}
```

```Scripts\Menu\UsernameAuthenticator.cs
using System;
using System.Collections.Generic;
using FishNet;
using FishNet.Authenticating;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Transporting;
using UnityEngine;
using UnityEngine.Events;

public class UsernameAuthenticator : Authenticator
{
    public override event Action<NetworkConnection, bool> OnAuthenticationResult;
    public UnityEvent<bool, string> StoryOnAuthenticationResult = new ();
    
    private readonly HashSet<string> _takenUsernames = new (StringComparer.OrdinalIgnoreCase);

    private void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }

    public override void InitializeOnce(NetworkManager networkManager)
    {
        base.InitializeOnce(networkManager);
        
        // Server: listen for username requests
        networkManager.ServerManager.RegisterBroadcast<UsernameRequest>(OnReceiveUsernameRequest, false);
        
        // client: listen for result
        networkManager.ClientManager.RegisterBroadcast<UsernameResponse>(OnReceiveResponse);
    }
    
    /// <summary>
    /// Server: receives username request from client
    /// </summary>
    private void OnReceiveUsernameRequest(NetworkConnection conn, UsernameRequest request, Channel channel)
    {
        // verify username
        string username = request.Username?.Trim();
        bool success = !string.IsNullOrWhiteSpace(username) && !_takenUsernames.Contains(username);
        if (success)
        {
            _takenUsernames.Add(username);
            conn.CustomData = username;
            Wind.Instance.AddPlayer(conn.ClientId, username);
        }
        
        string message = success ? "Connection Success"  : "Username taken or invalid!";
        
        // response with the result
        UsernameResponse response = new () { Success = success, Message = message };
        InstanceFinder.ServerManager.Broadcast(conn, response, false);
        
        // approve / reject connection
        OnAuthenticationResult?.Invoke(conn, success);
    }
    
    // client: receives result
    private void OnReceiveResponse(UsernameResponse response, Channel channel)
    {
        if (response.Success)
            Debug.Log(response.Message);
        else
            Debug.LogWarning($"Login failed: {response.Message}");
        
        StoryOnAuthenticationResult?.Invoke(response.Success, response.Message);
    }
    
    // cleanup for disconnect
    private void OnEnable()
    {
        InstanceFinder.ServerManager.OnRemoteConnectionState += ServerManager_OnOnRemoteConnectionState;
    }

    private void OnDisable()
    {
        if (InstanceFinder.ServerManager != null)
            InstanceFinder.ServerManager.OnRemoteConnectionState -= ServerManager_OnOnRemoteConnectionState;
    }

    private void ServerManager_OnOnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs args)
    {
        if (args.ConnectionState == RemoteConnectionState.Stopped && conn.CustomData is string username)
        {
            _takenUsernames.Remove(username);
            Wind.Instance.RemovePlayer(conn.ClientId);
        }
    }
}
```

```Scripts\Menu\Wind.cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Moves player data between scenes
/// </summary>
public class Wind : MonoBehaviour
{
    #region Singleton

    public static Wind Instance { get; private set; }
    
    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void OnDestroy()
    {
        if (Instance == this) Instance = null;
    }

    #endregion

    public UnityEvent<string> OnClientApproved = new ();
    public UnityEvent<int> OnClientLeave = new ();

    private Dictionary<int, string> _playerUsernames = new();

    public void AddPlayer(int id, string username)
    {
        if (!_playerUsernames.TryAdd(id, username))
            Debug.LogError("id already exists in Wind's usernames!");
        
        OnClientApproved?.Invoke(username);
    }

    public void RemovePlayer(int id)
    {
        if (!_playerUsernames.Remove(id))
            Debug.LogError("id does not exist in Wind's usernames!");
        
        OnClientLeave?.Invoke(id);
    }

    public bool TryGetUsernameForId(int playerId, out string username)
    {
        return _playerUsernames.TryGetValue(playerId, out username);
    }
}
```

```Scripts\Menu\WindManager.cs
using System.Collections.Generic;
using FishNet.Object;

/// <summary>
/// What goes between scenes in a multiplayer environment
/// </summary>
public class WindManager : NetworkBehaviour
{
    private readonly HashSet<string> _usernames = new();
    public static WindManager Instance { get; private set; }

    #region Singleton

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
    }

    public override void OnStopNetwork()
    {
        base.OnStopNetwork();
        
        if (Instance == this) Instance = null;
    }

    #endregion
    
    public void AddUsername(string username) => _usernames.Add(username);
    
    public void RemoveUsername(string username) => _usernames.Remove(username);
}
```

