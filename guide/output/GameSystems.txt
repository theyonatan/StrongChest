structure:
- GameSystems
    - Player.meta
    - PlayerAddons.meta
    - PlayerSystems.meta
    - Scenes.meta
    - WorldSystems.meta
    - YonderExtras.meta
    - zOverallAssets.meta
  - Player
      - Main Camera.prefab
      - Main Camera.prefab.meta
      - Models.meta
      - Player.asmdef
      - Player.asmdef.meta
      - PlayerNetworkPrefab.asset
      - PlayerNetworkPrefab.asset.meta
      - Resources.meta
      - Scripts.meta
      - ThirdPersonPlayerObject.prefab
      - ThirdPersonPlayerObject.prefab.meta
      - newProject.txt
      - newProject.txt.meta
      - package.json
      - package.json.meta
      - player.prefab
      - player.prefab.meta
    - Models
        - ScalePlayerDemo.prefab
        - ScalePlayerDemo.prefab.meta
        - SpacePirate_diffuse.png
        - SpacePirate_diffuse.png.meta
        - SpacePirate_normal.png
        - SpacePirate_normal.png.meta
        - SpacePirate_specular.png
        - SpacePirate_specular.png.meta
        - character.fbx
        - character.fbx.meta
    - Resources
        - cam.prefab
        - cam.prefab.meta
        - playerStates.meta
      - playerStates
          - WalkingPlayer.asset
          - WalkingPlayer.asset.meta
    - Scripts
        - Animations.meta
        - IPlayerBehavior.cs
        - IPlayerBehavior.cs.meta
        - Input.meta
        - Movement.meta
        - Player.cs
        - Player.cs.meta
        - Signs.meta
        - camera.meta
      - Animations
          - AnimationsManager.cs
          - AnimationsManager.cs.meta
          - AnimatorCoder.cs
          - AnimatorCoder.cs.meta
          - AnimatorValues.cs
          - AnimatorValues.cs.meta
          - OnParameter.cs
          - OnParameter.cs.meta
          - PlayerAnimationsController.controller
          - PlayerAnimationsController.controller.meta
      - Input
          - actionsMaster.cs
          - actionsMaster.cs.meta
          - actionsMaster.inputactions
          - actionsMaster.inputactions.meta
          - inputDirector.cs
          - inputDirector.cs.meta
      - Movement
          - DefaultMovementState.cs
          - DefaultMovementState.cs.meta
          - Helpers.meta
          - MovementManager.cs
          - MovementManager.cs.meta
          - MovementState.cs
          - MovementState.cs.meta
          - MovementStateType.cs
          - MovementStateType.cs.meta
          - PlayerFrictionless.physicMaterial
          - PlayerFrictionless.physicMaterial.meta
          - Ski.meta
          - stateData.meta
        - Helpers
            - IPlayerRotator.cs
            - IPlayerRotator.cs.meta
            - PlayerRotator.cs
            - PlayerRotator.cs.meta
        - Ski
            - skiState.cs
            - skiState.cs.meta
        - stateData
            - PlayerStateData.cs
            - PlayerStateData.cs.meta
            - StateData.cs
            - StateData.cs.meta
      - Signs
          - CameraOrientation.cs
          - CameraOrientation.cs.meta
          - CharacterOrientation.cs
          - CharacterOrientation.cs.meta
          - PlayerGround.cs
          - PlayerGround.cs.meta
          - lookatSign.cs
          - lookatSign.cs.meta
      - camera
          - CameraManager.cs
          - CameraManager.cs.meta
          - CameraState.cs
          - CameraState.cs.meta
          - CameraStates.cs
          - CameraStates.cs.meta
          - states.meta
        - states
            - CameraState2D.cs
            - CameraState2D.cs.meta
            - CameraStateInPlace.cs
            - CameraStateInPlace.cs.meta
            - CameraStateMount.cs
            - CameraStateMount.cs.meta
            - CameraStateSki.cs
            - CameraStateSki.cs.meta
            - ThirdPersonCameraState.cs
            - ThirdPersonCameraState.cs.meta
  - PlayerAddons
      - Cameras.meta
      - CharacterController.meta
      - EXTENSIONS.meta
      - PlayerAddons.asmdef
      - PlayerAddons.asmdef.meta
      - rigidbody.meta
    - Cameras
        - FP_CameraState.cs
        - FP_CameraState.cs.meta
        - TP_CameraState.cs
        - TP_CameraState.cs.meta
    - CharacterController
        - fps.meta
        - tps.meta
      - fps
          - cc_fpState.cs
          - cc_fpState.cs.meta
      - tps
          - Resources.meta
          - cc_tpState.cs
          - cc_tpState.cs.meta
        - Resources
            - tps_animator.controller
            - tps_animator.controller.meta
    - EXTENSIONS
        - cc.meta
        - other.meta
        - rigidbody.meta
      - cc
          - cc_ExtensionKnockback.cs
          - cc_ExtensionKnockback.cs.meta
      - other
          - ExtensionInteractier.cs
          - ExtensionInteractier.cs.meta
          - ExtensionInventory.cs
          - ExtensionInventory.cs.meta
          - ExtensionKillPlayer.cs
          - ExtensionKillPlayer.cs.meta
          - ExtensionScrollCamera.cs
          - ExtensionScrollCamera.cs.meta
          - ExtensionSnowCollector.cs
          - ExtensionSnowCollector.cs.meta
          - Knockbackable.cs
          - Knockbackable.cs.meta
          - Multiplayer.meta
        - Multiplayer
            - CleanupMultiplayer.prefab
            - CleanupMultiplayer.prefab.meta
            - ExtensionNetworkedPlayer.cs
            - ExtensionNetworkedPlayer.cs.meta
            - GameExample.meta
            - IPlayerDataMultiplayer.cs
            - IPlayerDataMultiplayer.cs.meta
            - MultiplayerStoryExample.cs
            - MultiplayerStoryExample.cs.meta
            - OldMultiplayerManager.cs
            - OldMultiplayerManager.cs.meta
            - ShutdownMultiplayer.cs
            - ShutdownMultiplayer.cs.meta
            - storyMultiplayer.prefab
            - storyMultiplayer.prefab.meta
          - GameExample
              - EnemyPlayer.cs
              - EnemyPlayer.cs.meta
      - rigidbody
          - ExtensionKnockback.cs
          - ExtensionKnockback.cs.meta
          - SimpleGrapple.meta
        - SimpleGrapple
            - ExtensionSimpleGraplingHook.cs
            - ExtensionSimpleGraplingHook.cs.meta
            - GrappleTarget.cs
            - GrappleTarget.cs.meta
    - rigidbody
        - Bike.meta
        - DeprecatedFirstPerson.meta
        - FirstPerson.meta
        - Hoverboard.meta
        - StoryControlled.meta
        - ThirdPerson.meta
      - Bike
          - BETA.meta
          - BikeState.cs
          - BikeState.cs.meta
          - bike.unity
          - bike.unity.meta
          - bike_Backup.unity
          - bike_Backup.unity.meta
        - BETA
            - BikeController.cs
            - BikeController.cs.meta
            - Bike_Model.prefab
            - Bike_Model.prefab.meta
            - Bike_v1.prefab
            - Bike_v1.prefab.meta
            - bike_model.meta
            - bike_world.meta
            - default_settings.png
            - default_settings.png.meta
            - slow_settings.png
            - slow_settings.png.meta
          - bike_model
              - bike.fbx
              - bike.fbx.meta
              - emissive.png
              - emissive.png.meta
              - lambert3SG.mat
              - lambert3SG.mat.meta
              - neo_NeoTokyoBike_color.png
              - neo_NeoTokyoBike_color.png.meta
          - bike_world
              - New Terrain 1.asset
              - New Terrain 1.asset.meta
              - New Terrain 2.asset
              - New Terrain 2.asset.meta
              - New Terrain 3.asset
              - New Terrain 3.asset.meta
              - New Terrain 4.asset
              - New Terrain 4.asset.meta
              - New Terrain.asset
              - New Terrain.asset.meta
      - DeprecatedFirstPerson
          - FPSPlayerObject.prefab
          - FPSPlayerObject.prefab.meta
          - FirstPersonCam.prefab
          - FirstPersonCam.prefab.meta
          - GroundMat.physicMaterial
          - GroundMat.physicMaterial.meta
          - daniTest.meta
          - scripts.meta
        - daniTest
            - Color.mat
            - Color.mat.meta
            - ColorAnother.mat
            - ColorAnother.mat.meta
            - PlayerMovement.cs
            - PlayerMovement.cs.meta
            - idk.unity
            - idk.unity.meta
            - moveCameraDani.cs
            - moveCameraDani.cs.meta
        - scripts
            - CameraStateFirstPerson.cs
            - CameraStateFirstPerson.cs.meta
            - FirstPersonState.cs
            - FirstPersonState.cs.meta
            - firstPersonStoryExample.cs
            - firstPersonStoryExample.cs.meta
      - FirstPerson
          - DeprecatedPlayer.prefab
          - DeprecatedPlayer.prefab.meta
          - FPState.cs
          - FPState.cs.meta
          - FPStoryExample.cs
          - FPStoryExample.cs.meta
          - SelfForDisable.cs
          - SelfForDisable.cs.meta
          - story.prefab
          - story.prefab.meta
      - Hoverboard
          - HoverboardCameraState.cs
          - HoverboardCameraState.cs.meta
          - HoverboardState.cs
          - HoverboardState.cs.meta
          - HoverboardStoryExample.cs
          - HoverboardStoryExample.cs.meta
      - StoryControlled
          - StoryControlledPlayer.cs
          - StoryControlledPlayer.cs.meta
      - ThirdPerson
          - FreeLook Camera.prefab
          - FreeLook Camera.prefab.meta
          - ThirdPersonState.cs
          - ThirdPersonState.cs.meta
  - PlayerSystems
      - Combat.meta
      - Cutscenes.meta
      - Inventory + Interactables.meta
      - RNGSystem.meta
      - Stats.meta
      - story.meta
    - Combat
        - Combat.asmdef
        - Combat.asmdef.meta
        - Example.meta
        - Guns.meta
        - Pillars.meta
        - UniqeWeapons.meta
      - Example
          - Puppet.meta
          - Puppet.prefab
          - Puppet.prefab.meta
          - PuppetEnemy.cs
          - PuppetEnemy.cs.meta
        - Puppet
            - blinn1.mat
            - blinn1.mat.meta
            - blinn2.mat
            - blinn2.mat.meta
            - dummy.fbx
            - dummy.fbx.meta
            - hay.png
            - hay.png.meta
            - pTorus6Shape.png
            - pTorus6Shape.png.meta
      - Guns
          - GunBaseExtension.cs
          - GunBaseExtension.cs.meta
          - ProjectileGun.cs
          - ProjectileGun.cs.meta
          - RaycastGun.cs
          - RaycastGun.cs.meta
      - Pillars
          - CrosshairHighlighter.cs
          - CrosshairHighlighter.cs.meta
          - Enemy.cs
          - Enemy.cs.meta
          - IDamagable.cs
          - IDamagable.cs.meta
      - UniqeWeapons
          - Combat.cs
          - Combat.cs.meta
    - Cutscenes
        - CameraKnotRotation.cs
        - CameraKnotRotation.cs.meta
        - Cutscene.cs
        - Cutscene.cs.meta
        - CutsceneCamera.cs
        - CutsceneCamera.cs.meta
        - Cutscenes.asmdef
        - Cutscenes.asmdef.meta
        - CutscenesHelper.cs
        - CutscenesHelper.cs.meta
        - Editor.meta
        - KnotAligner.cs
        - KnotAligner.cs.meta
        - MovieBars.cs
        - MovieBars.cs.meta
        - Resources.meta
      - Editor
          - CreateCutsceneMenu.cs
          - CreateCutsceneMenu.cs.meta
          - CutscenesEditor.asmdef
          - CutscenesEditor.asmdef.meta
          - SpawnCutsceneCamera.cs
          - SpawnCutsceneCamera.cs.meta
          - SplineKnotAligner.cs
          - SplineKnotAligner.cs.meta
      - Resources
          - Cutscene.prefab
          - Cutscene.prefab.meta
          - CutsceneCamera.prefab
          - CutsceneCamera.prefab.meta
          - MovieBars.prefab
          - MovieBars.prefab.meta
          - TrailCamera.prefab
          - TrailCamera.prefab.meta
    - Inventory + Interactables
        - Example.meta
        - Pillars.meta
        - UI Inventory.meta
        - inventoryInteractables.asmdef
        - inventoryInteractables.asmdef.meta
      - Example
          - Pictoicon_Tap.Png
          - Pictoicon_Tap.Png.meta
          - Potion.prefab
          - Potion.prefab.meta
          - PotionItem.cs
          - PotionItem.cs.meta
          - Source.meta
        - Source
            - Icons.meta
            - Item.meta
            - Profile Backgrounds.meta
          - Icons
              - ItemIcon_Bag01.Png
              - ItemIcon_Bag01.Png.meta
              - Pictoicon_Bag.Png
              - Pictoicon_Bag.Png.meta
              - Pictoicon_Gun.Png
              - Pictoicon_Gun.Png.meta
              - Pictoicon_Light.Png
              - Pictoicon_Light.Png.meta
              - Pictoicon_Potion.Png
              - Pictoicon_Potion.Png.meta
          - Item
              - Mushroom.png
              - Mushroom.png.meta
              - Mushroom_Potion2.fbx
              - Mushroom_Potion2.fbx.meta
              - Potion Preview.png
              - Potion Preview.png.meta
              - Potion.png
              - Potion.png.meta
          - Profile Backgrounds
              - Background.jpg
              - Background.jpg.meta
              - clocked.jpg
              - clocked.jpg.meta
              - clockedBetter.jpg
              - clockedBetter.jpg.meta
      - Pillars
          - Interactable.cs
          - Interactable.cs.meta
          - InventoryItem.cs
          - InventoryItem.cs.meta
          - InventorySingleton.cs
          - InventorySingleton.cs.meta
          - ItemAction.cs
          - ItemAction.cs.meta
      - UI Inventory
          - DisplayedItem.prefab
          - DisplayedItem.prefab.meta
          - DraggableItem.cs
          - DraggableItem.cs.meta
          - InventoryManager.cs
          - InventoryManager.cs.meta
          - InventorySlot.cs
          - InventorySlot.cs.meta
          - Item Frame.prefab
          - Item Frame.prefab.meta
    - RNGSystem
        - ExampleLootRoll.cs
        - ExampleLootRoll.cs.meta
        - LootGenerator.cs
        - LootGenerator.cs.meta
        - RNGSystem.asmdef
        - RNGSystem.asmdef.meta
    - Stats
        - StatsSingleton.cs
        - StatsSingleton.cs.meta
        - stats.asmdef
        - stats.asmdef.meta
        - stats.cs
        - stats.cs.meta
    - story
        - Other.meta
        - Speech.meta
        - StoryCheckpoints.meta
        - StoryData.meta
        - StoryObjects.meta
        - StorySystem.meta
        - story.asmdef
        - story.asmdef.meta
        - story.cs
        - story.cs.meta
      - Other
          - CharacterInteract.cs
          - CharacterInteract.cs.meta
          - DefaultAnimation.cs
          - DefaultAnimation.cs.meta
      - Speech
          - Resources.meta
          - SpeechCanvas.cs
          - SpeechCanvas.cs.meta
          - SpeechManager.cs
          - SpeechManager.cs.meta
        - Resources
            - ActiveCanvas.prefab
            - ActiveCanvas.prefab.meta
            - rounded corners.meta
            - speechBubbleTail.png
            - speechBubbleTail.png.meta
          - rounded corners
              - Rounded20px@4x.png
              - Rounded20px@4x.png.meta
              - Rounded40px@4x.png
              - Rounded40px@4x.png.meta
      - StoryCheckpoints
          - Checkpoint.cs
          - Checkpoint.cs.meta
      - StoryData
          - Chapters.cs
          - Chapters.cs.meta
          - Characters.cs
          - Characters.cs.meta
          - Emotions.cs
          - Emotions.cs.meta
          - Resources.meta
        - Resources
            - Player.asset
            - Player.asset.meta
            - System.asset
            - System.asset.meta
            - System.prefab
            - System.prefab.meta
      - StoryObjects
          - StoryObject.cs
          - StoryObject.cs.meta
      - StorySystem
          - StoryCharacter.cs
          - StoryCharacter.cs.meta
          - StoryCharacterPrefab.cs
          - StoryCharacterPrefab.cs.meta
          - StoryCommand.cs
          - StoryCommand.cs.meta
          - StoryExecuter.cs
          - StoryExecuter.cs.meta
          - StoryHelper.cs
          - StoryHelper.cs.meta
          - StoryTrigger.cs
          - StoryTrigger.cs.meta
  - Scenes
      - MultiPlayer.unity
      - MultiPlayer.unity.meta
      - Player.meta
      - Player.unity
      - Player.unity.meta
      - TestWorld.asmdef
      - TestWorld.asmdef.meta
    - Player
        - PlayerStory.cs
        - PlayerStory.cs.meta
  - WorldSystems
      - DayNight.meta
      - GoapAI.meta
      - SegmentGenerator.meta
      - Shops.meta
    - DayNight
        - DayClock.cs
        - DayClock.cs.meta
        - DayNightSystem.cs
        - DayNightSystem.cs.meta
        - Extensions.meta
      - Extensions
          - BiomeManager.cs
          - BiomeManager.cs.meta
          - BiomeProfile.cs
          - BiomeProfile.cs.meta
          - DayNightDebugger.cs
          - DayNightDebugger.cs.meta
          - LevelBiome.cs
          - LevelBiome.cs.meta
          - LightProbeController.cs
          - LightProbeController.cs.meta
          - LightingController.cs
          - LightingController.cs.meta
          - SkyboxController.cs
          - SkyboxController.cs.meta
          - StarfieldController.cs
          - StarfieldController.cs.meta
    - GoapAI
        - GoapAgent.cs
        - GoapAgent.cs.meta
        - Pillars.meta
        - goapai.asmdef
        - goapai.asmdef.meta
      - Pillars
          - Actions.cs
          - Actions.cs.meta
          - Beliefs.cs
          - Beliefs.cs.meta
          - Goals.cs
          - Goals.cs.meta
          - GoapAnimationMapper.cs
          - GoapAnimationMapper.cs.meta
          - GoapAnimator.cs
          - GoapAnimator.cs.meta
          - GoapPlanner.cs
          - GoapPlanner.cs.meta
          - GoapRunner.cs
          - GoapRunner.cs.meta
          - IGoapAgent.cs
          - IGoapAgent.cs.meta
          - Sensor.cs
          - Sensor.cs.meta
          - Strategies.cs
          - Strategies.cs.meta
    - SegmentGenerator
        - Segment.cs
        - Segment.cs.meta
        - SegmentEntranceTrigger.cs
        - SegmentEntranceTrigger.cs.meta
        - SegmentGenerator.asmdef
        - SegmentGenerator.asmdef.meta
        - SegmentStreamer.cs
        - SegmentStreamer.cs.meta
        - StreamingAlgorithms.meta
      - StreamingAlgorithms
          - MilestoneUnlockAlgorithm.cs
          - MilestoneUnlockAlgorithm.cs.meta
          - RandomSegmentAlgorithm.cs
          - RandomSegmentAlgorithm.cs.meta
          - SegmentStreamingAlgorithm.cs
          - SegmentStreamingAlgorithm.cs.meta
    - Shops
        - Shop.asmdef
        - Shop.asmdef.meta
        - Shop.cs
        - Shop.cs.meta
        - ShopItem.cs
        - ShopItem.cs.meta
        - ShopManager.cs
        - ShopManager.cs.meta
  - YonderExtras
      - DefaultPlayerAnimations.meta
      - Fonts.meta
      - UIPrefabs.meta
      - YieldedScripts.meta
    - DefaultPlayerAnimations
        - character@Falling.fbx
        - character@Falling.fbx.meta
        - character@Idle.fbx
        - character@Idle.fbx.meta
        - character@Jumping.fbx
        - character@Jumping.fbx.meta
        - character@Running.fbx
        - character@Running.fbx.meta
        - character@Walking.fbx
        - character@Walking.fbx.meta
    - Fonts
        - ArchivoBlack-Regular SDF.asset
        - ArchivoBlack-Regular SDF.asset.meta
        - Fredoka-Bold SDF.asset
        - Fredoka-Bold SDF.asset.meta
        - Fredoka-Regular SDF.asset
        - Fredoka-Regular SDF.asset.meta
        - Fredoka-VariableFont_wdth,wght SDF.asset
        - Fredoka-VariableFont_wdth,wght SDF.asset.meta
        - Fredoka_Condensed-Bold SDF.asset
        - Fredoka_Condensed-Bold SDF.asset.meta
        - Fredoka_Condensed-Regular SDF.asset
        - Fredoka_Condensed-Regular SDF.asset.meta
        - Fredoka_Expanded-Bold SDF.asset
        - Fredoka_Expanded-Bold SDF.asset.meta
        - Fredoka_Expanded-Regular SDF.asset
        - Fredoka_Expanded-Regular SDF.asset.meta
        - Fredoka_SemiCondensed-Bold SDF.asset
        - Fredoka_SemiCondensed-Bold SDF.asset.meta
        - Fredoka_SemiCondensed-Regular SDF.asset
        - Fredoka_SemiCondensed-Regular SDF.asset.meta
        - Fredoka_SemiExpanded-Bold SDF.asset
        - Fredoka_SemiExpanded-Bold SDF.asset.meta
        - Fredoka_SemiExpanded-Regular SDF.asset
        - Fredoka_SemiExpanded-Regular SDF.asset.meta
        - Heebo-Black SDF.asset
        - Heebo-Black SDF.asset.meta
        - Heebo-Bold SDF.asset
        - Heebo-Bold SDF.asset.meta
        - Heebo-Regular SDF.asset
        - Heebo-Regular SDF.asset.meta
        - Heebo-VariableFont_wght SDF.asset
        - Heebo-VariableFont_wght SDF.asset.meta
        - NunitoSans-Italic-VariableFont_YTLC,opsz,wdth,wght SDF.asset
        - NunitoSans-Italic-VariableFont_YTLC,opsz,wdth,wght SDF.asset.meta
        - NunitoSans-VariableFont_YTLC,opsz,wdth,wght SDF.asset
        - NunitoSans-VariableFont_YTLC,opsz,wdth,wght SDF.asset.meta
        - PlaywriteGBS-Italic-VariableFont_wght SDF.asset
        - PlaywriteGBS-Italic-VariableFont_wght SDF.asset.meta
        - PlaywriteGBS-Regular SDF.asset
        - PlaywriteGBS-Regular SDF.asset.meta
        - PlaywriteGBS-VariableFont_wght SDF.asset
        - PlaywriteGBS-VariableFont_wght SDF.asset.meta
        - Rubik-Black SDF.asset
        - Rubik-Black SDF.asset.meta
        - Rubik-Bold SDF.asset
        - Rubik-Bold SDF.asset.meta
        - Rubik-Regular SDF.asset
        - Rubik-Regular SDF.asset.meta
        - Static.meta
      - Static
          - ArchivoBlack-Regular.ttf
          - ArchivoBlack-Regular.ttf.meta
          - Fredoka-Bold.ttf
          - Fredoka-Bold.ttf.meta
          - Fredoka-Regular.ttf
          - Fredoka-Regular.ttf.meta
          - Fredoka-VariableFont_wdth,wght.ttf
          - Fredoka-VariableFont_wdth,wght.ttf.meta
          - Fredoka_Condensed-Bold.ttf
          - Fredoka_Condensed-Bold.ttf.meta
          - Fredoka_Condensed-Regular.ttf
          - Fredoka_Condensed-Regular.ttf.meta
          - Fredoka_Expanded-Bold.ttf
          - Fredoka_Expanded-Bold.ttf.meta
          - Fredoka_Expanded-Regular.ttf
          - Fredoka_Expanded-Regular.ttf.meta
          - Fredoka_SemiCondensed-Bold.ttf
          - Fredoka_SemiCondensed-Bold.ttf.meta
          - Fredoka_SemiCondensed-Regular.ttf
          - Fredoka_SemiCondensed-Regular.ttf.meta
          - Fredoka_SemiExpanded-Bold.ttf
          - Fredoka_SemiExpanded-Bold.ttf.meta
          - Fredoka_SemiExpanded-Regular.ttf
          - Fredoka_SemiExpanded-Regular.ttf.meta
          - Heebo-Black.ttf
          - Heebo-Black.ttf.meta
          - Heebo-Bold.ttf
          - Heebo-Bold.ttf.meta
          - Heebo-Regular.ttf
          - Heebo-Regular.ttf.meta
          - Heebo-VariableFont_wght.ttf
          - Heebo-VariableFont_wght.ttf.meta
          - NunitoSans-Italic-VariableFont_YTLC,opsz,wdth,wght.ttf
          - NunitoSans-Italic-VariableFont_YTLC,opsz,wdth,wght.ttf.meta
          - NunitoSans-VariableFont_YTLC,opsz,wdth,wght.ttf
          - NunitoSans-VariableFont_YTLC,opsz,wdth,wght.ttf.meta
          - PlaywriteGBS-Italic-VariableFont_wght.ttf
          - PlaywriteGBS-Italic-VariableFont_wght.ttf.meta
          - PlaywriteGBS-Regular.ttf
          - PlaywriteGBS-Regular.ttf.meta
          - PlaywriteGBS-VariableFont_wght.ttf
          - PlaywriteGBS-VariableFont_wght.ttf.meta
          - Rubik-Black.ttf
          - Rubik-Black.ttf.meta
          - Rubik-Bold.ttf
          - Rubik-Bold.ttf.meta
          - Rubik-Regular.ttf
          - Rubik-Regular.ttf.meta
    - UIPrefabs
        - Cursor.prefab
        - Cursor.prefab.meta
        - Version.prefab
        - Version.prefab.meta
        - cursor.meta
      - cursor
          - Circle03.png
          - Circle03.png.meta
          - Circle04.png
          - Circle04.png.meta
    - YieldedScripts
        - Multiplayer.meta
        - ObjectExtensions.meta
        - Timer.meta
      - Multiplayer
          - ExtensionMultiplayer.cs
          - ExtensionMultiplayer.cs.meta
          - Helpers.meta
          - MultiplayerFishnet.asmdef
          - MultiplayerFishnet.asmdef.meta
          - MultiplayerManager.cs
          - MultiplayerManager.cs.meta
          - MultiplayerStoryExample.cs
          - MultiplayerStoryExample.cs.meta
          - StoryExample.prefab
          - StoryExample.prefab.meta
          - playerOnline.prefab
          - playerOnline.prefab.meta
        - Helpers
            - HueClones.cs
            - HueClones.cs.meta
      - ObjectExtensions
          - Extras.asmdef
          - Extras.asmdef.meta
          - GameObjectExtensions.cs
          - GameObjectExtensions.cs.meta
          - Vector3Extensions.cs
          - Vector3Extensions.cs.meta
      - Timer
          - TImer.asmdef
          - TImer.asmdef.meta
          - Timer.cs
          - Timer.cs.meta
  - zOverallAssets
      - Decals.meta
      - Fonts.meta
      - scripts.meta
      - version verifier.meta
    - Decals
        - DecalColliderSync.cs
        - DecalColliderSync.cs.meta
    - Fonts
        - Editor.meta
        - more.meta
      - Editor
          - Fnt2TMPro.meta
        - Fnt2TMPro
            - CustomFntParse.cs
            - CustomFntParse.cs.meta
            - Fnt2TMPro.cs
            - Fnt2TMPro.cs.meta
      - more
          - NunitoSans-VariableFont_YTLC,opsz,wdth,wght SDF.asset
          - NunitoSans-VariableFont_YTLC,opsz,wdth,wght SDF.asset.meta
    - scripts
        - Editor.meta
        - FPSCounter.cs
        - FPSCounter.cs.meta
        - GameObjectExtensions.cs
        - GameObjectExtensions.cs.meta
        - NoteDescription.cs
        - NoteDescription.cs.meta
        - Selection Base.cs
        - Selection Base.cs.meta
        - Timer.cs
        - Timer.cs.meta
        - UpdateTextBasedOnSlider.cs
        - UpdateTextBasedOnSlider.cs.meta
        - Vector3Extensions.cs
        - Vector3Extensions.cs.meta
        - YDeprecated.cs
        - YDeprecated.cs.meta
        - debugging.meta
        - overall.asmdef
        - overall.asmdef.meta
      - Editor
          - CheckForEditorScripts.cs
          - CheckForEditorScripts.cs.meta
          - Overall.editor.asmdef
          - Overall.editor.asmdef.meta
          - SceneAssetInspector.cs
          - SceneAssetInspector.cs.meta
          - SceneDebugBuildLogger.cs
          - SceneDebugBuildLogger.cs.meta
          - SceneSanity.cs
          - SceneSanity.cs.meta
          - SceneSanityV2.cs
          - SceneSanityV2.cs.meta
      - debugging
          - BetterNullRef.cs
          - BetterNullRef.cs.meta
    - version verifier
        - Resources.meta
        - RuinsVersion.asset
        - RuinsVersion.asset.meta
        - VersionTracker.cs
        - VersionTracker.cs.meta
        - VersionUpdater.cs
        - VersionUpdater.cs.meta
        - VersionVerifier.editor.asmdef
        - VersionVerifier.editor.asmdef.meta
      - Resources
          - RuinsVersion.asset
          - RuinsVersion.asset.meta

```Player\Scripts\IPlayerBehavior.cs
public interface IPlayerBehavior
{
    void AwakePlayer() {}
    void OnEnablePlayer() {}
    void StartPlayer() {}
    void FixedUpdatePlayer() {}
    void UpdatePlayer() {}
    void OnDisablePlayer() {}
    void OnDestroyPlayer() {}
}
```

```Player\Scripts\Player.cs
using System;
using UnityEngine;

public class Player : MonoBehaviour
{
    private Camera _cam;
    private string _currentState;
    private PlayerStateData _playerStateData;
    public int PlayerId = -1;
    /// <summary> Make sure ownsAuthority Starts Disabled on: multiplayer - "Player Prefabs" on Multiplayer games! </summary>
    [SerializeField] private bool ownsAuthority = true;
    public bool HasAuthority => ownsAuthority;
    public bool PlayerEnabled = true;

    public Camera GetCamera()
    {
        if (!_cam)
            _cam = Camera.main;
        return _cam;
    }

    public static Player GetPlayer(int playerId)
    {
        foreach (var player in FindObjectsByType<Player>(FindObjectsSortMode.InstanceID))
            if (player.PlayerId == playerId)
                return player;
        
        return FindFirstObjectByType<Player>();
    }

    public static Player GetSelf()
    {
        foreach (var player in FindObjectsByType<Player>(FindObjectsSortMode.InstanceID))
            if (player.HasAuthority)
                return player;
        
        return FindFirstObjectByType<Player>();
    }

    public void SetAuthority(bool value)
    {
        ownsAuthority = value;
    }

    private void SelfStart()
    {
        Load("WalkingPlayer");
    }

    public ref PlayerStateData GetData(string stateName)
    {
        switch (stateName)
        {
            case "Walking":
                Load("WalkingPlayer");
                return ref _playerStateData;
            case "WaterTurbo":
                Load("WaterTurboPlayer");
                return ref _playerStateData;
            default:
                Load("WalkingPlayer");
                return ref _playerStateData;
        }
    }

    private void Load(string stateName)
    {
        if (stateName != _currentState)
            _playerStateData = Resources.Load<PlayerStateData>($"playerStates/{stateName}");
        
        _currentState = stateName;
    }
    
    public void SwapPlayerState<TMovementState, TCameraState>()
        where TMovementState : MovementState, new()
        where TCameraState : CameraState, new()
    {
        var movementManager = gameObject.GetComponent<MovementManager>();
        var cameraManager = gameObject.GetComponent<CameraManager>();

        if (!movementManager || !cameraManager)
            return;

        movementManager.ChangeState(new TMovementState());
        cameraManager.ChargeState(new TCameraState());
    }

    // MonoBehavior Events
    // Multiplayer: DON'T FORGET TO ENABLE PLAYER BEHAVIOURS() BEFORE RUNNING THESE MANUALLY
    IPlayerBehavior[] _playerBehaviors;

    public void DisablePlayerBehaviors()
    {
        PlayerEnabled = false;
    }
    public void EnablePlayerBehaviors()
    {
        PlayerEnabled = true;
    }
    
    public void Awake()
    {
        _playerBehaviors = GetComponents<IPlayerBehavior>();
        
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        foreach (var behavior in _playerBehaviors)
            behavior.AwakePlayer();
    }

    public void OnEnable()
    {
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        foreach (var behavior in _playerBehaviors)
            behavior.OnEnablePlayer();
    }

    public void Start()
    {
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        SelfStart();
        
        foreach (var behavior in _playerBehaviors)
            behavior.StartPlayer();
    }

    public void Update()
    {
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        foreach (var behavior in _playerBehaviors)
            behavior.UpdatePlayer();
    }

    public void FixedUpdate()
    {
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        foreach (var behavior in _playerBehaviors)
            behavior.FixedUpdatePlayer();
    }

    public void OnDisable()
    {
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        foreach (var behavior in _playerBehaviors)
            behavior.OnDisablePlayer();
    }
    
    public void OnDestroy()
    {
        if (!HasAuthority || !PlayerEnabled)
            return;
        
        foreach (var behavior in _playerBehaviors)
            behavior.OnDestroyPlayer();
    }
}
```

```Player\Scripts\Animations\AnimationsManager.cs
using System.Collections.Generic;
using System.Linq;
using AYellowpaper.SerializedCollections;
using UnityEngine;
using SHG.AnimatorCoder;
using UnityEngine.Events;

/// <summary>
/// Guide: AnimationsManager
///
/// there are 2 sides to this:
/// 1. main animations, the movement state gives us the base animations
/// 2. extension animations, adding to those on movement states.
/// calling the builder will not delete old animations, I trust the new state to never call them.
/// it will add or replace animations and parameter configurations.
///
/// about default animations:
/// only the movementstate can call default animations.
/// in the builder, if a new default is requested, it will remove the old and put a new one.
/// extensions will call their animations on top of whats running on the movement states,
/// which are the base player animations.
/// </summary>
public class AnimationsManager : AnimatorCoder, IPlayerBehavior
{
    [SerializeField] private Animator playerAnimator;

    public void OnEnablePlayer()
    {
        if (!GetComponent<Player>().HasAuthority)
            return;

        playerAnimator = GetComponentInChildren<Animator>(true);
        if (!playerAnimator)
            Debug.LogError($"[AnimationManager] animator on character not found!");
    }

    // ===== Loading =====

    public class Builder
    {
        private readonly Dictionary<string, AnimationData> _animations;
        private readonly List<string> _parameters;
        private readonly Dictionary<string, int> _parameterHashes;
        private readonly RuntimeAnimatorController _animatorController;
        private UnityAction _defaultAnimationAction;
        private bool _debugMode;

        public Builder(RuntimeAnimatorController animatorController)
        {
            _animatorController = animatorController;

            _animations = new Dictionary<string, AnimationData>();
            _parameters = new List<string>();
            _parameterHashes = new Dictionary<string, int>();
        }

        public Builder(string animatorControllerName)
        {
            var animatorController = Resources.Load<RuntimeAnimatorController>(animatorControllerName);

            if (!animatorController)
                Debug.LogError($"Animator controller '{animatorControllerName}' not found!");
            else
                _animatorController = animatorController;

            _animations = new Dictionary<string, AnimationData>();
            _parameters = new List<string>();
            _parameterHashes = new Dictionary<string, int>();
        }

        public Builder AddAnimation(string animationName, bool lockLayer = false, string autoNextAnimation = null,
            bool loops = true, float entryCrossfade = 0f, params Connection[] connections)
        {
            _animations.Add(animationName,
                new AnimationData(animationName, lockLayer, autoNextAnimation, loops, entryCrossfade, connections));

            return this;
        }

        /// <summary>
        /// Adds a boolean parameter that is used in the code-based animation system
        /// animator based parameters are used in the animator controller only.
        /// </summary>
        public Builder AddParameter(string parameterName)
        {
            _parameters.Add(parameterName);
            _parameterHashes.Add(parameterName, Animator.StringToHash(parameterName));

            return this;
        }

        /// <summary>
        /// Animation to play when unsure what to play / Default / Entry
        /// </summary>
        /// <param name="defaultAnimationAction">This function will get called which should play the animation</param>
        public Builder SetDefaultAnimation(UnityAction defaultAnimationAction)
        {
            _defaultAnimationAction = defaultAnimationAction;
            
            return this;
        }

        public Builder AllowDebug()
        {
            _debugMode = true;
            
            return this;
        }

        /// <summary>
        /// Building animations:
        /// Adds new animations or overrides existing ones.
        /// same for parameters.
        /// this function also detects the animator and sets the default animation if a new one is requested.
        /// </summary>
        /// <param name="animationsManager"></param>
        public void Build(AnimationsManager animationsManager)
        {
            // -------------------------------------------------------
            // assign animations and parameters to brain - add new or replace if existing.
            // -------------------------------------------------------
            // animations
            animationsManager.Animations ??= new Dictionary<string, AnimationData>();
            foreach (var kvp in _animations)
                animationsManager.Animations[kvp.Key] = kvp.Value;
            
            // parameters
            animationsManager.Parameters ??= new SerializedDictionary<string, bool>();
            foreach (var param in _parameters)
                if (!animationsManager.Parameters.ContainsKey(param))
                    animationsManager.Parameters.Add(param, false);
            
            // parameter hashes
            animationsManager.AnimatorParameters ??= new Dictionary<string, int>();
            foreach (var kvp in _parameterHashes)
                animationsManager.AnimatorParameters[kvp.Key] = kvp.Value;

            // -------------------------------------------------------
            // if movement state, a default animation function is requested.
            if (_defaultAnimationAction != null)
            {
                animationsManager.OnDefaultAnimationRequested.RemoveAllListeners();
                animationsManager.OnDefaultAnimationRequested.AddListener(_defaultAnimationAction);
            }
            
            // -------------------------------------------------------
            // we only initialize the brain once. works between MovementStates.
            if (!animationsManager.Initialized)
            {
                animationsManager.OnEnablePlayer(); // get animator
                animationsManager.playerAnimator.runtimeAnimatorController = _animatorController;
                animationsManager.DebugMode = _debugMode;
                
                
                // initialize brain
                animationsManager.Initialize(animationsManager.playerAnimator);
            }
        }
    }
}
```

```Player\Scripts\Animations\AnimatorCoder.cs
using System.Collections;
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using AYellowpaper.SerializedCollections;
using UnityEngine.Events;

namespace SHG.AnimatorCoder
{
    public abstract class AnimatorCoder : MonoBehaviour
    {
        public bool Initialized;
        public bool DebugMode;
        
        /// <summary> The baseline animation logic on a specific layer </summary>
        private void EntryAnimation() => OnDefaultAnimationRequested?.Invoke();
        protected readonly UnityEvent OnDefaultAnimationRequested = new ();
        
        private Animator _animator;

        protected Dictionary<string, AnimationData> Animations; // all available animations for the current animator controller
        protected SerializedDictionary<string, bool> Parameters; // code animator params to control animation flow
        protected Dictionary<string, int> AnimatorParameters; // animator params to control blend trees and animation values
        
        private string[] _currentAnimation;
        private bool[] _layerLocked;
        private Coroutine[] _currentCoroutine;
        
        private readonly HashSet<string> _loggedErrors = new();

        /// <summary> Sets up the Animator Brain </summary>
        protected void Initialize(Animator animator)
        {
            _animator = animator;
            
            // 3 arrays each the size of the amount of layers.
            _currentCoroutine = new Coroutine[_animator.layerCount];
            _layerLocked = new bool[_animator.layerCount];
            _currentAnimation = new string[_animator.layerCount];

            // setup default animation hash for all layers
            for (int i = 0; i < _animator.layerCount; ++i)
            {
                _layerLocked[i] = false;
                _currentAnimation[i] = null;
            }

            Initialized = true;
            EntryAnimation();
        }

        /// <summary> Returns the current animation that is playing </summary>
        public string GetCurrentAnimation(int layer)
        {
            try
            {
                return _currentAnimation[layer];
            }
            catch
            {
                Debug.LogError("Can't retrieve Current Animation. Fix: Initialize() in Start() and don't exceed number of animator layers");
                return "RESET";
            }
        }

        /// <summary> Sets the whole layer to be locked or unlocked </summary>
        public void SetLocked(bool lockLayer, int layer)
        {
            try
            {
                _layerLocked[layer] = lockLayer;
            }
            catch
            {
                Debug.LogError("Can't retrieve Current Animation. Fix: Initialize() in Start() and don't exceed number of animator layers");
            }
        }

        public bool IsLocked(int layer)
        {
            try
            {
                return _layerLocked[layer];
            }
            catch
            {
                Debug.LogError("Can't retrieve Current Animation. Fix: Initialize() in Start() and don't exceed number of animator layers");
                return false;
            }
        }

        /// <summary> Sets an animator parameter </summary>
        public void SetBool(string parameterName, bool value)
        {
            if (!Initialized) return;
            
            try
            {
                if (Parameters[parameterName] == value)
                    return;
                
                if (DebugMode) Debug.Log($"Setting {parameterName} to {value}");

                Parameters[parameterName] = value;
            }
            catch (Exception e)
            {
                Debug.LogError($"Trying to set: Parameter Not found: {parameterName}\n {e}");
            }
            
            ReEvaluateParameters();
        }

        /// <summary> Returns an animator parameter </summary>
        public bool GetBool(string parameterName)
        {
            try
            {
                return Parameters[parameterName];
            }
            catch
            {
                Debug.LogError($"Trying to get: Parameter Not found: {parameterName}");
                return false;
            }
        }
        
        /// <summary>
        /// Sets a parameter on the actual Unity animator
        /// </summary>
        public void SetFloat(string parameter, float value)
        {
            _animator.SetFloat(AnimatorParameters[parameter], value);
        }

        /// <summary> Takes in the animation details and the animation layer, then attempts to play the animation </summary>
        public void Play(string animationClipName, int layer = 0, float customCrossfade=-1, string reason="Play()")
        {
            if (DebugMode) Debug.LogWarning($"Playing {animationClipName} from {reason}");

            // Verify animation exists
            if (!Animations.TryGetValue(animationClipName, out var animationToPlay))
            {
                Debug.LogError($"Animation '{animationClipName}' was not registered in Builder");
                return;
            }
            
            // verify layer locked
            if (_layerLocked[layer] || _currentAnimation[layer] == animationClipName)
                return;
            
            if (_currentCoroutine[layer] != null)
            {
                StopCoroutine(_currentCoroutine[layer]);
                _currentCoroutine[layer] = null;
            }
            _layerLocked[layer] = animationToPlay.LockLayer;
            _currentAnimation[layer] = animationClipName;

            // before playing, reevaluate to check if we need to pass to somewhere else.
            ReEvaluateParameters();
            
            // Animator Play new animation
            if (Mathf.Approximately(customCrossfade, -1))
                customCrossfade = animationToPlay.EntryCrossfade;
            _animator.CrossFade(Animations[_currentAnimation[layer]].Hash, customCrossfade, layer);

            // Handle if There's next animation
            if (animationToPlay.AutoNextAnimation == null)
            {
                if (!animationToPlay.Loops)
                    _currentCoroutine[layer] = StartCoroutine(WaitAndPlayDefault());
                
                return;
            }
            
            // Handle if there is a next animation:
            // wait for current one to finish in coroutine, and play the next after.
            _currentCoroutine[layer] = StartCoroutine(WaitAndPlayNext());
            
            IEnumerator WaitAndPlayNext()
            {
                yield return null; // let animator switch to current playing animation so we can work with it.
                
                // wait for the current animation to finish
                float delay = _animator.GetNextAnimatorStateInfo(layer).length;
                if (animationToPlay.EntryCrossfade == 0) delay = _animator.GetCurrentAnimatorStateInfo(layer).length;
                
                // Get next animation (earlier we checked not null)
                var nextAnimation = Animations[animationToPlay.AutoNextAnimation];

                // play next animation
                float timeToWait = delay < nextAnimation.EntryCrossfade ? delay : delay - nextAnimation.EntryCrossfade;
                yield return new WaitForSeconds(timeToWait);
                
                // above we can cancel the coroutine in case an overriding animation is played before reaching this
                SetLocked(false, layer);
                Play(nextAnimation.AnimationClipName, layer, reason: "nextClip");
            }

            IEnumerator WaitAndPlayDefault()
            {
                yield return null; // let animator switch to current playing animation so we can work with it.
                
                // wait for the current animation to finish
                float delay = _animator.GetNextAnimatorStateInfo(layer).length;
                if (animationToPlay.EntryCrossfade == 0) delay = _animator.GetCurrentAnimatorStateInfo(layer).length;
                
                yield return new WaitForSeconds(delay);
                
                // above we can cancel the coroutine in case an overriding animation is played before reaching this
                SetLocked(false, layer);
                EntryAnimation();
            }
        }

        /// <summary>
        /// Called after animation finishes or parameter changed
        /// checks if we can transition to a new state based on parameters
        /// </summary>
        private void ReEvaluateParameters()
        {
            if (!_animator) return;

            for (int layer = 0; layer < _currentAnimation.Length; layer++)
            {
                if (_layerLocked[layer])
                    continue;

                var current = _currentAnimation[layer];

                // No active brain animation on this layer yet - nothing to evaluate.
                if (!Animations.TryGetValue(current, out var animData))
                    continue;

                foreach (var possible in animData.FollowingAnimations)
                {
                    if (!possible.Evaluate(Parameters)) continue;

                    Play(possible.ResultAnimationName, layer, possible.CustomCrossfade);
                    
                    return;
                }
            }
        }
    }

    /// <summary> Holds all data about an animation </summary>
    [Serializable]
    public class AnimationData
    {
        public readonly string AnimationClipName;
        
        public int Hash;
        
        /// <summary> Should the layer lock for this animation? </summary>
        public readonly bool LockLayer;
        
        /// <summary> Should an animation play immediately after? </summary>
        public string AutoNextAnimation;
        
        /// <summary> Should there be a transition time into this animation? </summary>
        public float EntryCrossfade;

        /// <summary> Does this animation loop? e.g. walking, idle </summary>
        public bool Loops;

        /// <summary> Next animations with conditions </summary>
        public IReadOnlyList<Connection> FollowingAnimations;

        /// <summary> Sets the animation data </summary>
        public AnimationData(string animationClipName = "RESET", bool lockLayer = false, string autoNextAnimation = null, bool loops = true, float entryCrossfade = 0, IReadOnlyList<Connection> conditions = null)
        {
            AnimationClipName = animationClipName;
            LockLayer = lockLayer;
            AutoNextAnimation = autoNextAnimation;
            Loops = loops;
            EntryCrossfade = entryCrossfade;
            FollowingAnimations = conditions ?? new List<Connection>();
            Hash = Animator.StringToHash(animationClipName);
        }
    }

    public class Connection
    {
        public string ResultAnimationName { get; private set; }
        public float CustomCrossfade;
        public List<AnimationParameter> Conditions { get; } = new();
        
        public static Connection To(string animationName, float customCrossfade=-1) => 
            new() { ResultAnimationName = animationName, CustomCrossfade =  customCrossfade };

        public Connection When(string param, bool value) 
        {
            Conditions.Add(new AnimationParameter(param, value));
            return this;
        }

        public bool Evaluate(Dictionary<string, bool> parameters)
        {
            if (Conditions == null || Conditions.Count == 0)
                return false;

            return Conditions.All(c => parameters[c.ParameterName] == c.TargetCondition);
        }
    }
    
    public class AnimationParameter
    {
        public readonly string ParameterName;
        public readonly bool TargetCondition;
        
        public AnimationParameter(string parameterName, bool targetValue)
        {
            ParameterName = parameterName;
            TargetCondition = targetValue;
        }
    }
}
```

```Player\Scripts\Animations\AnimatorValues.cs

```

```Player\Scripts\Animations\OnParameter.cs

```

```Player\Scripts\camera\CameraManager.cs
using Unity.Cinemachine;
using UnityEngine;

public class CameraManager : MonoBehaviour, IPlayerBehavior
{
    /// <summary>
    /// manages the different camera states.
    /// 
    /// CameraState will have many inheriting states, each for a different camera mode. <see cref="CameraState"/>
    /// 
    /// In order to change the camera state, a story or extension would call ChargeState.
    /// 
    /// awesome! :)
    /// </summary>

    // States
    [SerializeReference]
    private CameraState _currentState;
    public CameraState StartingState = null;

    // GameObjects:
    public CinemachineCamera CurrentCinemachineComponent;

    // References
    private Player _player;
    private InputDirector _inputDirector;

    // values
    public Vector2 CameraSpeed
    {
        get => _currentState.CameraSpeed;
        set => _currentState.CameraSpeed = value;
    }

    public void AwakePlayer()
    {
        // States:
        _currentState = new CameraStateInPlace();
        _player = GetComponent<Player>();
    }

    public void OnEnablePlayer()
    {
        if (!_player.HasAuthority)
            return;
        
        // subscribe to all input events:
        _inputDirector = InputDirector.Instance;
        _inputDirector.OnDisablePlayerMovement += DisableCamera;
        _inputDirector.OnEnablePlayerMovement += EnableCamera;

        // player object:
        var cameraObject = GameObject.FindGameObjectWithTag("DefaultCam");
        if (cameraObject != null)
            CurrentCinemachineComponent = cameraObject.GetComponent<CinemachineCamera>();

        // Starting State:
        if (StartingState != null)
            _currentState = StartingState;
        
        Debug.Log("CamManager - Start");
        _currentState.LoadState(this, _inputDirector);
        _currentState.EnterState();
    }

    /// <summary>
    /// charge the camera with a new state (and load it).
    /// if we use cinemachine on that state, we will instantiate a new object with the cinemachine component.
    /// </summary>
    /// <param name="newState"></param>
    /// <param name="cinemachineCameraToSpawn"></param>
    public void ChargeState(CameraState newState, GameObject cinemachineCameraToSpawn = null)
    {
        if (!_player.HasAuthority)
            return;
        
        // verify we need to switch
        if (newState.GetType() == _currentState.GetType())
            return;

        // clean state
        _currentState?.ClearState();

        // switch cinemachine virtual camera
        cinemachineCameraToSpawn ??= GetResources_DefaultVirtualCamera();
        
        // destroy previous state cinemachine object
        if (CurrentCinemachineComponent &&
            cinemachineCameraToSpawn != CurrentCinemachineComponent.gameObject)
        {
            Destroy(CurrentCinemachineComponent);
        }
        
        // apply new cinemachine object
        if (cinemachineCameraToSpawn)
            spawnNewVirtualCamera(cinemachineCameraToSpawn);
        
        else // no cinemachine object is used for this state
            CurrentCinemachineComponent = null;
        
        // enter new state
        Debug.Log("Swap State");
        _currentState = newState;
        _currentState.LoadState(this, InputDirector.Instance);
        _currentState.EnterState();
    }

    GameObject GetResources_DefaultVirtualCamera()
    {
        var virtualCamera = Resources.Load<GameObject>("cam");

        if (!virtualCamera)
            Debug.LogWarning("Cannot find virtual camera in resources folder!");
        
        return virtualCamera;
    }

    void spawnNewVirtualCamera(GameObject cinemachineComponent)
    {
        // spawn at camera position to kill any bendings
        var cam = _player.GetCamera();
        var spawnedCameraObject = cam
            ? Instantiate(cinemachineComponent, cam.transform.position, cam.transform.rotation)
            : Instantiate(cinemachineComponent, transform.parent);

        CurrentCinemachineComponent =
            spawnedCameraObject.GetComponent<CinemachineCamera>();
        
        // give new camera priority
        if (CurrentCinemachineComponent)
            CutscenesHelper.GiveCameraPriority(CurrentCinemachineComponent);
    }

    public void UpdatePlayer()
    {
        if (!_player.HasAuthority)
            return;
        
        _currentState.UpdateState();
    }

    public void OnDestroyPlayer()
    {
        if (_currentState != null)
            _currentState.ClearState();

        // clear events
        _inputDirector.OnDisablePlayerMovement -= DisableCamera;
        _inputDirector.OnEnablePlayerMovement -= EnableCamera;
    }

    public void EnableCamera()
    {
        _currentState.CanLookAround = true;
    }

    public void DisableCamera()
    {
        _currentState.CanLookAround = false;
    }
}
```

```Player\Scripts\camera\CameraState.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public abstract class CameraState
{
    /// <summary>
    /// /// CameraState will have many inheriting states, each for a different camera mode.
    /// What is a camera mode?
    /// 
    /// glad you asked!
    /// example for 2 camera modes:
    /// - a camera going around the player, for a third person shooter
    /// - a camera stuck on a 2d grid, following the player (a sideview, 2d game camera)
    /// 
    /// there is no default here, the camera's spawn state is completely dependent on the scene we spawn at.
    /// also the camera states are controlled by the camera manager, it charges a state and than activates it.
    /// the only thing that can change a state is the camera manager, and the only one who can access it is the movement manager and
    /// in rare cases, the story manager.
    /// 
    /// 
    /// EnterState() - loads the current camera state.
    /// ClearState() - clears the current camera state so the camera is ready for switching.
    /// UpdateState() - I don't use update a lot with cameras since I use cinemachine, but it's good to have, just in case. :)
    /// 
    /// Receiving input:
    /// Every camera state will have a reference to the InputManager,
    /// and will create it's own functions upon receving input.
    /// usually, these functions will just be assigining the input to values so the update() can use them later.
    /// </summary>


    // references
    protected InputDirector InputDirector;

    // Settings
    public Vector2 CameraSpeed = Vector2.one;
    public float HorizontalSensitivity = 1.0f;
    public float VerticalSensitivity = 1.0f;
    public float ZoomSensitivity = 1.0f;

    // State data
    public bool CanLookAround = true;
    protected CameraManager Manager;
    
    // State machine
    public abstract void LoadState(CameraManager manager, InputDirector director);
    public abstract void EnterState();
    public abstract void UpdateState();
    public abstract void FixedUpdate();
    public abstract void ClearState();
    public abstract void OnDestroy();
}
```

```Player\Scripts\camera\CameraStates.cs
public enum CameraStates
{
    Normal, // Regular State for everything.
    Mounted, // On a mount
    Null, // default for general, would only use in editor
    Cutscene, // for cutscenes
    Sitting, // for when sitting on a bench, chair or just regular viewing the world
    Ship, // AbyssRacer!!!!
    SideView, // for when sideviewing, 2D parts
    Ski // Ski
}
```

```Player\Scripts\camera\states\CameraState2D.cs
using UnityEngine;

public class CameraState2D : CameraState
{
    public override void ClearState()
    {
        throw new System.NotImplementedException();
    }

    public override void FixedUpdate()
    {
        throw new System.NotImplementedException();
    }

    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
    }

    public override void EnterState()
    {
        throw new System.NotImplementedException();
    }

    public override void UpdateState()
    {
        throw new System.NotImplementedException();
    }

    public override void OnDestroy()
    {
        throw new System.NotImplementedException();
    }
}
```

```Player\Scripts\camera\states\CameraStateInPlace.cs
using UnityEngine;

public class CameraStateInPlace : CameraState
{
    public override void ClearState()
    {
        
    }

    public override void FixedUpdate()
    {
        
    }

    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
        
    }

    public override void EnterState()
    {
        
    }

    public override void UpdateState()
    {
        
    }
    public override void OnDestroy()
    {
        
    }
}
```

```Player\Scripts\camera\states\CameraStateMount.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CameraStateMount : CameraState
{
    public override void ClearState()
    {
        throw new System.NotImplementedException();
    }

    public override void FixedUpdate()
    {
        throw new System.NotImplementedException();
    }

    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
    }

    public override void EnterState()
    {
        throw new System.NotImplementedException();
    }

    public override void UpdateState()
    {
        throw new System.NotImplementedException();
    }

    public override void OnDestroy()
    {
        throw new System.NotImplementedException();
    }
}
```

```Player\Scripts\camera\states\CameraStateSki.cs
using UnityEngine;

public class CameraStateSki : CameraState
{
    public override void ClearState()
    {
        throw new System.NotImplementedException();
    }

    public override void FixedUpdate()
    {
        throw new System.NotImplementedException();
    }

    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
    }

    public override void EnterState()
    {
        throw new System.NotImplementedException();
    }

    public override void UpdateState()
    {
        throw new System.NotImplementedException();
    }

    public override void OnDestroy()
    {
        throw new System.NotImplementedException();
    }
}
```

```Player\Scripts\camera\states\ThirdPersonCameraState.cs
using UnityEngine;
using Unity.Cinemachine;

public class ThirdPersonCameraState : CameraState
{
    // Const
    private CinemachineFreeLook _freelookCamera;
    private GameObject _player;
    private Transform _lookat;

    public override void ClearState()
    {

    }

    public override void FixedUpdate()
    {

    }

    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
        _freelookCamera = manager.transform.parent.GetComponentInChildren<CinemachineFreeLook>();

        PlayerStateData localData = Resources.Load<PlayerStateData>("playerStates/normalPlayer");
        CameraSpeed = localData.CameraSpeed;
        
        _player = manager.transform.parent.gameObject;
        _lookat = _player.GetComponentInChildren<LookatSign>().transform;
        
        _freelookCamera.Follow = _player.transform;
        _freelookCamera.LookAt = _lookat;
    }

    public override void EnterState()
    {
        //freelookCamera.m_XAxis.m_MaxSpeed = cameraSpeed.x;
        //freelookCamera.m_YAxis.m_MaxSpeed = cameraSpeed.y;
    }

    public override void UpdateState()
    {
        
    }

    public override void OnDestroy()
    {
        
    }
}
```

```Player\Scripts\Input\actionsMaster.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.14.2
//     from Assets/GameSystems/Player/Scripts/Input/actionsMaster.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

/// <summary>
/// Provides programmatic access to <see cref="InputActionAsset" />, <see cref="InputActionMap" />, <see cref="InputAction" /> and <see cref="InputControlScheme" /> instances defined in asset "Assets/GameSystems/Player/Scripts/Input/actionsMaster.inputactions".
/// </summary>
/// <remarks>
/// This class is source generated and any manual edits will be discarded if the associated asset is reimported or modified.
/// </remarks>
/// <example>
/// <code>
/// using namespace UnityEngine;
/// using UnityEngine.InputSystem;
///
/// // Example of using an InputActionMap named "Player" from a UnityEngine.MonoBehaviour implementing callback interface.
/// public class Example : MonoBehaviour, MyActions.IPlayerActions
/// {
///     private MyActions_Actions m_Actions;                  // Source code representation of asset.
///     private MyActions_Actions.PlayerActions m_Player;     // Source code representation of action map.
///
///     void Awake()
///     {
///         m_Actions = new MyActions_Actions();              // Create asset object.
///         m_Player = m_Actions.Player;                      // Extract action map object.
///         m_Player.AddCallbacks(this);                      // Register callback interface IPlayerActions.
///     }
///
///     void OnDestroy()
///     {
///         m_Actions.Dispose();                              // Destroy asset object.
///     }
///
///     void OnEnable()
///     {
///         m_Player.Enable();                                // Enable all actions within map.
///     }
///
///     void OnDisable()
///     {
///         m_Player.Disable();                               // Disable all actions within map.
///     }
///
///     #region Interface implementation of MyActions.IPlayerActions
///
///     // Invoked when "Move" action is either started, performed or canceled.
///     public void OnMove(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnMove: {context.ReadValue&lt;Vector2&gt;()}");
///     }
///
///     // Invoked when "Attack" action is either started, performed or canceled.
///     public void OnAttack(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnAttack: {context.ReadValue&lt;float&gt;()}");
///     }
///
///     #endregion
/// }
/// </code>
/// </example>
public partial class @ActionsMaster: IInputActionCollection2, IDisposable
{
    /// <summary>
    /// Provides access to the underlying asset instance.
    /// </summary>
    public InputActionAsset asset { get; }

    /// <summary>
    /// Constructs a new instance.
    /// </summary>
    public @ActionsMaster()
    {
        asset = InputActionAsset.FromJson(@"{
    ""version"": 1,
    ""name"": ""actionsMaster"",
    ""maps"": [
        {
            ""name"": ""Player"",
            ""id"": ""b630a8af-b235-45a2-9d18-b176891df93c"",
            ""actions"": [
                {
                    ""name"": ""Movement"",
                    ""type"": ""Value"",
                    ""id"": ""18ac098e-e77f-411e-bedc-aefbe92d9fbb"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Look"",
                    ""type"": ""Value"",
                    ""id"": ""a758617a-52fc-49dd-8836-9ed6462b0428"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Zoom"",
                    ""type"": ""Value"",
                    ""id"": ""5ba122c5-91e4-4b95-b3a4-9e661fcf961f"",
                    ""expectedControlType"": ""Axis"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""MouseX"",
                    ""type"": ""PassThrough"",
                    ""id"": ""9b6f7fbe-7a90-4a13-96d6-7fa18cdf4dfa"",
                    ""expectedControlType"": ""Axis"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""MouseY"",
                    ""type"": ""PassThrough"",
                    ""id"": ""b354cf1c-7979-480f-b04d-6f8d989b4c5f"",
                    ""expectedControlType"": ""Axis"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Jumping"",
                    ""type"": ""Button"",
                    ""id"": ""da114936-c430-4305-8b28-730e22bfcb58"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Running"",
                    ""type"": ""Button"",
                    ""id"": ""92dc60e8-3430-4640-96b2-3df9d5fefcca"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Crouch"",
                    ""type"": ""Button"",
                    ""id"": ""4201029f-825c-4e0c-aad8-c0ac0078189f"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Fire1"",
                    ""type"": ""Button"",
                    ""id"": ""32593bf3-dc52-4349-8023-baf07509d4a0"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Interact"",
                    ""type"": ""Button"",
                    ""id"": ""ca4469e6-650d-4e93-bcca-bb969b13cd17"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Inventory"",
                    ""type"": ""Button"",
                    ""id"": ""364f04f4-09b5-47ba-ba29-e5db7af4af20"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Combat"",
                    ""type"": ""Button"",
                    ""id"": ""4e0e708c-a7d6-45fe-9ab5-92ea5fd14c64"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""FlameThrower"",
                    ""type"": ""Button"",
                    ""id"": ""16429ff8-7a83-4ecd-ad17-de669e08860c"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""MainMenu"",
                    ""type"": ""Button"",
                    ""id"": ""ee037276-d98f-48ea-86b3-2f511d39bc62"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""TimeSwap"",
                    ""type"": ""Button"",
                    ""id"": ""1c2d801e-7ddc-4121-b69e-35b67aa037bd"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": ""WASD"",
                    ""id"": ""bcd97bec-e60e-48a1-9d5b-e28f9c9bb396"",
                    ""path"": ""2DVector(mode=2)"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""7b5dbd72-8db2-43eb-8106-9052c88a500a"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""c7be4a63-bcb3-49eb-a1e6-079a59119f4e"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""21c3b41f-c4aa-485c-a8b7-458d7a8de896"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""053a2c12-274a-4502-b44a-f5e0e6dbbf38"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""5ec8d81a-e4d5-4c95-9469-fd9e3566ed72"",
                    ""path"": ""<Gamepad>/leftStick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""0d16b726-071e-4c49-a397-4cac7177bea7"",
                    ""path"": ""<Mouse>/delta/x"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""MouseX"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""44ecd46f-0b7a-4baf-b60f-26c0cfb3e6f7"",
                    ""path"": ""<Joystick>/stick/x"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""MouseX"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""fd188abc-27df-464e-b850-7e9dc7900b02"",
                    ""path"": ""<Mouse>/delta/y"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""MouseY"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""0c571149-c19a-4530-974e-1629879971d8"",
                    ""path"": ""<Gamepad>/dpad/y"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""MouseY"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e0272589-c1e8-4422-96a7-ed7cca5e2e28"",
                    ""path"": ""<Keyboard>/space"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Jumping"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c1f57e1d-3561-4bf6-9814-b381aa672e9e"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Jumping"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""8f2cac3c-359d-4d01-a00e-6df48cfd7f57"",
                    ""path"": ""<Gamepad>/buttonSouth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Running"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5ec9c3ed-cac4-4fba-a220-4f187353207c"",
                    ""path"": ""<Keyboard>/leftShift"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Running"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""43aab101-7569-4a8e-a8cf-6d2130244c34"",
                    ""path"": ""<Mouse>/delta"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Look"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1c34ed19-ec4c-4985-ab1c-82057b0df9b9"",
                    ""path"": ""<Mouse>/scroll/y"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Zoom"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""aa5338ed-3919-4f3f-95a6-fc1c295d0528"",
                    ""path"": ""<Keyboard>/leftCtrl"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Crouch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""eb4ed8c0-9b4f-429a-a377-65d46faf6dda"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Fire1"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""7aa78a6a-63c1-43bd-bedc-5184e83514ac"",
                    ""path"": ""<Gamepad>/rightTrigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""main"",
                    ""action"": ""Fire1"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5adee641-ccee-4481-9024-5fbb0e66502a"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Interact"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e1777ae6-40ed-4297-8eb0-f9c9b5dbbbf6"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Interact"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""326405aa-d77e-40ba-9607-4b84999e8c5d"",
                    ""path"": ""<Keyboard>/tab"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Inventory"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""6e191ecc-8434-4242-8b6c-0406ae42be41"",
                    ""path"": ""<Gamepad>/start"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Inventory"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""52f144f6-e425-4ce0-b69f-7307438e8af1"",
                    ""path"": ""<Keyboard>/q"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Combat"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""7a14ca43-f901-46fd-8a91-c6353ee5172a"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Combat"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""bcc0720f-f5a1-4eb2-beab-2e4e642a9a8f"",
                    ""path"": ""<Mouse>/rightButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""FlameThrower"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5458b6ad-6f83-4009-ad49-8104a50ca215"",
                    ""path"": ""<Gamepad>/leftTrigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""FlameThrower"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""b23c132b-58c4-48e2-8abe-283ab6c61f7d"",
                    ""path"": ""<Keyboard>/p"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""MainMenu"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""0fb5e391-241e-451b-bb07-6c22836ee2e7"",
                    ""path"": ""<Keyboard>/q"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TimeSwap"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": [
        {
            ""name"": ""main"",
            ""bindingGroup"": ""main"",
            ""devices"": []
        }
    ]
}");
        // Player
        m_Player = asset.FindActionMap("Player", throwIfNotFound: true);
        m_Player_Movement = m_Player.FindAction("Movement", throwIfNotFound: true);
        m_Player_Look = m_Player.FindAction("Look", throwIfNotFound: true);
        m_Player_Zoom = m_Player.FindAction("Zoom", throwIfNotFound: true);
        m_Player_MouseX = m_Player.FindAction("MouseX", throwIfNotFound: true);
        m_Player_MouseY = m_Player.FindAction("MouseY", throwIfNotFound: true);
        m_Player_Jumping = m_Player.FindAction("Jumping", throwIfNotFound: true);
        m_Player_Running = m_Player.FindAction("Running", throwIfNotFound: true);
        m_Player_Crouch = m_Player.FindAction("Crouch", throwIfNotFound: true);
        m_Player_Fire1 = m_Player.FindAction("Fire1", throwIfNotFound: true);
        m_Player_Interact = m_Player.FindAction("Interact", throwIfNotFound: true);
        m_Player_Inventory = m_Player.FindAction("Inventory", throwIfNotFound: true);
        m_Player_Combat = m_Player.FindAction("Combat", throwIfNotFound: true);
        m_Player_FlameThrower = m_Player.FindAction("FlameThrower", throwIfNotFound: true);
        m_Player_MainMenu = m_Player.FindAction("MainMenu", throwIfNotFound: true);
        m_Player_TimeSwap = m_Player.FindAction("TimeSwap", throwIfNotFound: true);
    }

    ~@ActionsMaster()
    {
        UnityEngine.Debug.Assert(!m_Player.enabled, "This will cause a leak and performance issues, ActionsMaster.Player.Disable() has not been called.");
    }

    /// <summary>
    /// Destroys this asset and all associated <see cref="InputAction"/> instances.
    /// </summary>
    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindingMask" />
    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.devices" />
    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.controlSchemes" />
    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Contains(InputAction)" />
    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.GetEnumerator()" />
    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    /// <inheritdoc cref="IEnumerable.GetEnumerator()" />
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Enable()" />
    public void Enable()
    {
        asset.Enable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Disable()" />
    public void Disable()
    {
        asset.Disable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindings" />
    public IEnumerable<InputBinding> bindings => asset.bindings;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindAction(string, bool)" />
    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindBinding(InputBinding, out InputAction)" />
    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Player
    private readonly InputActionMap m_Player;
    private List<IPlayerActions> m_PlayerActionsCallbackInterfaces = new List<IPlayerActions>();
    private readonly InputAction m_Player_Movement;
    private readonly InputAction m_Player_Look;
    private readonly InputAction m_Player_Zoom;
    private readonly InputAction m_Player_MouseX;
    private readonly InputAction m_Player_MouseY;
    private readonly InputAction m_Player_Jumping;
    private readonly InputAction m_Player_Running;
    private readonly InputAction m_Player_Crouch;
    private readonly InputAction m_Player_Fire1;
    private readonly InputAction m_Player_Interact;
    private readonly InputAction m_Player_Inventory;
    private readonly InputAction m_Player_Combat;
    private readonly InputAction m_Player_FlameThrower;
    private readonly InputAction m_Player_MainMenu;
    private readonly InputAction m_Player_TimeSwap;
    /// <summary>
    /// Provides access to input actions defined in input action map "Player".
    /// </summary>
    public struct PlayerActions
    {
        private @ActionsMaster m_Wrapper;

        /// <summary>
        /// Construct a new instance of the input action map wrapper class.
        /// </summary>
        public PlayerActions(@ActionsMaster wrapper) { m_Wrapper = wrapper; }
        /// <summary>
        /// Provides access to the underlying input action "Player/Movement".
        /// </summary>
        public InputAction @Movement => m_Wrapper.m_Player_Movement;
        /// <summary>
        /// Provides access to the underlying input action "Player/Look".
        /// </summary>
        public InputAction @Look => m_Wrapper.m_Player_Look;
        /// <summary>
        /// Provides access to the underlying input action "Player/Zoom".
        /// </summary>
        public InputAction @Zoom => m_Wrapper.m_Player_Zoom;
        /// <summary>
        /// Provides access to the underlying input action "Player/MouseX".
        /// </summary>
        public InputAction @MouseX => m_Wrapper.m_Player_MouseX;
        /// <summary>
        /// Provides access to the underlying input action "Player/MouseY".
        /// </summary>
        public InputAction @MouseY => m_Wrapper.m_Player_MouseY;
        /// <summary>
        /// Provides access to the underlying input action "Player/Jumping".
        /// </summary>
        public InputAction @Jumping => m_Wrapper.m_Player_Jumping;
        /// <summary>
        /// Provides access to the underlying input action "Player/Running".
        /// </summary>
        public InputAction @Running => m_Wrapper.m_Player_Running;
        /// <summary>
        /// Provides access to the underlying input action "Player/Crouch".
        /// </summary>
        public InputAction @Crouch => m_Wrapper.m_Player_Crouch;
        /// <summary>
        /// Provides access to the underlying input action "Player/Fire1".
        /// </summary>
        public InputAction @Fire1 => m_Wrapper.m_Player_Fire1;
        /// <summary>
        /// Provides access to the underlying input action "Player/Interact".
        /// </summary>
        public InputAction @Interact => m_Wrapper.m_Player_Interact;
        /// <summary>
        /// Provides access to the underlying input action "Player/Inventory".
        /// </summary>
        public InputAction @Inventory => m_Wrapper.m_Player_Inventory;
        /// <summary>
        /// Provides access to the underlying input action "Player/Combat".
        /// </summary>
        public InputAction @Combat => m_Wrapper.m_Player_Combat;
        /// <summary>
        /// Provides access to the underlying input action "Player/FlameThrower".
        /// </summary>
        public InputAction @FlameThrower => m_Wrapper.m_Player_FlameThrower;
        /// <summary>
        /// Provides access to the underlying input action "Player/MainMenu".
        /// </summary>
        public InputAction @MainMenu => m_Wrapper.m_Player_MainMenu;
        /// <summary>
        /// Provides access to the underlying input action "Player/TimeSwap".
        /// </summary>
        public InputAction @TimeSwap => m_Wrapper.m_Player_TimeSwap;
        /// <summary>
        /// Provides access to the underlying input action map instance.
        /// </summary>
        public InputActionMap Get() { return m_Wrapper.m_Player; }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Enable()" />
        public void Enable() { Get().Enable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Disable()" />
        public void Disable() { Get().Disable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.enabled" />
        public bool enabled => Get().enabled;
        /// <summary>
        /// Implicitly converts an <see ref="PlayerActions" /> to an <see ref="InputActionMap" /> instance.
        /// </summary>
        public static implicit operator InputActionMap(PlayerActions set) { return set.Get(); }
        /// <summary>
        /// Adds <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <param name="instance">Callback instance.</param>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c> or <paramref name="instance"/> have already been added this method does nothing.
        /// </remarks>
        /// <seealso cref="PlayerActions" />
        public void AddCallbacks(IPlayerActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Add(instance);
            @Movement.started += instance.OnMovement;
            @Movement.performed += instance.OnMovement;
            @Movement.canceled += instance.OnMovement;
            @Look.started += instance.OnLook;
            @Look.performed += instance.OnLook;
            @Look.canceled += instance.OnLook;
            @Zoom.started += instance.OnZoom;
            @Zoom.performed += instance.OnZoom;
            @Zoom.canceled += instance.OnZoom;
            @MouseX.started += instance.OnMouseX;
            @MouseX.performed += instance.OnMouseX;
            @MouseX.canceled += instance.OnMouseX;
            @MouseY.started += instance.OnMouseY;
            @MouseY.performed += instance.OnMouseY;
            @MouseY.canceled += instance.OnMouseY;
            @Jumping.started += instance.OnJumping;
            @Jumping.performed += instance.OnJumping;
            @Jumping.canceled += instance.OnJumping;
            @Running.started += instance.OnRunning;
            @Running.performed += instance.OnRunning;
            @Running.canceled += instance.OnRunning;
            @Crouch.started += instance.OnCrouch;
            @Crouch.performed += instance.OnCrouch;
            @Crouch.canceled += instance.OnCrouch;
            @Fire1.started += instance.OnFire1;
            @Fire1.performed += instance.OnFire1;
            @Fire1.canceled += instance.OnFire1;
            @Interact.started += instance.OnInteract;
            @Interact.performed += instance.OnInteract;
            @Interact.canceled += instance.OnInteract;
            @Inventory.started += instance.OnInventory;
            @Inventory.performed += instance.OnInventory;
            @Inventory.canceled += instance.OnInventory;
            @Combat.started += instance.OnCombat;
            @Combat.performed += instance.OnCombat;
            @Combat.canceled += instance.OnCombat;
            @FlameThrower.started += instance.OnFlameThrower;
            @FlameThrower.performed += instance.OnFlameThrower;
            @FlameThrower.canceled += instance.OnFlameThrower;
            @MainMenu.started += instance.OnMainMenu;
            @MainMenu.performed += instance.OnMainMenu;
            @MainMenu.canceled += instance.OnMainMenu;
            @TimeSwap.started += instance.OnTimeSwap;
            @TimeSwap.performed += instance.OnTimeSwap;
            @TimeSwap.canceled += instance.OnTimeSwap;
        }

        /// <summary>
        /// Removes <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <remarks>
        /// Calling this method when <paramref name="instance" /> have not previously been registered has no side-effects.
        /// </remarks>
        /// <seealso cref="PlayerActions" />
        private void UnregisterCallbacks(IPlayerActions instance)
        {
            @Movement.started -= instance.OnMovement;
            @Movement.performed -= instance.OnMovement;
            @Movement.canceled -= instance.OnMovement;
            @Look.started -= instance.OnLook;
            @Look.performed -= instance.OnLook;
            @Look.canceled -= instance.OnLook;
            @Zoom.started -= instance.OnZoom;
            @Zoom.performed -= instance.OnZoom;
            @Zoom.canceled -= instance.OnZoom;
            @MouseX.started -= instance.OnMouseX;
            @MouseX.performed -= instance.OnMouseX;
            @MouseX.canceled -= instance.OnMouseX;
            @MouseY.started -= instance.OnMouseY;
            @MouseY.performed -= instance.OnMouseY;
            @MouseY.canceled -= instance.OnMouseY;
            @Jumping.started -= instance.OnJumping;
            @Jumping.performed -= instance.OnJumping;
            @Jumping.canceled -= instance.OnJumping;
            @Running.started -= instance.OnRunning;
            @Running.performed -= instance.OnRunning;
            @Running.canceled -= instance.OnRunning;
            @Crouch.started -= instance.OnCrouch;
            @Crouch.performed -= instance.OnCrouch;
            @Crouch.canceled -= instance.OnCrouch;
            @Fire1.started -= instance.OnFire1;
            @Fire1.performed -= instance.OnFire1;
            @Fire1.canceled -= instance.OnFire1;
            @Interact.started -= instance.OnInteract;
            @Interact.performed -= instance.OnInteract;
            @Interact.canceled -= instance.OnInteract;
            @Inventory.started -= instance.OnInventory;
            @Inventory.performed -= instance.OnInventory;
            @Inventory.canceled -= instance.OnInventory;
            @Combat.started -= instance.OnCombat;
            @Combat.performed -= instance.OnCombat;
            @Combat.canceled -= instance.OnCombat;
            @FlameThrower.started -= instance.OnFlameThrower;
            @FlameThrower.performed -= instance.OnFlameThrower;
            @FlameThrower.canceled -= instance.OnFlameThrower;
            @MainMenu.started -= instance.OnMainMenu;
            @MainMenu.performed -= instance.OnMainMenu;
            @MainMenu.canceled -= instance.OnMainMenu;
            @TimeSwap.started -= instance.OnTimeSwap;
            @TimeSwap.performed -= instance.OnTimeSwap;
            @TimeSwap.canceled -= instance.OnTimeSwap;
        }

        /// <summary>
        /// Unregisters <param cref="instance" /> and unregisters all input action callbacks via <see cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />.
        /// </summary>
        /// <seealso cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />
        public void RemoveCallbacks(IPlayerActions instance)
        {
            if (m_Wrapper.m_PlayerActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        /// <summary>
        /// Replaces all existing callback instances and previously registered input action callbacks associated with them with callbacks provided via <param cref="instance" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c>, calling this method will only unregister all existing callbacks but not register any new callbacks.
        /// </remarks>
        /// <seealso cref="PlayerActions.AddCallbacks(IPlayerActions)" />
        /// <seealso cref="PlayerActions.RemoveCallbacks(IPlayerActions)" />
        /// <seealso cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />
        public void SetCallbacks(IPlayerActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    /// <summary>
    /// Provides a new <see cref="PlayerActions" /> instance referencing this action map.
    /// </summary>
    public PlayerActions @Player => new PlayerActions(this);
    private int m_mainSchemeIndex = -1;
    /// <summary>
    /// Provides access to the input control scheme.
    /// </summary>
    /// <seealso cref="UnityEngine.InputSystem.InputControlScheme" />
    public InputControlScheme mainScheme
    {
        get
        {
            if (m_mainSchemeIndex == -1) m_mainSchemeIndex = asset.FindControlSchemeIndex("main");
            return asset.controlSchemes[m_mainSchemeIndex];
        }
    }
    /// <summary>
    /// Interface to implement callback methods for all input action callbacks associated with input actions defined by "Player" which allows adding and removing callbacks.
    /// </summary>
    /// <seealso cref="PlayerActions.AddCallbacks(IPlayerActions)" />
    /// <seealso cref="PlayerActions.RemoveCallbacks(IPlayerActions)" />
    public interface IPlayerActions
    {
        /// <summary>
        /// Method invoked when associated input action "Movement" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnMovement(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Look" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnLook(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Zoom" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnZoom(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "MouseX" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnMouseX(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "MouseY" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnMouseY(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Jumping" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnJumping(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Running" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnRunning(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Crouch" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCrouch(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Fire1" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnFire1(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Interact" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnInteract(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Inventory" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnInventory(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Combat" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCombat(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "FlameThrower" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnFlameThrower(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "MainMenu" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnMainMenu(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "TimeSwap" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnTimeSwap(InputAction.CallbackContext context);
    }
}
```

```Player\Scripts\Input\inputDirector.cs
using UnityEngine;
using System;

public class InputDirector : MonoBehaviour, IPlayerBehavior
{
    /// <summary>
    /// The director of all input related events.
    /// 
    /// input events run just before "update()" does.
    /// 
    /// input is sent through events, and is passed to it's neccesary functions through the different managers.
    /// notice every "started" event is called before "updated".
    /// </summary>
    

    // master
    private ActionsMaster _playerInput;
    public static InputDirector Instance;

    // events
    public event Action OnInputReady;
    public event Action OnDisablePlayerMovement;
    public event Action OnEnablePlayerMovement;

    public event Action OnFireStarted;
    public event Action OnFirePressed;
    public event Action OnFireReleased;
    public event Action OnInteractPressed;
    public event Action OnCombatPressed;
    public event Action OnInventoryPressed;
    public event Action OnMainMenuPressed;
    public event Action OnPressedTimeChange;

    private Action<Vector2> _onPlayerMoved;
    public event Action<Vector2> OnPlayerMoved
    { // if someone subscribes while input is already pressed, send them the event as well.
        add
        {
            _onPlayerMoved += value;
            value?.Invoke(MovementValue); // Send latest movement immediately
        }
        remove
        {
            _onPlayerMoved -= value;
        }
    }
    public event Action OnPlayerMovedStarted;
    public event Action OnPlayerMovedFinished;

    public event Action<Vector2> OnCameraMoved;
    public event Action<float> OnCameraZoomChanged;

    public event Action OnPlayerRunStarted;
    public event Action OnPlayerRunStopped;
    public event Action OnPlayerRunDisabled;
    public event Action OnPlayerRunEnabled;

    public event Action OnPlayerJumpStarted;
    public event Action OnPlayerJumpStopped;

    public event Action OnPlayerCrouchStarted;
    public event Action OnPlayerCrouchStopped;

    public event Action OnPlayerFlameThrowerStart;
    public event Action OnPlayerFlameThrowerStop;

    // values
    public Vector2 MovementValue;

    // data
    private Player localPlayer;
    public bool ShouldDisable; // only disable when we're done with player, when this flag is on.
    
    public void AwakePlayer()
    {
        // Multiplayer Guard
        localPlayer = GetComponent<Player>();
        Debug.Log($"on enable!!! does {localPlayer.name} has authority? {localPlayer.HasAuthority}");
        if (!localPlayer.HasAuthority)
            return;
        
        // Singleton
        if (Instance == null)
            Instance = this;
        else
            Debug.LogWarning("input director already exists.");
    }

    public void OnEnablePlayer()
    {
        // Multiplayer Guard
        if (!localPlayer.HasAuthority)
            return;
        
        _playerInput = new ActionsMaster();
        
        // actions
        _playerInput.Player.Fire1.started += _ => OnFireStarted?.Invoke();
        _playerInput.Player.Fire1.performed += _ => OnFirePressed?.Invoke();
        _playerInput.Player.Fire1.canceled += _ => OnFireReleased?.Invoke();
        _playerInput.Player.Interact.performed += _ => OnInteractPressed?.Invoke();
        _playerInput.Player.Inventory.performed += _ => OnInventoryPressed?.Invoke();
        _playerInput.Player.MainMenu.performed += _ => OnMainMenuPressed?.Invoke();
        _playerInput.Player.TimeSwap.performed += _ => OnPressedTimeChange?.Invoke();

        // combat
        _playerInput.Player.Combat.performed += _ => OnCombatPressed?.Invoke();

        _playerInput.Player.FlameThrower.performed += _ => OnPlayerFlameThrowerStart?.Invoke();
        _playerInput.Player.FlameThrower.canceled += _ => OnPlayerFlameThrowerStop?.Invoke();

        // camera
        _playerInput.Player.Look.performed += ctx => OnCameraMoved?.Invoke(ctx.ReadValue<Vector2>());
        _playerInput.Player.Zoom.performed += ctx => OnCameraZoomChanged?.Invoke(ctx.ReadValue<float>());

        // movement
        _playerInput.Player.Movement.performed += x => { MovementValue = x.ReadValue<Vector2>(); _onPlayerMoved?.Invoke(MovementValue); };
        _playerInput.Player.Movement.started += x => { MovementValue = x.ReadValue<Vector2>(); OnPlayerMovedStarted?.Invoke();  _onPlayerMoved?.Invoke(MovementValue); };
        _playerInput.Player.Movement.canceled += x => { MovementValue = x.ReadValue<Vector2>(); OnPlayerMovedFinished?.Invoke(); };

        _playerInput.Player.Running.started += _ => OnPlayerRunStarted?.Invoke();
        _playerInput.Player.Running.canceled += _ => OnPlayerRunStopped?.Invoke();

        // jumping
        _playerInput.Player.Jumping.started += _ => OnPlayerJumpStarted?.Invoke();
        _playerInput.Player.Jumping.canceled += _ => OnPlayerJumpStopped?.Invoke();

        // crouching
        _playerInput.Player.Crouch.started += _ => OnPlayerCrouchStarted?.Invoke();
        _playerInput.Player.Crouch.canceled += _ => OnPlayerCrouchStopped?.Invoke();

        // plugins
        Cursor.visible = false;

        // Director
        _playerInput.Enable();
        OnInputReady?.Invoke();
        
        ShouldDisable = true;
    }

    public void OnDisablePlayer()
    {
        if (!ShouldDisable)
            return;

        Instance = null;

        // plugins

        // Unsubscribe from everything & Disable Director
        _playerInput.Player.Disable();
        _playerInput.Disable();
        _playerInput.Dispose();
    }

    public void EnableInput()
    {
        OnEnablePlayerMovement?.Invoke();
    }

    public void DisableInput()
    {
        OnDisablePlayerMovement?.Invoke();
    }

    public void EnableMouseUIInput()
    {
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;
    }

    public void DisableMouseUIInput()
    {
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    public void DisableJumpInput()
    {
        // Disables the Jumping action so no callbacks fire
        var jump = _playerInput.Player.Jumping;
        if (jump is { enabled: true })
            jump.Disable();
    }
    
    public void EnableJumpInput()
    {
        // Enables the Jumping action
        var jump = _playerInput.Player.Jumping;
        if (jump is { enabled: false })
            jump.Enable();
    }

    public void ToggleRun(bool canRun)
    {
        if (canRun)
            OnPlayerRunEnabled?.Invoke();
        else
            OnPlayerRunDisabled?.Invoke();
    }
}
```

```Player\Scripts\Movement\DefaultMovementState.cs
using System;
using UnityEngine;

public class DefaultMovementState : MovementState
{
    [Header("Currently Using: DefaultMovementState")]
    public const string CurrentStateName = "Default MovementState";


    public override MovementComponentType ComponentType => MovementComponentType.None;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        Controller = manager;
    }

    public override void EnterState()
    {
        Debug.Log("Entering Default (Empty) Movement state!");
    }

    public override void FixedUpdate()
    {
        
    }

    public override void UpdateState()
    {
        
    }
    
    public override void CleanState()
    {
        
    }
}
```

```Player\Scripts\Movement\MovementManager.cs
using System;
using UnityEngine;

public class MovementManager : MonoBehaviour, IPlayerBehavior
{
    /// <summary>
    /// manages the different movement states.
    /// 
    /// MovementState will have many inheriting states, each for a different movement mode.
    /// the default will be Normal,
    /// and depending on different story events, (player moved through ski gate, or touched a cave entrance)
    /// I will change the movement state.
    /// 
    /// only update will get called from here.
    /// 
    /// also note,
    /// some events will not be started by input, but by game events.
    /// For that, I will have public functions to change the state when the events happen.
    /// for example:
    /// on a random mountain, a ski sign, on triggerEnter:
    /// other.playerGameObject.getcomponent<movementManager>().onEnterSkiState();
    /// </summary>

    // State
    [SerializeReference]
    public MovementState CurrentState;
    public MovementState StartingState;

    // Assignables
    private Player _player;
    private InputDirector _director;
    private CameraManager _cameraManager;
    private CapsuleCollider _capsuleCollider;

    public void AwakePlayer()
    {
        _director = InputDirector.Instance;
        _player = GetComponent<Player>();
        _capsuleCollider = GetComponent<CapsuleCollider>();
        
        // if injected custom start state OR default to third person state
        CurrentState = StartingState ?? new DefaultMovementState();

        // Multiplayer Guard
        if (!_player.HasAuthority)
            return;
        
        CurrentState.LoadState(this, _director);
        CurrentState.EnterState();
    }

    public void ChangeState(MovementState newState)
    {
        if (!_player.HasAuthority)
            return;
        
        // verify we need to switch
        if (newState.GetType() == CurrentState.GetType())
            return;
        
        CurrentState.CleanState();
        CurrentState = newState;
        
        EnsureReqiredStateType(newState.ComponentType);
        CurrentState.LoadState(this, _director);
        
        CurrentState.EnterState();
    }

    private void EnsureReqiredStateType(MovementComponentType stateType)
    {
        switch (stateType)
        {
            case MovementComponentType.Rigidbody:
                EnsureOnly<Rigidbody>();
                _capsuleCollider.isTrigger = false;
                break;
            case MovementComponentType.CharacterController:
                EnsureOnly<CharacterController>();
                _capsuleCollider.isTrigger = true;
                break;
            case MovementComponentType.None:
                Remove<Rigidbody>();
                Remove<CharacterController>();
                _capsuleCollider.isTrigger = false;
                break;
        }
    }

    public void UpdatePlayer()
    {
        if (!_player.HasAuthority)
            return;

        CurrentState.UpdateState();
    }

    public void FixedUpdatePlayer()
    {
        if (!_player.HasAuthority)
            return;

        CurrentState.FixedUpdate();
    }

    public void OnDestroyPlayer()
    {
        CurrentState.CleanState();
    }
    
    public MovementState GetCurrentState()
    {
        return CurrentState;
    }

    public void EnableMovement()
    {
        CurrentState.CanMove = true;
    }

    public void DisableMovement()
    {
        CurrentState.CanMove = false;
    }
    
    // helpers
    private void EnsureOnly<T>() where T : Component
    {
        // Add required
        if (!TryGetComponent(out T addedComponent))
            addedComponent = gameObject.AddComponent<T>();

        // Remove the other type
        if (typeof(T) == typeof(Rigidbody))
            Remove<CharacterController>();
        else
            Remove<Rigidbody>();
        
        // config if cc
        if (addedComponent is CharacterController cc)
        {
            cc.center = new Vector3(0f, 0.7f, 0f);
            cc.height = 1.4f;
            cc.radius = 0.3f;
            cc.skinWidth = 0.01f;
        }
        
    }

    private void Remove<T>() where T : Component
    {
        if (TryGetComponent(out T existing))
            Destroy(existing);
    }
}
```

```Player\Scripts\Movement\MovementState.cs
using UnityEngine;

[System.Serializable]
public abstract class MovementState
{
    /// <summary>
    /// /// MovementState will have many inheriting states, each for a different movement mode.
    /// the default will be Idle,
    /// and depending on different input events, (player clicked run button or started moving with WASD)
    /// I will change the movement state.
    /// 
    /// EnterState() - loading the state data at the beginning of the game.
    /// </summary>
    protected InputDirector Director;
    protected MovementManager Controller;
    
    /// <summary>
    /// Shared between all states.
    /// so if this changes in one, it applies to all of them.
    /// </summary>
    protected PlayerStateData LocalData;

    public bool CanMove = true;
    public bool CanRun = true;
    
    /// <summary>
    /// a state uses either a Rigidbody or a CharacterController.
    /// this alerts the movement manager which to use.
    /// </summary>a
    public abstract MovementComponentType ComponentType { get; }

    // State machine
    public abstract void LoadState(MovementManager manager, InputDirector director);
    public abstract void EnterState();
    public abstract void UpdateState();
    public abstract void FixedUpdate();
    public abstract void CleanState();

    // Extra calls

    public virtual void OnCollisionStay(Collision collision)
    {
        
    }
}
```

```Player\Scripts\Movement\MovementStateType.cs
public enum MovementComponentType
{
    None,
    Rigidbody,
    CharacterController
}
```

```Player\Scripts\Movement\Helpers\IPlayerRotator.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IPlayerRotator
{
    // normal rotation
    public void RotatePlayer(Vector2 inputRotation);
    // rotate without update
    public void RotatePlayerAsync(Vector2 targetRotation);
}
```

```Player\Scripts\Movement\Helpers\PlayerRotator.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerRotator : IPlayerRotator
{
    GameObject _character;
    Transform _camTransform;

    Vector3 _currentTargetRotation = Vector3.zero;
    Vector3 _timeToReachTargetRotation = Vector3.zero;

    Vector3 _dumpedVelocity = Vector3.zero;
    Vector3 _dumpedVelocityPassedTime = Vector3.zero;

    float _directionAngle;

    // Constractor
    public PlayerRotator(Transform cam, Vector3 timeToReachTargetRotation)
    {
        _character = GameObject.FindGameObjectWithTag("Character");
        _camTransform = cam;
        this._timeToReachTargetRotation = timeToReachTargetRotation;
    }

    // normal rotation - gets called every update.
    public void RotatePlayer(Vector2 inputRotation)
    {
        // calculate the new rotation
        CalculateTargetRotation(inputRotation);
        // rotate the player
        SmoothlyRotatePlayer();
    }

    // rotate without update (asynchronously to Unity)
    public void RotatePlayerAsync(Vector2 targetRotation)
    {
        // set targetRotationValues

        // smoothly rotate the player
        SmoothlyRotatePlayer();
    }

    void CalculateTargetRotation(Vector2 inputRotation)
    {
        // calculate the rotation angle
        CalculateDirectionAngle(inputRotation);

        // add the rotation of the camera
        AddCameraRotation();

        // if the player has a new "target" for a new rotation (new target rotation),
        if (_directionAngle != _currentTargetRotation.y)
        {
            // ...than reset the dumping.
            _currentTargetRotation.y = _directionAngle;
            _dumpedVelocityPassedTime.y = 0f;
        }
    }
    void CalculateDirectionAngle(Vector2 inputRotation)
    {
        _directionAngle = Mathf.Atan2(inputRotation.x, inputRotation.y) * Mathf.Rad2Deg; // get the angle (in degrees)

        if (_directionAngle < 0f)
            _directionAngle += 360f;
    }
    void AddCameraRotation()
    {
        _directionAngle += _camTransform.eulerAngles.y;

        if (_directionAngle > 360f)
            _directionAngle -= 360f;
    }

    void SmoothlyRotatePlayer()
    {
        // current rotation
        float currentYAngle = _character.transform.rotation.eulerAngles.y;

        // no need to rotate
        if (currentYAngle == _currentTargetRotation.y)
            return;

        // get the smooth angle rotation
        float smoothYAngle = Mathf.SmoothDampAngle(currentYAngle, _currentTargetRotation.y, ref _dumpedVelocity.y, _timeToReachTargetRotation.y - _dumpedVelocityPassedTime.y);
        _dumpedVelocity.y += Time.deltaTime; // with dumping

        // final target rotation
        Quaternion targetRotation = Quaternion.Euler(0f, smoothYAngle, 0f);

        // rotate the player
        _character.transform.rotation = targetRotation;
    }

}
```

```Player\Scripts\Movement\Ski\skiState.cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SkiState : MovementState
{

    public override MovementComponentType ComponentType => MovementComponentType.Rigidbody;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        Controller = manager;
    }

    public override void EnterState()
    {
        Debug.Log("Starting to ski");
    }

    public override void FixedUpdate()
    {
        Debug.Log("Skiing!");
    }

    public override void UpdateState()
    {
        Debug.Log("Skiing!");
    }

    public override void CleanState()
    {

    }
}
```

```Player\Scripts\Movement\stateData\PlayerStateData.cs
using System;
using UnityEngine;

[Serializable]
[CreateAssetMenu(fileName = "PlayerStateData", menuName = "Zero/PlayerStateData", order = 1)]
public class PlayerStateData : ScriptableObject
{
    public float Acceleration = 2f;
    public float WalkingSpeed = 5f;
    public float RunningSpeed = 10f;
    
    public float JumpSpeed = 10f;
    public float JumpHeight = 4f;

    public Vector2 CameraSpeed;

    public Vector3 TimeToReachTargetRotation = new(0f, 0.14f, 0f);
    
    #region Changeables

    public float acceleration
    {
        get => Acceleration;
        set
        {
            if (Mathf.Approximately(Acceleration, value)) return;
            Acceleration = value;
            OnAccelerationChanged?.Invoke(value);
        }
    }

    public float walkingSpeed
    {
        get => WalkingSpeed;
        set
        {
            if (Mathf.Approximately(WalkingSpeed, value)) return;
            WalkingSpeed = value;
            OnWalkingSpeedChanged?.Invoke(value);
        }
    }

    public float runningSpeed
    {
        get => RunningSpeed;
        set
        {
            if (Mathf.Approximately(RunningSpeed, value)) return;
            RunningSpeed = value;
            OnRunningSpeedChanged?.Invoke(value);
        }
    }

    // Public events
    public event Action<float> OnAccelerationChanged;
    public event Action<float> OnWalkingSpeedChanged;
    public event Action<float> OnRunningSpeedChanged;

    #endregion
}

```

```Player\Scripts\Movement\stateData\StateData.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class StatsData : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
```

```Player\Scripts\Signs\CameraOrientation.cs
using UnityEngine;

public class CameraOrientation : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

public enum CameraOrientationType
{
    FirstPerson,
    ThirdPerson
}
```

```Player\Scripts\Signs\CharacterOrientation.cs
using System;
using UnityEngine;

public class CharacterOrientation : MonoBehaviour
{
    [SerializeField] private bool lockOrientationToZero = true;

    private void Update()
    {
        if (lockOrientationToZero)
            transform.localPosition = Vector3.zero;
    }
}
```

```Player\Scripts\Signs\PlayerGround.cs
using UnityEngine;

/// <summary>
/// use this to find groundcheck position
/// </summary>
public class PlayerGround : MonoBehaviour
{
    
}
```

```Player\Scripts\Signs\lookatSign.cs
using UnityEngine;

public class LookatSign : MonoBehaviour
{
    [SerializeField] private lookatType lookatType;

    public lookatType GetLookatType()
    {
        return lookatType;
    }
}

public enum lookatType
{
    FirstPerson,
    ThirdPersonFocusOnPlayer,
    ThirdPersonFocusOnAim,
}
```

```PlayerAddons\Cameras\FP_CameraState.cs
using Unity.Cinemachine;
using UnityEngine;

public class FP_CameraState : CameraState
{
    [Header("Assignables")]

    [SerializeField] private float _sensitivityX = 150f;
    [SerializeField] private float _sensitivityY = 150f;

    [SerializeField] private Transform _playerOrientation;
    [SerializeField] private CinemachineVirtualCameraBase _cameraOrientation;

    private readonly bool _allowArrows = true;

    [Header("Input")] private float _mouseX;
    private float _mouseY;

    private readonly float _multiplier = 0.01f;

    private float _xRotation;
    private float _yRotation;

    public float Tilt { get; private set; }

    // -------------------------------
    // State Machine
    // -------------------------------
    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
        Manager = manager;

        // subscribe to input events
        director.OnCameraMoved += _inputDirector_OnCameraMoved;
    }

    public override void EnterState()
    {
        _playerOrientation = Manager.transform;
        _cameraOrientation = Manager.CurrentCinemachineComponent.GetComponent<CinemachineCamera>();

        Transform characterOrientation = Manager.GetComponentInChildren<CharacterOrientation>().transform;
        _cameraOrientation.gameObject.AddComponent<CinemachineHardLockToTarget>();
        _cameraOrientation.Follow = Manager.GetComponentInChildren<CameraOrientation>().transform;
        if (_cameraOrientation is CinemachineCamera cinemachineCamera)
            cinemachineCamera.Lens.FieldOfView = 80f;
        
        characterOrientation.rotation = _playerOrientation.rotation;
        
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    private bool _updatedThisFrameThroughArrows = false;
    public override void UpdateState()
    {
        _updatedThisFrameThroughArrows = false;
        if (_allowArrows)
        {
            Vector2 camValue = Vector2.zero;

            if (Input.GetKey(KeyCode.UpArrow)
                || Input.GetKey(KeyCode.DownArrow)
                || Input.GetKey(KeyCode.RightArrow)
                || Input.GetKey(KeyCode.LeftArrow))
                _updatedThisFrameThroughArrows = true;

            if (Input.GetKey(KeyCode.UpArrow))
                camValue.y = 1;
            if (Input.GetKey(KeyCode.DownArrow))
                camValue.y = -1;
            if (Input.GetKey(KeyCode.RightArrow))
                camValue.x = 1;
            if (Input.GetKey(KeyCode.LeftArrow))
                camValue.x = -1;

            // normalize for consistant speed
            if (camValue.magnitude > 1)
                camValue.Normalize();

            _mouseX = camValue.x / 2f;
            _mouseY = camValue.y / 2f;
        }

        CameraUpdate();
    }
    

    public override void FixedUpdate()
    {
        
    }


    public override void ClearState()
    {
        if (!_cameraOrientation)
            return;
        
        var previousComponent = _cameraOrientation.GetComponent<CinemachineHardLockToTarget>();
        if (previousComponent)
            Object.Destroy(previousComponent);
    }

    public override void OnDestroy()
    {
        InputDirector.OnCameraMoved -= _inputDirector_OnCameraMoved;
    }

    // -------------------------------
    // State Functions
    // -------------------------------

    private void CameraUpdate()
    {
        if (!_updatedThisFrameThroughArrows)
        {
            _mouseX = Input.GetAxisRaw("Mouse X");
            _mouseY = Input.GetAxisRaw("Mouse Y");
        }

        if (!CanLookAround)
        {
            _mouseX = 0;
            _mouseY = 0;
        }

        _yRotation += _mouseX * _sensitivityX * _multiplier;
        _xRotation -= _mouseY * _sensitivityY * _multiplier;

        _xRotation = Mathf.Clamp(_xRotation, -90f, 90f);

        _cameraOrientation.transform.rotation = Quaternion.Euler(_xRotation, _yRotation, Tilt);
        _playerOrientation.transform.rotation = Quaternion.Euler(0, _yRotation, 0);
    }

    // -------------------------------
    // Input Events
    // -------------------------------
    private void _inputDirector_OnCameraMoved(Vector2 camValue)
    {
        _mouseX = camValue.x;
        _mouseY = camValue.y;
    }
}
```

```PlayerAddons\Cameras\TP_CameraState.cs
using UnityEngine;
using Unity.Cinemachine;

public class TP_CameraState : CameraState
{
    [Header("Sensitivity")]
    private float _sensitivityX = 150f;
    private float _sensitivityY = 150f;

    [Header("Vertical Clamp")]
    [SerializeField] private float _minYClamp = 48.3f;
    [SerializeField] private float _maxYClamp = 67.5f;
    
    [Header("Camera Configuration Constants")]
    private float _baseArmLength = 0.05f;
    private float _baseCameraDistance = 3.0f;
    private float _influence = 0.8f;

    [Header("Assignables")]
    private Transform _cameraOrientation;     // camera goes around
    private Transform _lookatTarget;
    private CinemachineCamera _virtualCam;
    private CinemachineThirdPersonFollow _thirdPersonFollow;

    private float _mouseX;
    private float _mouseY;

    private readonly float _multiplier = 0.01f;

    private float _xRotation;
    private float _yRotation;

    private readonly bool _allowArrows = true;
    private bool _updatedThisFrameThroughArrows = false;

    // -------------------------------
    // State Machine
    // -------------------------------
    public override void LoadState(CameraManager manager, InputDirector director)
    {
        Manager = manager;
        InputDirector = director;
        
        _cameraOrientation = Manager.GetComponentInChildren<CameraOrientation>().transform;
        _virtualCam = Manager.CurrentCinemachineComponent.GetComponent<CinemachineCamera>();
        _lookatTarget = GameObject.FindGameObjectWithTag("lookat").transform;

        director.OnCameraMoved += _inputDirector_OnCameraMoved;
    }

    public override void EnterState()
    {
        // configure virtual camera
        _thirdPersonFollow = _virtualCam.gameObject.AddComponent<CinemachineThirdPersonFollow>();
        _virtualCam.Follow = _cameraOrientation;
        
        // configure camera third person component
        _thirdPersonFollow.CameraDistance = _baseCameraDistance;
        _thirdPersonFollow.VerticalArmLength = _baseArmLength;
        _thirdPersonFollow.Damping = new Vector3(0f, 0f, 0.2f);
        _thirdPersonFollow.ShoulderOffset = new Vector3(-0.3f, -0.18f, 0f);
        _thirdPersonFollow.AvoidObstacles = new CinemachineThirdPersonFollow.ObstacleSettings()
        {
            Enabled = true,
            CollisionFilter = 1 << LayerMask.NameToLayer("Ground"),
            IgnoreTag = "",
            CameraRadius = 0.001f,
            DampingFromCollision = 0f,
            DampingIntoCollision = 0.5f
        };
        
        // configure cursor
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    public override void UpdateState()
    {
        _influence = 0.8f;
        
        _updatedThisFrameThroughArrows = false;

        // Optional debug with arrow keys
        if (_allowArrows)
            CollectArrowsInputDebug();

        ApplyGoldenRatioCameraDistance();
        CameraUpdate();
    }

    public override void FixedUpdate()
    {
        // nothing for now
    }

    public override void ClearState()
    {
        if (!_virtualCam)
            return;
        
        var previousComponent = _virtualCam.GetComponent<CinemachineThirdPersonFollow>();
        if (previousComponent)
            Object.Destroy(previousComponent);
    }

    public override void OnDestroy()
    {
        if (InputDirector != null)
            InputDirector.OnCameraMoved -= _inputDirector_OnCameraMoved;
    }

    // -------------------------------
    // State Functions
    // -------------------------------
    private void CameraUpdate()
    {
        if (!_updatedThisFrameThroughArrows)
        {
            _mouseX = Input.GetAxisRaw("Mouse X");
            _mouseY = Input.GetAxisRaw("Mouse Y");
        }

        if (!CanLookAround)
        {
            _mouseX = 0;
            _mouseY = 0;
        }

        // Horizontal (yaw)
        _yRotation += _mouseX * _sensitivityX * _multiplier;
        
        // Vertical (pitch)  clamped to max and min camera height
        _xRotation -= _mouseY * _sensitivityY * _multiplier;
        _xRotation = Mathf.Clamp(_xRotation, -_minYClamp, _maxYClamp);

        // Rotation of the camera orientation
        _cameraOrientation.rotation = Quaternion.Euler(_xRotation, _yRotation, 0f);
    }

    private void ApplyGoldenRatioCameraDistance()
    {
        // get camera pitch in degrees (-90 looking down, +90 looking up)
        float pitch = _virtualCam.State.RawOrientation.eulerAngles.x;
        if (pitch > 180f) pitch -= 360f;  // convert 0-360  -180 to 180

        // normalize pitch to -1..1
        float pitchNorm = - Mathf.Clamp(pitch / 70f, -1f, 1f);

        // golden ratio curve
        float golden = 1f + pitchNorm * 0.618f * _influence;

        // apply to arm length
        _thirdPersonFollow.VerticalArmLength = _baseArmLength * golden;
        
        // optionally: apply subtle change to distance
        _thirdPersonFollow.CameraDistance = _baseCameraDistance * (1f + pitchNorm * 0.2f * _influence);
    }

    private void CollectArrowsInputDebug()
    {
        Vector2 camValue = Vector2.zero;

        if (Input.GetKey(KeyCode.UpArrow)
            || Input.GetKey(KeyCode.DownArrow)
            || Input.GetKey(KeyCode.RightArrow)
            || Input.GetKey(KeyCode.LeftArrow))
            _updatedThisFrameThroughArrows = true;

        if (Input.GetKey(KeyCode.UpArrow))
            camValue.y = 1;
        if (Input.GetKey(KeyCode.DownArrow))
            camValue.y = -1;
        if (Input.GetKey(KeyCode.RightArrow))
            camValue.x = 1;
        if (Input.GetKey(KeyCode.LeftArrow))
            camValue.x = -1;

        if (camValue.magnitude > 1)
            camValue.Normalize();

        _mouseX = camValue.x / 2f;
        _mouseY = camValue.y / 2f;
    }

    // -------------------------------
    // Input Events
    // -------------------------------
    private void _inputDirector_OnCameraMoved(Vector2 camValue)
    {
        _mouseX = camValue.x;
        _mouseY = camValue.y;
    }
}
```

```PlayerAddons\CharacterController\fps\cc_fpState.cs
using System;
using UnityEngine;

/// <summary>
/// First Person State - Character Controller
/// </summary>
[Serializable]
public class cc_fpState : MovementState
{
    [Header("Definition")]
    public override MovementComponentType ComponentType => MovementComponentType.CharacterController;
    [SerializeField] public string StateName = "cc FirstPerson";
    
    [Header("Assignables")]
    [SerializeField] private CharacterController cc;
    [SerializeField] private Transform playerTransform;
    [SerializeField] private Transform orientation; // animator root
    [SerializeField] private Player player;

    [Header("Movement")]
    [SerializeField] private float walkSpeed = 5f;
    [SerializeField] private float sprintSpeed = 8f;
    [SerializeField] private float acceleration = 12f;
    
    [Header("Jump & Gravity")]
    [SerializeField] private float jumpHeight = 1.6f;
    [SerializeField] private float gravity = -25f;
    [SerializeField] private float minGravity = -30f;
    [SerializeField] private float maxGravity = 20f;
    [SerializeField] private float groundedOffset = -0.15f;
    [SerializeField] private float groundedRadius = 0.25f;
    
    private bool _holdingJump;
    private bool IsGrounded => cc.isGrounded;
    private bool _holdingSprint;
    
    private Vector2 _moveInput = new Vector2(0f, 0f);
    private Vector3 _movementVelocity;
    private float _verticalVelocity;
    
    // -------------------------------
    // State Machine
    // -------------------------------
    public override void LoadState(MovementManager manager, InputDirector director)
    {
        Controller = manager;
        Director = director ?? InputDirector.Instance;
        playerTransform = manager.transform;
        
        cc = manager.GetComponent<CharacterController>();
        player = manager.GetComponent<Player>();
        
        var animator = manager.GetComponentInChildren<Animator>();
        orientation = animator ? animator.transform : manager.transform;
        
        if (!player.HasAuthority)
            return;

        LocalData = player.GetData("Walking");
        acceleration = LocalData.acceleration;
        walkSpeed = LocalData.walkingSpeed;
        sprintSpeed = LocalData.runningSpeed;
        
        // Subscribe to input events
        Director.OnPlayerMoved += OnPlayerMoved;
        Director.OnPlayerMovedFinished += OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted += OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped += OnPlayerJumpStopped;
        Director.OnPlayerRunStarted += OnPlayerRunStarted;
        Director.OnPlayerRunStopped += OnPlayerRunStopped;
        Director.OnEnablePlayerMovement += OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement += OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled += OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled += OnPlayerRunDisabled;
        
        // Subscribe to player data changes
        LocalData.OnAccelerationChanged += newAcceleration => acceleration = newAcceleration;
        LocalData.OnWalkingSpeedChanged += newWalkingSpeed => walkSpeed = newWalkingSpeed;
        LocalData.OnRunningSpeedChanged += newRunningSpeed => sprintSpeed = newRunningSpeed;
    }

    public override void EnterState()
    {
        _verticalVelocity = -2f;
    }

    public override void UpdateState()
    {
        HandleHorizontalMovement();
        HandleJumpAndGravity();
        MovePlayer();
    }

    public override void FixedUpdate()
    {
        
    }

    public override void CleanState()
    {
        // Reset velocity
        _movementVelocity = Vector3.zero;
        _verticalVelocity = 0f;

        // Unsubscribe
        Director.OnPlayerMoved -= OnPlayerMoved;
        Director.OnPlayerMovedFinished -= OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted -= OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped -= OnPlayerJumpStopped;
        Director.OnPlayerRunStarted -= OnPlayerRunStarted;
        Director.OnPlayerRunStopped -= OnPlayerRunStopped;
        Director.OnEnablePlayerMovement -= OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement -= OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled -= OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled -= OnPlayerRunDisabled;
    }

    // -------------------------------
    // Core Movement
    // -------------------------------
    private void MovePlayer()
    {
        if (!CanMove)
            return;
        
        cc.Move(_movementVelocity * Time.deltaTime);
    }

    private void HandleHorizontalMovement()
    {
        if (!CanMove)
        {
            _movementVelocity.x = 0f;
            _movementVelocity.z = 0f;
            return;
        }

        // FP: move relative to orientation (which is usually synced with camera yaw)
        Vector3 forward = orientation.forward;
        Vector3 right = orientation.right;
        forward.y = 0f;
        right.y = 0f;
        forward.Normalize();
        right.Normalize();

        Vector3 inputDir = new Vector3(_moveInput.x, 0f, _moveInput.y);
        Vector3 targetDirection = (forward * inputDir.z + right * inputDir.x).normalized;

        float targetSpeed = 0f;
        if (_moveInput.magnitude > 0.01f)
        {
            targetSpeed = _holdingSprint && CanRun ? sprintSpeed : walkSpeed;
        }

        Vector3 targetHorizontalVelocity = targetDirection * targetSpeed;
        Vector3 currentHorizontal = new Vector3(_movementVelocity.x, 0f, _movementVelocity.z);

        currentHorizontal = Vector3.Lerp(currentHorizontal, targetHorizontalVelocity,
            acceleration * Time.deltaTime);

        _movementVelocity.x = currentHorizontal.x;
        _movementVelocity.z = currentHorizontal.z;
    }

    private void HandleJumpAndGravity()
    {
        // constant but limited force if on ground
        if (IsGrounded && _verticalVelocity < 0f)
            _verticalVelocity = -2f;
        
        // jump
        if (IsGrounded && _holdingJump && CanMove)
            _verticalVelocity = Mathf.Sqrt(jumpHeight * -2f * gravity);
        
        // new velocity, clamp if reached max
        _verticalVelocity += gravity * Time.deltaTime;
        _verticalVelocity = Mathf.Clamp(_verticalVelocity, minGravity, maxGravity);
        
        // apply new velocity
        _movementVelocity.y = _verticalVelocity;
    }

    // for knockback
    public void AddVerticalVelocity(float knockbackUpForce)
    {
        _verticalVelocity += knockbackUpForce;
    }
    
    // -------------------------------
    // Input Events
    // -------------------------------
    private void OnPlayerMoved(Vector2 movementValue)
    {
        _moveInput = movementValue;
    }

    private void OnPlayerMovedFinished()
    {
        _moveInput = Vector2.zero;
    }

    private void OnPlayerJumpStarted() => _holdingJump = true;
    private void OnPlayerJumpStopped() => _holdingJump = false;

    private void OnPlayerRunStarted() => _holdingSprint = true;
    private void OnPlayerRunStopped() => _holdingSprint = false;

    private void OnEnablePlayerMovement() => CanMove = true;
    private void OnDisablePlayerMovement() => CanMove = false;

    private void OnPlayerRunEnabled() => CanRun = true;
    private void OnPlayerRunDisabled() => CanRun = false;
}
```

```PlayerAddons\CharacterController\tps\cc_tpState.cs
using System;
using SHG.AnimatorCoder;
using UnityEngine;

[Serializable]
public class cc_tpState : MovementState
{
    [Header("Definition")]
    public override MovementComponentType ComponentType => MovementComponentType.CharacterController;
    [SerializeField] public const string StateName = "cc ThirdPerson";
    
    [Header("Assignables")]
    [SerializeField] private CharacterController cc;
    [SerializeField] private Transform cameraTransform;
    [SerializeField] private Transform characterOrientation;
    private Player _player;
    private AnimationsManager _animator;

    [Header("Movement")]
    [SerializeField] private float walkSpeed = 5f;
    [SerializeField] private float sprintSpeed = 8f;
    [SerializeField] private float acceleration = 12f;
    [SerializeField] private float rotationSpeed = 12f;

    [Header("Jump & Gravity")]
    [SerializeField] private float jumpHeight = 1.4f;
    [SerializeField] private float gravity = -25f;
    [SerializeField] private float minGravity = -30f;
    [SerializeField] private float maxGravity = 20f;
    [SerializeField] private float groundedOffset = -0.15f;
    [SerializeField] private float groundedRadius = 0.25f;
    [SerializeField] private LayerMask groundLayers;

    private Vector2 _moveInput;
    private bool _holdingJump;
    private bool _holdingSprint;
    private bool IsGrounded => cc.isGrounded;
    private bool _lockSwitch;

    private float _verticalVelocity;
    private Vector3 _movementVelocity;

    // -------------------------------
    // State Machine
    // -------------------------------
    public override void LoadState(MovementManager manager, InputDirector director)
    {
        _player = manager.GetComponent<Player>();
        _animator = manager.GetComponent<AnimationsManager>();
        cc = manager.GetComponent<CharacterController>();
        
        if (!_player.HasAuthority)
            return;
        
        Controller = manager;
        Director = director ?? InputDirector.Instance;

        
        if (!cc)
            Debug.LogError("Character Controller not found for this person state, should be added via MovementManager");

        characterOrientation = manager.GetComponentInChildren<CharacterOrientation>().transform;
        cameraTransform = _player.GetCamera().transform;

        LocalData = _player.GetData("Walking");
        acceleration = LocalData.acceleration;
        walkSpeed = LocalData.walkingSpeed;
        sprintSpeed = LocalData.runningSpeed;
        
        // Input events
        Director.OnPlayerMoved += OnPlayerMoved;
        Director.OnPlayerMovedFinished += OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted += OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped += OnPlayerJumpStopped;
        Director.OnPlayerRunStarted += OnPlayerRunStarted;
        Director.OnPlayerRunStopped += OnPlayerRunStopped;
        Director.OnEnablePlayerMovement += OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement += OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled += OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled += OnPlayerRunDisabled;
        
        // Subscribe to player data changes
        LocalData.OnAccelerationChanged += newAcceleration => acceleration = newAcceleration;
        LocalData.OnWalkingSpeedChanged += newWalkingSpeed => walkSpeed = newWalkingSpeed;
        LocalData.OnRunningSpeedChanged += newRunningSpeed => sprintSpeed = newRunningSpeed;
        
        // Setup Animations
        new AnimationsManager.Builder("tps_animator")
            .AddAnimation("Idle", connections: new [] {
                Connection.To("Walking", customCrossfade: 0.06f).When("Walking", true),
            })
            .AddAnimation("Walking", connections: new [] {
                Connection.To("Idle", customCrossfade: 0.2f).When("Walking", false),
                Connection.To("Running", customCrossfade: 0.16f).When("Running", true)
            })
            .AddAnimation("Running", connections: new []
            {
                Connection.To("Walking", customCrossfade: 0.2f).When("Running", false),
                Connection.To("Idle", customCrossfade: 0.2f).When("Walking", false)
            })
            .AddAnimation("Jump", entryCrossfade: 0f, autoNextAnimation: "Fall", lockLayer: true, loops: false)
            .AddAnimation("Fall", connections:
                Connection.To("Idle", customCrossfade: 0.03f).When("Falling", false))
            .AddParameter("Walking")
            .AddParameter("Falling")
            .AddParameter("Running")
            .SetDefaultAnimation(DefaultAnimation)
            .Build(_animator);
    }

    public override void EnterState()
    {
        // dear future self, looking for optimizations, no need to reset values here because:
        // A. they are already defaulted to 0, we make a new tpstate each time (we don't swap states often so it's fine)
        // B. this causes a bug where the player would stop moving because this overrides the inputvalue.
        // EnterState happens after OnPlayerMoved.
        // _moveInput = Vector2.zero;
        // _currentVelocity = Vector3.zero;
        
        _verticalVelocity = -2f;
    }

    public override void UpdateState()
    {
        HandleMovementInput();
        HandleJumpAndGravity();
        MovePlayer();
    }

    public override void FixedUpdate()
    {
        
    }

    public override void CleanState()
    {
        // _currentVelocity = Vector3.zero;
        // _verticalVelocity = 0f;

        Director.OnPlayerMoved -= OnPlayerMoved;
        Director.OnPlayerMovedFinished -= OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted -= OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped -= OnPlayerJumpStopped;
        Director.OnPlayerRunStarted -= OnPlayerRunStarted;
        Director.OnPlayerRunStopped -= OnPlayerRunStopped;
        Director.OnEnablePlayerMovement -= OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement -= OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled -= OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled -= OnPlayerRunDisabled;
    }

    // -------------------------------
    // Core Movement
    // -------------------------------
    private void MovePlayer()
    {
        if (!CanMove)
            return;
        
        cc.Move(_movementVelocity * Time.deltaTime);
    }

    private void HandleMovementInput()
    {
        // don't move if input disabled
        if (!CanMove)
        {
            _movementVelocity.x = 0f;
            _movementVelocity.z = 0f;
            return;
        }

        // get inputs from player
        Vector3 inputDir = new Vector3(_moveInput.x, 0f, _moveInput.y);
        Vector3 moveDir = Vector3.zero;

        // set move direction towards where camera looks
        Vector3 camForward = cameraTransform.forward;
        Vector3 camRight = cameraTransform.right;
        moveDir = (camForward * inputDir.z) + (camRight * inputDir.x);
        moveDir.Normalize();

        // character orientation -> rotate just the model towards camera
        Quaternion targetRotation;

        if (_lockSwitch)
        {
            targetRotation = Quaternion.LookRotation(new Vector3(camForward.x, 0f, camForward.z));
            RotateCharacterImmediatly(targetRotation);
        }
        else if (_moveInput.magnitude > 0.01f)
        {
            // rotate character model towards movement direction
            targetRotation = Quaternion.LookRotation(new Vector3(moveDir.x, 0f, moveDir.z));
            RotateCharacterTowards(targetRotation);
        }
        
        // move towards new velocity
        float targetSpeed = _holdingSprint && CanRun ? sprintSpeed : walkSpeed;
        Vector3 targetHorizontalVelocity = moveDir * targetSpeed;
        Vector3 currentHorizontal = new Vector3(_movementVelocity.x, 0f, _movementVelocity.z);
        
        currentHorizontal = Vector3.Lerp(currentHorizontal, targetHorizontalVelocity,
            acceleration * Time.deltaTime);

        _movementVelocity.x = currentHorizontal.x;
        _movementVelocity.z = currentHorizontal.z;
    }

    private void RotateCharacterTowards(Quaternion targetRot)
    {
        characterOrientation.rotation = Quaternion.Slerp(
            characterOrientation.rotation,
            targetRot,
            rotationSpeed * Time.deltaTime);
    }

    private void RotateCharacterImmediatly(Quaternion targetRot)
    {
        characterOrientation.rotation = targetRot;
    }

    private void HandleJumpAndGravity()
    {
        // constant but limited force if on ground
        if (IsGrounded && _verticalVelocity < 0f)
        {
            _verticalVelocity = -2f;
            
            _animator.SetBool("Falling", false);
        }
        else
            _animator.SetBool("Falling", true);
        
        // jump
        if (IsGrounded && _holdingJump && CanMove)
        {
            _verticalVelocity = Mathf.Sqrt(jumpHeight * -2f * gravity);
            _animator.Play("Jump");
        }

        // new velocity, clamp if reached max
        _verticalVelocity += gravity * Time.deltaTime;
        _verticalVelocity = Mathf.Clamp(_verticalVelocity, minGravity, maxGravity);
        
        // apply new velocity
        _movementVelocity.y = _verticalVelocity;
    }
    
    // for knockback
    public void AddVerticalVelocity(float knockbackUpForce)
    {
        _verticalVelocity += knockbackUpForce;
    }

    /// <summary>
    /// Default Animation Logic
    /// </summary>
    private void DefaultAnimation()
    {
        if (_animator.GetBool("Falling"))
            _animator.Play("Fall");
        else
            _animator.Play("Idle");
    }
    
    // -------------------------------
    // Input Events
    // -------------------------------
    private void OnPlayerMoved(Vector2 movementValue)
    {
        _moveInput = movementValue;
        _animator.SetBool("Walking", true);
    }

    private void OnPlayerMovedFinished()
    {
        _moveInput = Vector2.zero;
        _animator.SetBool("Walking", false);
    }

    private void OnPlayerJumpStarted() => _holdingJump = true;
    private void OnPlayerJumpStopped() => _holdingJump = false;

    private void OnPlayerRunStarted()
    {
        _holdingSprint = true;
        _lockSwitch = !_lockSwitch;
        
        _animator.SetBool("Running", true);
    }

    private void OnPlayerRunStopped()
    {
        _holdingSprint = false;
        
        _animator.SetBool("Running", false);
    }

    private void OnEnablePlayerMovement() => CanMove = true;
    private void OnDisablePlayerMovement() => CanMove = false;

    private void OnPlayerRunEnabled() => CanRun = true;
    private void OnPlayerRunDisabled() => CanRun = false;
}
```

```PlayerAddons\EXTENSIONS\cc\cc_ExtensionKnockback.cs
using UnityEngine;

public class cc_ExtensionKnockback : MonoBehaviour, Knockbackable, IPlayerBehavior
{
    [Header("Forces")]
    [SerializeField] private float knockbackBackwardsForce = 12f;
    [SerializeField] private float knockbackUpForce = 6f;
    [SerializeField] private float decay = 18f;

    private CharacterController cc;
    private Vector3 externalVelocity;
    private MovementManager _movementManager;
    
    public void AwakePlayer()
    {
        cc = GetComponent<CharacterController>();
        _movementManager = GetComponent<MovementManager>();
    }

    public void UpdatePlayer()
    {
        if (externalVelocity.sqrMagnitude < 0.001f)
            return;

        if (!cc)
            cc = GetComponent<CharacterController>();
        
        // Apply injected motion (same way cc_fpState does)
        cc.Move(externalVelocity * Time.deltaTime);

        // Smooth decay
        externalVelocity = Vector3.Lerp(
            externalVelocity,
            Vector3.zero,
            decay * Time.deltaTime
        );
    }

    public void ApplyKnockback(Vector3 attackingPosition, float horizontalForce=0f, float verticalForce=0f)
    {
        // Direction away from attacker
        Vector3 dir = (transform.position - attackingPosition);
        dir.y = 0f;
        dir.Normalize();

        // Bias backward more than upward
        Vector3 knockback =
            dir * horizontalForce;

        externalVelocity = knockback;
        
        // Vertical impulse goes to the movement authority
        var currentState = _movementManager.GetCurrentState();
        if (currentState is cc_fpState fpsPlayer)
        {
            fpsPlayer.AddVerticalVelocity(verticalForce);
        }
        else if (currentState is cc_tpState tpsPlayer)
        {
            tpsPlayer.AddVerticalVelocity(verticalForce);
        }

        Debug.Log("Took Knockback!");
    }
}
```

```PlayerAddons\EXTENSIONS\other\ExtensionInteractier.cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class ExtensionInteractier : MonoBehaviour, IPlayerBehavior
{
    protected InputDirector _inputDirector;
    private bool _unsubscribedFromDefaultInteract = false;
    private int _interactionMask;
    public List<string> InteractableTypes;

    private Transform _camTransform;
    public Transform InteractorSource;
    public float InteractRange;
    private Interactable _lastInteractedObj;
    
    public bool DisplayDebugInteract;

    // Start is called before the first frame update
    public void StartPlayer()
    {
        _inputDirector = GetComponent<InputDirector>();
        _inputDirector.OnInteractPressed += OnPressedInteract;
        
        // get ignore layers
        int playerLayer = LayerMask.NameToLayer("Player");
        int selfLayer = LayerMask.NameToLayer("Self");
        
        // default: hit anything
        _interactionMask = Physics.DefaultRaycastLayers;
        
        // exclude player and self
        if (playerLayer != -1)
            _interactionMask &= ~(1 << playerLayer);
        if (selfLayer != -1)
            _interactionMask &= ~(1 << selfLayer);
        
        // get camera for direction
        if (TryGetComponent(out Player player))
            _camTransform = player.GetCamera().transform;
        else if (Camera.main != null)
            _camTransform = Camera.main.transform;
        else
            _camTransform = InteractorSource.transform;
    }

    protected void OnPressedInteract()
    {
        Debug.Log("Player Pressed Interact");
        Ray ray = new(InteractorSource.position, _camTransform.forward);
        if (Physics.Raycast(ray, out RaycastHit hitInfo, InteractRange, _interactionMask))
        {
            if (TryGetInteractable(hitInfo, out var interactObj))
                interactObj.Interact();
            else if (hitInfo.collider != null && hitInfo.collider.transform.parent != null)
            {
                Debug.Log(hitInfo.collider.gameObject.name  + " bellow: " + hitInfo.collider.transform.parent.name + " is not interactable");
            }
        }
    }

    // Update is called once per frame
    public void UpdatePlayer()
    {
        Ray r = new(InteractorSource.position, _camTransform.forward);
        if (DisplayDebugInteract) 
            Debug.DrawRay(r.origin, r.direction * InteractRange, Color.mediumPurple);
        if (Physics.Raycast(r, out RaycastHit hitInfo, InteractRange, _interactionMask))
        {
            if (TryGetInteractable(hitInfo, out var interactObj))
            {
                interactObj.MarkAsInteractable();
                _lastInteractedObj = interactObj;
            }
            else if (_lastInteractedObj != null)
            {
                _lastInteractedObj.StopMarking();
                _lastInteractedObj = null;
            }
        }
    }

    public void OnDestroyPlayer()
    {
        UnsubscribeFromDefaultInteract();
    }

    protected void UnsubscribeFromDefaultInteract()
    {
        if (_unsubscribedFromDefaultInteract)
            return;
        
        _unsubscribedFromDefaultInteract = true;
        _inputDirector.OnInteractPressed -= OnPressedInteract;
    }
    
    private bool TryGetInteractable(RaycastHit hit, out Interactable interactable)
    {
        if (hit.collider.gameObject.TryGetComponent(out Interactable interactObj))
        {
            if (InteractableTypes.Contains(interactObj.InteractableType))
            {
                interactable = interactObj;
                return true;
            }
            if (string.IsNullOrEmpty(interactObj.InteractableType))
                Debug.LogError($"Forgot To Assign InteractableType to {interactObj.GetType()}");
        }

        interactable = null;
        return false;
    }
}
```

```PlayerAddons\EXTENSIONS\other\ExtensionInventory.cs
using UnityEngine;

public class ExtensionInventory : MonoBehaviour, IPlayerBehavior
{
    private InputDirector _inputDirector;
    public GameObject InventoryCanvas;
    private CameraManager _cameraManager;
    private MovementManager _movementManager;

    // Start is called before the first frame update
    public void StartPlayer()
    {
        _movementManager = gameObject.GetComponent<MovementManager>();
        _cameraManager = gameObject.GetComponent<CameraManager>();
        _inputDirector = gameObject.GetComponent<InputDirector>();

        _inputDirector.OnInventoryPressed += OnInventoryToggle;

        // initiate the canvas
        InventoryCanvas.SetActive(true);
        InventoryCanvas.SetActive(false);
    }

    void OnInventoryToggle()
    {
        bool inventoryActive = InventoryCanvas.activeSelf;
        
        // Disable Inventory
        if (inventoryActive)
        {
            _movementManager.EnableMovement();
            _cameraManager.EnableCamera();
            InventoryCanvas.SetActive(false);
            Cursor.visible = false;
            Cursor.lockState = CursorLockMode.Locked;
        }
        else // Enable Inventory
        {
            _movementManager.DisableMovement();
            _cameraManager.DisableCamera();
            InventoryCanvas.SetActive(true);
            Cursor.visible = true;
            Cursor.lockState = CursorLockMode.None;
        }
    }

    public void OnDestroyPlayer()
    {
        _inputDirector.OnInventoryPressed -= OnInventoryToggle;
    }
}
```

```PlayerAddons\EXTENSIONS\other\ExtensionKillPlayer.cs
using UnityEngine;

public class ExtensionKillPlayer : MonoBehaviour, IPlayerBehavior
{
    public float SnowToRemove = 30f;
    public Vector3 LastCheckpoint = Vector3.zero;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    public void StartPlayer()
    {
        StatsSingleton.Instance.GetStat(StatType.Health).OnStatChanged += ExtensionKillPlayer_OnStatChanged;
    }

    public void OnDestroyPlayer()
    {
        StatsSingleton.Instance.GetStat(StatType.Health).OnStatChanged -= ExtensionKillPlayer_OnStatChanged;
    }

    private void ExtensionKillPlayer_OnStatChanged(float newHealthValue)
    {
        if (newHealthValue <= 0f)
        {
            // reset it's stats
            StatsSingleton.Instance.SetStat(StatType.Health, 100f);

            float currentSnow = StatsSingleton.Instance.GetStat(StatType.Snow).Value;
            
            if (currentSnow - SnowToRemove <= 0f)
                StatsSingleton.Instance.SetStat(StatType.Snow, 0f);
            else if (currentSnow - SnowToRemove > 0f)
                StatsSingleton.Instance.DecreamentStat(StatType.Snow, SnowToRemove);

            // and respawn to last checkpoint
            GameObject player = GameObject.FindGameObjectWithTag("Player");
            player.transform.position = LastCheckpoint;
        }
    }

    public void UnlockCheckpoint(Transform checkpoint)
    {
        LastCheckpoint = checkpoint.position;
    }
}
```

```PlayerAddons\EXTENSIONS\other\ExtensionScrollCamera.cs
using UnityEngine;
using Unity.Cinemachine;

public class ExtensionScrollCamera : MonoBehaviour
{
    [Header("Managers")] public MovementManager movementManager;
    public CameraManager cameraManager;

    [Header("Cameras")] private CinemachineCamera _activeCam;
    private CinemachineThirdPersonFollow _tpFollow;

    [Header("Zoom Settings")] public float minDistance = 0.5f; // closest in TP
    public float maxDistance = 6f; // farthest in TP
    public float scrollSpeed = 2f;
    public float firstPersonSwitchDistance = 0.6f; // when reaching this, switch to FP

    private bool _isFirstPerson = false;

    private void Awake()
    {
        if (movementManager == null)
            movementManager = GetComponent<MovementManager>();

        if (cameraManager == null)
            cameraManager = GetComponent<CameraManager>();

        if (_activeCam != null)
            _activeCam = movementManager.GetComponentInChildren<CinemachineCamera>();
    }

    private void Update()
    {
        //     float scroll = Input.mouseScrollDelta.y;
        //     if (Mathf.Abs(scroll) < 0.01f)
        //         return;
        //
        //     if (!_isFirstPerson)
        //     {
        //         float newDist = _tpFollow.CameraDistance - scroll * scrollSpeed;
        //         newDist = Mathf.Clamp(newDist, minDistance, maxDistance);
        //         _tpFollow.CameraDistance = newDist;
        //
        //         // fully zoomed in -> switch to FP
        //         if (newDist <= firstPersonSwitchDistance)
        //         {
        //             SwitchToFirstPerson();
        //         }
        //     }
        //     else
        //     {
        //         // In FP, any scroll OUT switches back to TP
        //         if (scroll < 0f)
        //         {
        //             SwitchToThirdPerson();
        //         }
        //     }
        // }

        // private void SwitchToFirstPerson()
        // {
        //     if (_isFirstPerson) return;
        //     _isFirstPerson = true;
        //
        //     if (firstPersonCam != null)
        //         firstPersonCam.Priority = 20;
        //     if (thirdPersonCam != null)
        //         thirdPersonCam.Priority = 10;
        //
        //     // switch movement + camera state
        //     if (movementManager != null)
        //         movementManager.ChangeState(new FirstPersonCCState());
        //
        //     if (cameraManager != null)
        //         cameraManager.ChangeState(new FirstPersonCameraState());
        // }
        //
        // private void SwitchToThirdPerson()
        // {
        //     if (!_isFirstPerson) return;
        //     _isFirstPerson = false;
        //
        //     if (thirdPersonCam != null)
        //         thirdPersonCam.Priority = 20;
        //     if (firstPersonCam != null)
        //         firstPersonCam.Priority = 10;
        //
        //     if (_tpFollow == null && thirdPersonCam != null)
        //         _tpFollow = thirdPersonCam.GetCinemachineComponent<CinemachineThirdPersonFollow>();
        //
        //     if (_tpFollow != null)
        //         _tpFollow.CameraDistance = Mathf.Clamp(3f, minDistance, maxDistance);
        //
        //     if (movementManager != null)
        //         movementManager.ChangeState(new ThirdPersonCCState());
        //
        //     if (cameraManager != null)
        //         cameraManager.ChangeState(new ThirdPersonCameraState());
        // }
    }
}
```

```PlayerAddons\EXTENSIONS\other\ExtensionSnowCollector.cs
using UnityEngine;
using UnityEngine.VFX;

public class ExtensionSnowCollector : MonoBehaviour
{
    public float SnowCollectionCooldown = 2f;
    public float collectionTimer = 0f;

    [SerializeField] Camera maskCamera;
    [SerializeField] RenderTexture snowMaskTexture;
    [SerializeField] LayerMask snowLayerMask;   

    [SerializeField] VisualEffect snowVFX;
    [SerializeField] Transform playerTransform;
    
    private Texture2D maskTexture2D;

    void Start()
    {
        // Convert the render texture to regular Texture2D so we can work with it
        maskTexture2D = new Texture2D(snowMaskTexture.width, snowMaskTexture.height, TextureFormat.RGB24, false);
        ReadMaskTexture();
    }

    void Update()
    {
        // if the player wants to collect snow
        if (Input.GetKey(KeyCode.E))
        {
            Debug.Log("Snowing");
            snowVFX.SetFloat("Rate", 30f);

            // shoot ray at ground, see if we black or white
            Ray ray = new(playerTransform.position + new Vector3(0f, 1f), Vector3.down);
            Debug.DrawRay(playerTransform.position, Vector3.down);
            if (Physics.Raycast(ray, out RaycastHit hit, 4f, snowLayerMask))
            {
                Renderer renderer = hit.collider.GetComponent<Renderer>();

                if (renderer != null)
                {
                    Vector2 uv = hit.textureCoord;

                    float grayScale = maskTexture2D.GetPixelBilinear(uv.x, uv.y).grayscale;
                    if (grayScale < 0.5f)
                    {
                        UpdateMask(uv);

                        collectionTimer -= Time.deltaTime;
                        if (collectionTimer > 0f)
                            return;

                        collectionTimer = SnowCollectionCooldown;

                        CollectSnow(grayScale);
                    }
                }
            }
        }
        else
        {
            snowVFX.SetFloat("Rate", 0f);
        }
    }

    private void ReadMaskTexture()
    {
        RenderTexture.active = snowMaskTexture;
        maskTexture2D.ReadPixels(new Rect(0f, 0f, snowMaskTexture.width, snowMaskTexture.height), 0, 0);
        maskTexture2D.Apply();
        RenderTexture.active = null;
    }

    private void UpdateMask(Vector2 uv)
    {
        int x = (int)(uv.x * snowMaskTexture.width);
        int y = (int)(uv.y * snowMaskTexture.height);

        maskTexture2D.SetPixel(x, y, Color.white);
        maskTexture2D.Apply();

        Graphics.Blit(maskTexture2D, snowMaskTexture);
    }

    private void CollectSnow(float snowCollected)
    {
        snowCollected = Mathf.Clamp(snowCollected, 0.5f, 1f);

        float snowToAdd = (snowCollected - 0.5f) * 4f + 1f;

        StatsSingleton.Instance.IncreamentStat(StatType.Snow, snowToAdd);
    }
}
```

```PlayerAddons\EXTENSIONS\other\Knockbackable.cs
using UnityEngine;

public interface Knockbackable
{
    public void ApplyKnockback(Vector3 attackingPosition, float horizontalForce=0f, float verticalForce=0f);
}
```

```PlayerAddons\EXTENSIONS\other\Multiplayer\ExtensionNetworkedPlayer.cs
#if NETCODE

using Unity.Cinemachine;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.Events;
// ReSharper disable All

public class ExtensionNetworkedPlayer : NetworkBehaviour
{
    [SerializeField] private InputDirector inputDirector;
    [SerializeField] private MovementManager movementManager; // maybe remove this (I disable input)
    [SerializeField] private CameraManager cameraManager;
    [SerializeField] private Rigidbody rb;

    public UnityEvent<GameObject> OnNetworkSpawned;
    
    public override void OnNetworkSpawn()
    {
        inputDirector = GetComponentInChildren<InputDirector>();
        movementManager = GetComponentInChildren<MovementManager>();
        cameraManager = GetComponentInChildren<CameraManager>();

        // default to "you don't own this"
        movementManager.IsOwner = false;

        if (IsOwner)
        {
            ConfigPlayer_IfOwner();
            
            ConfigPlayerExtensions();
        }
        else
        {
            ConfigPlayer_NotOwner();
        }
    }

    private void FixedUpdate()
    {
        if (IsOwner)
        {
            // Local player will control this.
            // (through the movement manager and input director stuff)
        }
        else
        {
            // maybe if I will need smoothing later.
        }
    }

    /// <summary>
    /// if I am the owner of the object (this is the local player's object)
    /// </summary>
    private void ConfigPlayer_NotOwner()
    {
        // set "isOwner" in relavant scripts
        inputDirector.IsOwner = false;
        movementManager.IsOwner = false;

        // disable relavant objects:
        // input
        inputDirector.gameObject.SetActive(false);

        // camera
        GameObject localCamObject = GetComponentInChildren<CinemachineCamera>().gameObject;
        localCamObject.SetActive(false);

        // visibillity Layer
        GameObject localSelfObject = GetComponentInChildren<SelfForDisable>().gameObject;
        int defaultLayer = 0;
        localSelfObject.layer = defaultLayer;
    }

    /// <summary>
    /// if I am not the owner of the object (this is running on a different player)
    /// </summary>
    private void ConfigPlayer_IfOwner()
    {
        // set "isOwner" in relavant scripts
        movementManager.IsOwner = true;
        inputDirector.IsOwner = true;

        // initiate the player movement components
        InputDirector.Instance = inputDirector;
        movementManager.StartingState = new FpState();
        cameraManager.StartingState = new FP_CameraState();
    }

    /// <summary>
    /// if I am the owner:
    /// add relavant extensions.
    /// </summary>
    private void ConfigPlayerExtensions()
    {
        GameObject playerObject = inputDirector.gameObject;

        OnNetworkSpawned?.Invoke(playerObject);
    }
}
#endif
```

```PlayerAddons\EXTENSIONS\other\Multiplayer\IPlayerDataMultiplayer.cs
using UnityEngine;

public interface IPlayerDataMultiplayer
{
    
}
```

```PlayerAddons\EXTENSIONS\other\Multiplayer\MultiplayerStoryExample.cs
#if NETCODE
using Unity.Netcode;
using UnityEngine;

/// <summary>
/// Regular stories control the game. this is a host only version,
/// Responsible for starting the different connecting players.
/// And, this is the story of the server.
/// </summary>
public class MultiplayerStoryExample : NetworkBehaviour
{
    // this should change for each game story!
    [SerializeField] GameObject playerPrefab;

    public override void OnNetworkSpawn()
    {
        if (!IsServer) return;

        SpawnPlayers(); // Spawn the already connected players

        NetworkManager.Singleton.OnClientConnectedCallback += Singleton_OnClientConnectedCallback;
    }

    private void Singleton_OnClientConnectedCallback(ulong clientId)
    {
        if (!IsServer) return;

        SpawnPlayer(clientId);
    }

    void SpawnPlayers()
    {
        // called on host, spawns 1 prefab per client
        foreach (var clientId in NetworkManager.Singleton.ConnectedClientsIds)
        {
            SpawnPlayer(clientId);
        }
    }

    void SpawnPlayer(ulong clientId)
    {
        GameObject player = Instantiate(playerPrefab, new Vector3(0f, 2f, 0f), Quaternion.identity);

        var netObj = player.GetComponent<NetworkObject>();
        netObj.SpawnAsPlayerObject(clientId);

        Debug.Log($"[Netcode] Spawning player prefab with hash: {netObj.PrefabIdHash}");
    }

    public override void OnDestroy()
    {
        base.OnDestroy();

        if (NetworkManager.Singleton != null)
            NetworkManager.Singleton.OnClientConnectedCallback -= Singleton_OnClientConnectedCallback;
    }
}
#endif
```

```PlayerAddons\EXTENSIONS\other\Multiplayer\OldMultiplayerManager.cs
using System.Collections.Generic;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Events;

// ReSharper disable All

public class OldMultiplayerManager
{
    // singleton
    private static OldMultiplayerManager _instance;
    public static OldMultiplayerManager Instance => _instance ??= new OldMultiplayerManager();
    
    // personal data
    public int localId;
    
    // events
    public UnityEvent OnNewPlayerRegistered;
    public UnityEvent OnPlayerDisconnected;
    
    // player data object (new one per player)
    public Dictionary<int, IPlayerDataMultiplayer> PlayersDict = new();
    public int CountPlayers = 0;
    
    // functions to get player by data
    public int RegisterNewPlayer(IPlayerDataMultiplayer playerData, bool localPlayer=false)
    {
        // set playerid
        int playerID = CountPlayers;
        CountPlayers++;
        
        // add player to dictionary
        if (PlayersDict.ContainsKey(playerID))
            Debug.LogError($"PlayerID {playerID} is already registered!");
        
        PlayersDict[playerID] = playerData;

        if (localPlayer)
            localId = playerID;
        OnNewPlayerRegistered?.Invoke();
        
        return playerID;
    }
    
    [CanBeNull]
    public IPlayerDataMultiplayer TryGetPlayerByID(int id)
    {
        if (!PlayersDict.ContainsKey(id))
        {
            Debug.LogError($"PlayerID {id} is not registered!");
            return null;
        }
        
        return PlayersDict[id];
    }
    
    [CanBeNull]
    public IPlayerDataMultiplayer TryGetLocalPlayer()
    {
        if (!PlayersDict.ContainsKey(localId))
        {
            Debug.LogError($"Local Player is not registered!");
            return null;
        }
        
        return PlayersDict[localId];
    }

    [CanBeNull]
    public void RemovePlayer(int id)
    {
        if (!PlayersDict.Remove(id))
            Debug.LogError($"Can't Remove PlayerID: {id} is not registered!");
        
        Debug.Log($"Removed player: {id}");
    }
}
```

```PlayerAddons\EXTENSIONS\other\Multiplayer\ShutdownMultiplayer.cs
#if NETCODE
using Unity.Netcode;
#endif
using UnityEngine;

public class ShutdownMultiplayer : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    private void OnDestroy()
    {
        #if NETCODE
        if (NetworkManager.Singleton != null && NetworkManager.Singleton.IsListening)
            NetworkManager.Singleton.Shutdown();
#endif
    }
}
```

```PlayerAddons\EXTENSIONS\other\Multiplayer\GameExample\EnemyPlayer.cs
using UnityEngine;

public class EnemyPlayer : MonoBehaviour, IDamageable
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {

    }

    public void TakeDamage(float damage)
    {
        // show black you died UI
        
        // move player to somewhere else

        // invoke respawn logic

    }
}
```

```PlayerAddons\EXTENSIONS\rigidbody\ExtensionKnockback.cs
using UnityEngine;

public class ExtensionKnockback : MonoBehaviour, Knockbackable
{
    [SerializeField] private float knockbackBackwardsForce = 12f;
    [SerializeField] private float knockbackUpForce = 9f;
    private Rigidbody _rb;

    private void Awake()
    {
        _rb = GetComponent<Rigidbody>();
    }

    public void ApplyKnockback(Vector3 attackingPosition, float horizontalForce=0f, float verticalForce=0f)
    {
        Vector3 pushDirection = (transform.position - attackingPosition).normalized;
        Vector3 pushForce =  pushDirection * knockbackBackwardsForce;
        pushForce.y = knockbackUpForce;
        
        _rb.AddForce(pushForce, ForceMode.Impulse);
    }
}
```

```PlayerAddons\EXTENSIONS\rigidbody\SimpleGrapple\ExtensionSimpleGraplingHook.cs
using UnityEngine;

public class ExtensionSimpleGraplingHook : MonoBehaviour
{
    private InputDirector _inputDirector;
    public Camera Cam;
    public LineRenderer RopeLine;

    [Header("Grapple")]
    public float MaxGrappleDistance = 60f;
    public Color HighlightColor = Color.yellow;
    private bool _hittingGrappleStick;
    private RaycastHit _grappleHit;

    private Rigidbody _rb;
    private ConfigurableJoint _joint;
    private GrappleTarget _currentHighlight;
    private Vector3 _grappleHitPoint;
    private float _ropeLength;
    
    private void Start()
    {
        // collect input
        _inputDirector = GetComponent<InputDirector>();
        _inputDirector.OnFireStarted += StartGrapple;
        _inputDirector.OnFireReleased += StopGrapple;
        
        // collect references
        _rb = GetComponent<Rigidbody>();
        if (!Cam) Cam = Camera.main;
        if (RopeLine)
        {
            RopeLine.positionCount = 2;
            RopeLine.enabled = false;
        }
    }

    private void Update()
    {
        // select highlight OR null if aiming on nothing
        Ray ray = new  Ray(Cam.transform.position, Cam.transform.forward);
        if (Physics.Raycast(ray, out _grappleHit, MaxGrappleDistance))
            _hittingGrappleStick = true;

        HighlightGrappleStick();

        UpdateRopeVisual();
    }

    private void FixedUpdate()
    {
        // keep the joint's connected anchor "pinned" in world space even if the stick moves slightly
        if (_joint)
            _joint.connectedAnchor = _grappleHitPoint;
    }

    private void StartGrapple()
    {
        if (_joint || !_hittingGrappleStick)
            return;
        
        if (!_grappleHit.collider.CompareTag("GrappleStick"))
            return;
        
        _grappleHitPoint = _grappleHit.point;
        
        ConfigureRope();
    }

    private void StopGrapple()
    {
        if (_joint) Destroy(_joint);
        _joint = null;
        _rb.linearDamping = 0f;
    }

    private void HighlightGrappleStick()
    {
        // new stick we just hit
        GrappleTarget newTarget = null;
        
        // did we hit a stick?
        if (_hittingGrappleStick)
            _grappleHit.collider.TryGetComponent(out newTarget);

        if (newTarget != _currentHighlight)
        {
            if (_currentHighlight) _currentHighlight.SetHighlighted();
            if (newTarget) newTarget.SetHighlighted(HighlightColor);
            _currentHighlight = newTarget;
        }
    }

    private void ConfigureRope()
    {
        // fixed rope length from current position to stick
        _ropeLength = Vector3.Distance(transform.position, _grappleHitPoint);
        
        // build a hard-length "rope" using ConfigurableJoint
        _joint = gameObject.AddComponent<ConfigurableJoint>();
        _joint.autoConfigureConnectedAnchor = false;
        _joint.connectedAnchor = _grappleHitPoint;
        
        // lock angular motion so the rope behaves like a pivot
        _joint.angularXMotion = ConfigurableJointMotion.Free;
        _joint.angularYMotion = ConfigurableJointMotion.Free;
        _joint.angularZMotion = ConfigurableJointMotion.Free;
        
        // linear limited motion (distance cannot exceed ropelength)
        _joint.xMotion = ConfigurableJointMotion.Limited;
        _joint.yMotion = ConfigurableJointMotion.Limited;
        _joint.zMotion = ConfigurableJointMotion.Limited;

        SoftJointLimit jointLimit = new SoftJointLimit()
            { limit = _ropeLength, bounciness = 0f, contactDistance = 0.01f };
        _joint.linearLimit = jointLimit;
        
        // zero spring makes it a rigid limit (no elastic pull)
        var spring = new SoftJointLimitSpring { spring = 0f, damper = 0f };
        _joint.linearLimitSpring = spring;
        
        // give a little solver stability
        _joint.enableCollision = false;
        _joint.breakForce = Mathf.Infinity;
        _joint.breakTorque = Mathf.Infinity;

        // slightly damp velocity perpendicular to rope to reduce jitter
        _rb.linearDamping = 0.05f;

        // start rope visual
        if (RopeLine) RopeLine.enabled = true;
    }

    private void UpdateRopeVisual()
    {
        if (_joint && RopeLine)
        {
            RopeLine.enabled = true;
            RopeLine.SetPosition(0, _grappleHitPoint);
            RopeLine.SetPosition(1, transform.position + Vector3.forward * 1f); // end at player center
        }
        else if (RopeLine)
        {
            RopeLine.enabled = false;
        }
    }

    private void OnDestroy()
    {
        // remove inputs
        _inputDirector.OnFireStarted -= StartGrapple;
        _inputDirector.OnFireReleased -= StopGrapple;
        
        // remove grapple leftovers
        if (_currentHighlight) _currentHighlight.SetHighlighted();
        if (_joint) Destroy(_joint);
        if (RopeLine) RopeLine.enabled = false;
    }
}
```

```PlayerAddons\EXTENSIONS\rigidbody\SimpleGrapple\GrappleTarget.cs
using UnityEngine;

[RequireComponent(typeof(Renderer))]
public class GrappleTarget : MonoBehaviour
{
    private static readonly int ColorProperty = Shader.PropertyToID("_Color");
    private Renderer _rend;
    private Color _baseColor;
    private bool _hasProperty;

    private void Awake()
    {
        _rend = GetComponent<Renderer>();
        
        if (!_rend.material.HasProperty(ColorProperty)) return;
        _hasProperty = true;
        _baseColor = _rend.material.color;
    }

    public void SetHighlighted(Color? highlightColor = null)
    {
        if (!_hasProperty) return;
        _rend.material.color = highlightColor ?? _baseColor;
        
        Debug.Log(gameObject.name + " has been set to " + highlightColor);
    }
}
```

```PlayerAddons\rigidbody\Bike\BikeState.cs
using System;
using UnityEngine;

public class BikeState : MovementState
{

    public override MovementComponentType ComponentType => MovementComponentType.Rigidbody;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        throw new System.NotImplementedException();
    }

    public override void EnterState()
    {
        throw new System.NotImplementedException();
    }

    public override void UpdateState()
    {
        throw new System.NotImplementedException();
    }

    public override void FixedUpdate()
    {
        throw new System.NotImplementedException();
    }

    public override void CleanState()
    {
        throw new System.NotImplementedException();
    }
}
```

```PlayerAddons\rigidbody\Bike\BETA\BikeController.cs
using UnityEngine;

public class BikeController : MonoBehaviour
{
    [Header("Movement")]
    private float _moveInput, _steerInput;
    public float MaxSpeed, Acceleration, SteerStrength;

    [Header("Rotations")]
    public AnimationCurve TurningCurve;
    
    public float BikeXRotationInterpolationSpeed = 0.09f;
    public float BikeZTiltAngle = 45f;
    private float _currentVelocityOffset;
    private Vector3 _velocity;

    [SerializeField] private GameObject handleObject;
    public float RotationValueHandle = 30f;
    public float RotationSpeedHandle = 0.15f;
    
    [Header("Brake")]
    [Range(1, 10)]
    public float BrakingFactor;
    private bool _isBraking = false;

    [Header("Grounded")]
    public Rigidbody SphereRb, BikeBody;

    public bool IsGroundedObserver => IsGrounded();

    public float GravityValue;
    
    private float _groundCheckDistance;
    private RaycastHit _groundHit;
    public LayerMask GroundLayer;
    
    private void Start()
    {
        // subscribe to input events
        SphereRb.transform.parent = null;
        BikeBody.transform.parent = null;
        
        // ignore collision
        BoxCollider bikeCollider = BikeBody.GetComponent<BoxCollider>();
        SphereCollider sphereCollider = SphereRb.GetComponent<SphereCollider>();
        
        Physics.IgnoreCollision(bikeCollider, sphereCollider);
        
        // ground check
        _groundCheckDistance = sphereCollider.radius + 0.2f;
    }

    private void Update()
    {
        _moveInput = Input.GetAxis("Vertical");
        _steerInput = Input.GetAxis("Horizontal");
        _isBraking = Input.GetKey(KeyCode.Space);
        
        transform.position = SphereRb.transform.position;
        _velocity = BikeBody.transform.InverseTransformDirection(BikeBody.linearVelocity);
        _currentVelocityOffset = _velocity.z / MaxSpeed;
    }

    private void FixedUpdate()
    {
        Movement();
    }

    private void Movement()
    {
        if (IsGrounded())
        {
            if (!_isBraking)
            {
                AccelerateBike();
                RotateBike();
            }
            BrakeBike();
        }
        else
            ApplyGravity();
        TiltForwardBike();
    }

    private void AccelerateBike()
    {
        Vector3 movementValue = MaxSpeed * _moveInput * transform.forward;
        SphereRb.linearVelocity = Vector3.Lerp(SphereRb.linearVelocity, movementValue, Time.fixedDeltaTime * Acceleration);
    }

    private void RotateBike()
    {
        float turningCurve = TurningCurve.Evaluate(Mathf.Abs(_currentVelocityOffset));
        float rotationValue = _steerInput * _moveInput * turningCurve * SteerStrength * Time.fixedDeltaTime;
        transform.Rotate(0, rotationValue, 0, Space.World);
        
        // visual handle rotation
        Quaternion handleLocalRotation = handleObject.transform.localRotation;
        handleObject.transform.localRotation = Quaternion.Slerp(
            handleLocalRotation,
            Quaternion.Euler(handleLocalRotation.x, RotationValueHandle * _steerInput, handleLocalRotation.z),
            RotationSpeedHandle);
    }

    private void TiltForwardBike()
    {
        float xRotation =
            (Quaternion.FromToRotation(BikeBody.transform.up, _groundHit.normal) * BikeBody.transform.rotation)
            .eulerAngles.x;
        
        float zRotation = 0f;
        
        // how much I want to rotate * where I am rotating * am I rotating?
        if (_currentVelocityOffset > 0f)
            zRotation = -BikeZTiltAngle * _steerInput * _currentVelocityOffset;

        Quaternion targetRotation = Quaternion.Slerp(BikeBody.transform.rotation,
            Quaternion.Euler(xRotation, transform.eulerAngles.y, zRotation),
            BikeXRotationInterpolationSpeed);
        
        Quaternion newRotation = Quaternion.Euler(targetRotation.eulerAngles.x, transform.eulerAngles.y, targetRotation.eulerAngles.z);
        
        BikeBody.MoveRotation(newRotation);
    }

    private void BrakeBike()
    {
        if (_isBraking)
            SphereRb.linearVelocity *= BrakingFactor / 10;
    }

    private void ApplyGravity()
    {
        SphereRb.AddForce(GravityValue * Vector3.down, ForceMode.Acceleration);
    }
    
    private bool IsGrounded() => Physics.Raycast(SphereRb.position, Vector3.down, out _groundHit, GroundLayer);
}
```

```PlayerAddons\rigidbody\DeprecatedFirstPerson\daniTest\PlayerMovement.cs
// Some stupid rigidbody based movement by Dani

using System;
using UnityEngine;

public class PlayerMovement : MonoBehaviour {

    //Assingables
    public Transform playerCam;
    public Transform orientation;
    public Transform playerTransform;
    
    //Other
    private Rigidbody rb;

    //Rotation and look
    private float xRotation;
    private float sensitivity = 50f;
    private float sensMultiplier = 1f;
    
    //Movement
    public float moveSpeed = 4500;
    public float maxSpeed = 20;
    public bool grounded;
    public LayerMask whatIsGround;
    
    public float counterMovement = 0.175f;
    private float threshold = 0.01f;
    public float maxSlopeAngle = 35f;

    //Crouch & Slide
    private Vector3 crouchScale = new(1, 0.5f, 1);
    private Vector3 playerScale;
    public float slideForce = 400;
    public float slideCounterMovement = 0.2f;

    //Jumping
    private bool readyToJump = true;
    private float jumpCooldown = 0.25f;
    public float jumpForce = 550f;
    
    //Input
    float x, y;
    bool jumping, sprinting, crouching;
    
    //Sliding
    private Vector3 normalVector = Vector3.up;
    private Vector3 wallNormalVector;

    void Awake() {
        playerTransform = transform;
        rb = GetComponent<Rigidbody>();
    }
    
    void Start() {
        playerScale =  playerTransform.localScale;
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    
    private void FixedUpdate() {
        Movement();
    }

    private void Update() {
        MyInput();
        Look();
    }

    /// <summary>
    /// Find user input. Should put this in its own class but im lazy
    /// </summary>
    private void MyInput() {
        x = Input.GetAxisRaw("Horizontal");
        y = Input.GetAxisRaw("Vertical");
        jumping = Input.GetButton("Jump");
        crouching = Input.GetKey(KeyCode.LeftControl);
      
        //Crouching
        if (Input.GetKeyDown(KeyCode.LeftControl))
            StartCrouch();
        if (Input.GetKeyUp(KeyCode.LeftControl))
            StopCrouch();
    }

    private void StartCrouch() {
        playerTransform.localScale = crouchScale;
        playerTransform.position = new Vector3(transform.position.x, playerTransform.position.y - 0.5f, playerTransform.position.z);
        if (rb.linearVelocity.magnitude > 0.5f) {
            if (grounded) {
                rb.AddForce(orientation.transform.forward * slideForce);
            }
        }
    }

    private void StopCrouch() {
        playerTransform.localScale = playerScale;
        playerTransform.position = new Vector3(transform.position.x, playerTransform.position.y + 0.5f, playerTransform.position.z);
    }

    private void Movement() {
        //Extra gravity
        rb.AddForce(Vector3.down * Time.deltaTime * 10);
        
        //Find actual velocity relative to where player is looking
        Vector2 mag = FindVelRelativeToLook();
        float xMag = mag.x, yMag = mag.y;

        //Counteract sliding and sloppy movement
        CounterMovement(x, y, mag);
        
        //If holding jump && ready to jump, then jump
        if (readyToJump && jumping) Jump();

        //Set max speed
        float maxSpeed = this.maxSpeed;
        
        //If sliding down a ramp, add force down so player stays grounded and also builds speed
        if (crouching && grounded && readyToJump) {
            rb.AddForce(Vector3.down * Time.deltaTime * 3000);
            return;
        }
        
        //If speed is larger than maxspeed, cancel out the input so you don't go over max speed
        if (x > 0 && xMag > maxSpeed) x = 0;
        if (x < 0 && xMag < -maxSpeed) x = 0;
        if (y > 0 && yMag > maxSpeed) y = 0;
        if (y < 0 && yMag < -maxSpeed) y = 0;

        //Some multipliers
        float multiplier = 1f, multiplierV = 1f;
        
        // Movement in air
        if (!grounded) {
            multiplier = 0.5f;
            multiplierV = 0.5f;
        }
        
        // Movement while sliding
        if (grounded && crouching) multiplierV = 0f;

        //Apply forces to move player
        rb.AddForce(orientation.transform.forward * y * moveSpeed * Time.deltaTime * multiplier * multiplierV);
        rb.AddForce(orientation.transform.right * x * moveSpeed * Time.deltaTime * multiplier);
    }

    private void Jump() {
        if (grounded && readyToJump) {
            readyToJump = false;

            //Add jump forces
            rb.AddForce(Vector2.up * jumpForce * 1.5f);
            rb.AddForce(normalVector * jumpForce * 0.5f);
            
            //If jumping while falling, reset y velocity.
            Vector3 vel = rb.linearVelocity;
            if (rb.linearVelocity.y < 0.5f)
                rb.linearVelocity = new Vector3(vel.x, 0, vel.z);
            else if (rb.linearVelocity.y > 0) 
                rb.linearVelocity = new Vector3(vel.x, vel.y / 2, vel.z);
            
            Invoke(nameof(ResetJump), jumpCooldown);
        }
    }
    
    private void ResetJump() {
        readyToJump = true;
    }
    
    private float desiredX;
    private void Look() {
        float mouseX = Input.GetAxis("Mouse X") * sensitivity * Time.fixedDeltaTime * sensMultiplier;
        float mouseY = Input.GetAxis("Mouse Y") * sensitivity * Time.fixedDeltaTime * sensMultiplier;

        //Find current look rotation
        Vector3 rot = playerCam.transform.localRotation.eulerAngles;
        desiredX = rot.y + mouseX;
        
        //Rotate, and also make sure we dont over- or under-rotate.
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        //Perform the rotations
        playerCam.transform.localRotation = Quaternion.Euler(xRotation, desiredX, 0);
        orientation.transform.localRotation = Quaternion.Euler(0, desiredX, 0);
    }

    private void CounterMovement(float x, float y, Vector2 mag) {
        if (!grounded || jumping) return;

        //Slow down sliding
        if (crouching) {
            rb.AddForce(moveSpeed * Time.deltaTime * -rb.linearVelocity.normalized * slideCounterMovement);
            return;
        }

        //Counter movement
        if (Math.Abs(mag.x) > threshold && Math.Abs(x) < 0.05f || (mag.x < -threshold && x > 0) || (mag.x > threshold && x < 0)) {
            rb.AddForce(moveSpeed * orientation.transform.right * Time.deltaTime * -mag.x * counterMovement);
        }
        if (Math.Abs(mag.y) > threshold && Math.Abs(y) < 0.05f || (mag.y < -threshold && y > 0) || (mag.y > threshold && y < 0)) {
            rb.AddForce(moveSpeed * orientation.transform.forward * Time.deltaTime * -mag.y * counterMovement);
        }
        
        //Limit diagonal running. This will also cause a full stop if sliding fast and un-crouching, so not optimal.
        if (Mathf.Sqrt((Mathf.Pow(rb.linearVelocity.x, 2) + Mathf.Pow(rb.linearVelocity.z, 2))) > maxSpeed) {
            float fallspeed = rb.linearVelocity.y;
            Vector3 n = rb.linearVelocity.normalized * maxSpeed;
            rb.linearVelocity = new Vector3(n.x, fallspeed, n.z);
        }
    }

    /// <summary>
    /// Find the velocity relative to where the player is looking
    /// Useful for vectors calculations regarding movement and limiting movement
    /// </summary>
    /// <returns></returns>
    public Vector2 FindVelRelativeToLook() {
        float lookAngle = orientation.transform.eulerAngles.y;
        float moveAngle = Mathf.Atan2(rb.linearVelocity.x, rb.linearVelocity.z) * Mathf.Rad2Deg;

        float u = Mathf.DeltaAngle(lookAngle, moveAngle);
        float v = 90 - u;

        float magnitue = rb.linearVelocity.magnitude;
        float yMag = magnitue * Mathf.Cos(u * Mathf.Deg2Rad);
        float xMag = magnitue * Mathf.Cos(v * Mathf.Deg2Rad);
        
        return new Vector2(xMag, yMag);
    }

    private bool IsFloor(Vector3 v) {
        float angle = Vector3.Angle(Vector3.up, v);
        return angle < maxSlopeAngle;
    }

    private bool cancellingGrounded;
    
    /// <summary>
    /// Handle ground detection
    /// </summary>
    private void OnCollisionStay(Collision other) {
        //Make sure we are only checking for walkable layers
        int layer = other.gameObject.layer;
        if (whatIsGround != (whatIsGround | (1 << layer))) return;

        //Iterate through every collision in a physics update
        for (int i = 0; i < other.contactCount; i++) {
            Vector3 normal = other.contacts[i].normal;
            //FLOOR
            if (IsFloor(normal)) {
                grounded = true;
                cancellingGrounded = false;
                normalVector = normal;
                CancelInvoke(nameof(StopGrounded));
            }
        }

        //Invoke ground/wall cancel, since we can't check normals with CollisionExit
        float delay = 3f;
        if (!cancellingGrounded) {
            cancellingGrounded = true;
            Invoke(nameof(StopGrounded), Time.deltaTime * delay);
        }
    }

    private void StopGrounded() {
        grounded = false;
    }
    
}
```

```PlayerAddons\rigidbody\DeprecatedFirstPerson\daniTest\moveCameraDani.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class moveCameraDani : MonoBehaviour
{
    public GameObject player;

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.position = player.transform.position;
    }
}
```

```PlayerAddons\rigidbody\DeprecatedFirstPerson\scripts\CameraStateFirstPerson.cs
using UnityEngine;

public class CameraStateFirstPerson : CameraState
{
    // CamObject
    GameObject _virtualCam;
    Transform orientation; // Character is orientation.

    // values (input)
    private float mouseX = 0f;
    private float mouseY = 0f;

    // values (static)
    private float xRotation;
    private float sensitivityX = 5f;
    private float sensitivityY = 7f;
    private float sensMultiplier = 1f;
    private float desiredX;


    // Init functions
    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
        Manager = manager;

        // subscribe to input events
        InputDirector.OnCameraMoved += _inputDirector_OnCameraMoved;
    }

    public override void EnterState()
    {
        orientation = Manager.transform.GetComponentInChildren<Animator>().gameObject.transform;
        _virtualCam = Manager.CurrentCinemachineComponent.gameObject;
    }


    // input events
    private void _inputDirector_OnCameraMoved(Vector2 camValue)
    {
        mouseX = camValue.x;
        mouseY = camValue.y;
    }

    public override void UpdateState()
    {
        CameraLogic();
    }

    public override void FixedUpdate()
    {
        
    }

    // Logic
    public void CameraLogic()
    {
        // Calculate value change
        mouseX = mouseX * sensitivityX * Time.fixedDeltaTime * sensMultiplier;
        mouseY = mouseY * sensitivityY * Time.fixedDeltaTime * sensMultiplier;

        // Find current look rotation
        Vector3 rot = _virtualCam.transform.localRotation.eulerAngles;
        desiredX = rot.y + mouseX;

        // Rotate, and also make sure we dont over- or under-rotate.
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        // Perform the rotations
        _virtualCam.transform.localRotation = Quaternion.Euler(xRotation, desiredX, 0);
        orientation.localRotation = Quaternion.Euler(0, desiredX, 0);
    }


    // Destructions
    public override void ClearState()
    {
        
    }

    public override void OnDestroy()
    {
        InputDirector.OnCameraMoved -= _inputDirector_OnCameraMoved;
    }
}
```

```PlayerAddons\rigidbody\DeprecatedFirstPerson\scripts\FirstPersonState.cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FirstPersonState : MovementState
{
    // Assignables
    public Rigidbody rb;
    public Transform playerTransform;
    public Transform orientation;
    public Animator character;

    // values (input)
    float x;
    float y;
    public float xMovement = 0f;
    public float yMovement = 0f;
    public Vector2 testingMovme = Vector2.zero;
    public bool holdingJump = false;
    public bool holdingCrouch = false;

    // values (static)
    [Header("Movement")]
    public float moveSpeed = 4500;
    public float maxSpeed = 20;

    public float counterMovement = 0.175f;
    private float threshold = 0.01f;

    [Header("Jumping")]
    public bool readyToJump = true;
    private float jumpCooldown = 0.25f;
    public float jumpForce = 550f;

    [Header("Grounded Check")]
    public bool grounded;
    public LayerMask whatIsGround;
    public float maxSlopeAngle = 35f;

    [Header("Crouching")]
    private Vector3 crouchScale = new(1, 0.5f, 1);
    private Vector3 playerScale;

    [Header("Sliding")]
    public float slideForce = 400;
    public float slideCounterMovement = 0.2f;
    private Vector3 normalVector = Vector3.up;
    private Vector3 wallNormalVector;


    // State Machine

    public override MovementComponentType ComponentType => MovementComponentType.Rigidbody;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        // Player Family
        Controller = manager;
        Director = director;

        // Assignables
        playerTransform = manager.transform.parent.transform;
        orientation = manager.transform.parent.GetComponentInChildren<Animator>().gameObject.transform;

        // load movement data
        LocalData = Resources.Load<PlayerStateData>("playerStates/normalPlayer");
        
        // input events
        Director.OnPlayerMoved += _director_OnPlayerMoved;
        Director.OnPlayerMovedFinished += _director_OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted += _director_OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped += _director_OnPlayerJumpStopped;
        Director.OnPlayerCrouchStarted += _director_OnPlayerCrouchStarted;
        Director.OnPlayerCrouchStopped += _director_OnPlayerCrouchStopped;
    }

    public override void EnterState()
    {
        character = Controller.transform.parent.GetComponentInChildren<Animator>();

        // start enter state animation

        rb = Controller.gameObject.GetComponent<Rigidbody>();

        Debug.Log("Entering FPS state!");
    }

    public override void FixedUpdate()
    {
        grounded = isGrounded();
        Movement();
    }

    public override void UpdateState()
    {
        xMovement = x;
        yMovement = y;
    }

    public override void CleanState()
    {
        Director.GetComponent<AnimationsManager>().SetFloat("MoveX", 0f);
        Director.GetComponent<AnimationsManager>().SetFloat("MoveY", 0f);

        Vector3 movementVelocity = new(0f, rb.linearVelocity.y, 0f);
        rb.linearVelocity = movementVelocity;
    }

    // Logic
    // Fixed Update Movement
    private void Movement()
    {
        //Extra gravity
        rb.AddForce(Vector3.down * (Time.deltaTime * 100));

        //Find actual velocity relative to where player is looking
        Vector2 mag = FindVelRelativeToLook();
        float xMag = mag.x, yMag = mag.y;

        //Counteract sliding and sloppy movement
        CounterMovement(xMovement, yMovement, mag);

        //If holding jump && ready to jump, then jump
        if (readyToJump && holdingJump) jump();

        //Set max speed
        float maxSpeed = this.maxSpeed;

        //If sliding down a ramp, add force down so player stays grounded and also builds speed
        if (holdingCrouch && grounded && readyToJump)
        {
            rb.AddForce(Vector3.down * Time.deltaTime * 3000);
            return;
        }

        //If speed is larger than maxspeed, cancel out the input so you don't go over max speed
        if (xMovement > 0 && xMag > maxSpeed) xMovement = 0;
        if (xMovement < 0 && xMag < -maxSpeed) xMovement = 0;
        if (yMovement > 0 && yMag > maxSpeed) yMovement = 0;
        if (yMovement < 0 && yMag < -maxSpeed) yMovement = 0;

        //Some multipliers
        float multiplier = 1f, multiplierV = 1f;

        // Movement in air
        if (!grounded)
        {
            multiplier = 0.5f;
            multiplierV = 0.5f;
        }

        // Movement while sliding
        if (grounded && holdingCrouch) multiplierV = 0f;

        //Apply forces to move player
        rb.AddForce(orientation.forward * yMovement * moveSpeed * Time.deltaTime * multiplier * multiplierV);
        rb.AddForce(orientation.right * xMovement * moveSpeed * Time.deltaTime * multiplier);
    }

    /// <summary>
    /// Find the velocity relative to where the player is looking
    /// Useful for vectors calculations regarding movement and limiting movement
    /// </summary>
    /// <returns></returns>
    public Vector2 FindVelRelativeToLook()
    {
        float lookAngle = orientation.eulerAngles.y;
        float moveAngle = Mathf.Atan2(rb.linearVelocity.x, rb.linearVelocity.z) * Mathf.Rad2Deg;

        float u = Mathf.DeltaAngle(lookAngle, moveAngle);
        float v = 90 - u;

        float magnitue = rb.linearVelocity.magnitude;
        float yMag = magnitue * Mathf.Cos(u * Mathf.Deg2Rad);
        float xMag = magnitue * Mathf.Cos(v * Mathf.Deg2Rad);

        return new Vector2(xMag, yMag);
    }

    // counter sloppy movement and for sliding
    private void CounterMovement(float x, float y, Vector2 mag)
    {
        if (!grounded || holdingJump) return;

        //Slow down sliding
        if (holdingCrouch)
        {
            rb.AddForce(moveSpeed * Time.deltaTime * -rb.linearVelocity.normalized * slideCounterMovement);
            return;
        }

        //Counter movement
        if (Math.Abs(mag.x) > threshold && Math.Abs(x) < 0.05f || (mag.x < -threshold && x > 0) || (mag.x > threshold && x < 0))
        {
            rb.AddForce(moveSpeed * orientation.right * Time.deltaTime * -mag.x * counterMovement);
        }
        if (Math.Abs(mag.y) > threshold && Math.Abs(y) < 0.05f || (mag.y < -threshold && y > 0) || (mag.y > threshold && y < 0))
        {
            rb.AddForce(moveSpeed * orientation.forward * Time.deltaTime * -mag.y * counterMovement);
        }

        //Limit diagonal running. This will also cause a full stop if sliding fast and un-crouching, so not optimal.
        if (Mathf.Sqrt((Mathf.Pow(rb.linearVelocity.x, 2) + Mathf.Pow(rb.linearVelocity.z, 2))) > maxSpeed)
        {
            float fallspeed = rb.linearVelocity.y;
            Vector3 n = rb.linearVelocity.normalized * maxSpeed;
            rb.linearVelocity = new Vector3(n.x, fallspeed, n.z);
        }
    }

    // jump and ground
    private void jump()
    {
        if (grounded && readyToJump)
        {
            readyToJump = false;

            //Add jump forces
            rb.AddForce(Vector2.up * jumpForce * 1.5f);
            rb.AddForce(normalVector * jumpForce * 0.5f);

            //If jumping while falling, reset y velocity.
            Vector3 vel = rb.linearVelocity;
            if (rb.linearVelocity.y < 0.5f)
                rb.linearVelocity = new Vector3(vel.x, 0, vel.z);
            else if (rb.linearVelocity.y > 0)
                rb.linearVelocity = new Vector3(vel.x, vel.y / 2, vel.z);

            Controller.StartCoroutine(ResetJump());
        }
    }

    private IEnumerator ResetJump()
    {
        yield return new WaitForSeconds(jumpCooldown);
        readyToJump = true;
    }

    bool isGrounded()
    {
        float sphereRadius = 0.1f; // Adjust the radius as needed
        Vector3 rayStart = playerTransform.position - new Vector3(0f, 0.3f, 0f);

        Collider[] hitColliders = new Collider[1];
        int numColliders = Physics.OverlapSphereNonAlloc(rayStart, sphereRadius, hitColliders, ~3);
        return numColliders > 0;
    }
    
    
    
    // Input Events
    private void _director_OnPlayerMovedFinished()
    {
        x = 0f;
        y = 0f;
    }

    private void _director_OnPlayerMoved(Vector2 movementValue)
    {
        x = movementValue.x;
        y = movementValue.y;
    }

    private void _director_OnPlayerJumpStarted()
    {
        holdingJump = true;
    }
    private void _director_OnPlayerJumpStopped()
    {
        holdingJump = false;
    }

    private void _director_OnPlayerCrouchStarted()
    {
        holdingCrouch = true;
        playerTransform.localScale = crouchScale;
        playerTransform.position = new Vector3(playerTransform.position.x, playerTransform.position.y - 0.5f, playerTransform.position.z);
        if (rb.linearVelocity.magnitude > 0.5f)
        {
            if (grounded)
            {
                rb.AddForce(orientation.transform.forward * slideForce);
            }
        }
    }

    private void _director_OnPlayerCrouchStopped()
    {
        holdingCrouch = false;
        playerTransform.localScale = playerScale;
        playerTransform.position = new Vector3(playerTransform.position.x, playerTransform.position.y + 0.5f, playerTransform.position.z);
    }
}
```

```PlayerAddons\rigidbody\DeprecatedFirstPerson\scripts\firstPersonStoryExample.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class firstPersonStoryExample : MonoBehaviour
{
    private void Awake()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
            return;
        MovementManager movementManager = player.GetComponentInChildren<MovementManager>();
        CameraManager cameraManager = player.GetComponentInChildren<CameraManager>();

        movementManager.StartingState = new FirstPersonState();
        cameraManager.StartingState = new CameraStateFirstPerson();
    }
}
```

```PlayerAddons\rigidbody\FirstPerson\FPState.cs
using System;
using System.Collections;
using UnityEngine;

[System.Serializable]
public class FpState : MovementState
{
    [Header("Currently Using: FPS MovementState")]
    public const string CurrentStateName = "FPState";
    private float _playerHeight = 2f;

    [Header("Assignables")]
    [SerializeField] private Transform orientation;
    [SerializeField] private Animator character;
    [SerializeField] private Transform playerTransform;
    [SerializeField] private Rigidbody rb;
    private AnimationsManager _animationsManager;

    [Header("InputValues")]
    public float _horizontalMovement;
    public float _verticalMovement;

    private bool _holdingJump = false;
    private bool _holdingSprint = false;

    [Header("Movement")]
    [SerializeField] private float moveSpeed = 6f;
    [SerializeField] private float airMultiplier = 0.4f;
    private float _movementMultiplier = 10f;
    public Vector3 MoveDirection;
    private Vector3 _normalizedMovementDirection;
    private Vector3 _correctedWallMovement = Vector3.zero;

    private Vector3 _slopeMoveDirection;
    private RaycastHit _slopeHit;

    [Header("Sprinting")]
    [SerializeField] private float walkSpeed = 6f;
    [SerializeField] private float sprintSpeed = 10f;
    [SerializeField] private float acceleration = 50f;

    [Header("Jumping")]
    public float JumpForce = 14f;
    public bool IsJumping = false;

    [Header("Drag")]
    [SerializeField] private float groundDrag = 6f;
    [SerializeField] private float airDrag = 2f;

    [Header("Ground Detection")]
    [SerializeField] private Transform groundCheck;
    [SerializeField] private float groundDistance = 0.1f;
    [SerializeField] private bool isGrounded;
    [SerializeField] private LayerMask groundLayer;
    
    [Header("Climb Steps")]
    [SerializeField] private float stepHeight = 0.5f;            // max climbable step
    [SerializeField] private float stepCheckDistance = 0.5f;    // how far in front to step-check
    private bool _isStepping = false;
    private Vector3 _stepStartPos;
    private Vector3 _stepTargetPos;
    private float _stepProgress = 0f;
    private float detectedStepHeight;
    private const float StepDuration = 0.1f; // Smooth climb time
    private const float StepThreshold = 0.1f;

    // -------------------------------
    // State Machine
    // -------------------------------


    public override MovementComponentType ComponentType => MovementComponentType.Rigidbody;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        // Player Family
        Controller = manager;
        Director = director;
        _animationsManager = manager.GetComponent<AnimationsManager>();

        // Assignables
        playerTransform = manager.transform.transform;
        orientation = manager.transform.GetComponentInChildren<Animator>().gameObject.transform;
        
        // Load movement data
        LocalData = Resources.Load<PlayerStateData>("playerStates/normalPlayer");
        groundLayer = LayerMask.NameToLayer("Ground");

        // Input Events`
        Director.OnPlayerMoved += _director_OnPlayerMoved;
        Director.OnPlayerMovedFinished += _director_OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted += _director_OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped += _director_OnPlayerJumpStopped;
        Director.OnPlayerRunStarted += _director_OnPlayerRunStarted;
        Director.OnPlayerRunStopped += _director_OnPlayerRunStopped;

        Director.OnEnablePlayerMovement += _director_OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement += _director_OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled += _director_OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled += _director_OnPlayerRunDisabled;
    }

    public override void EnterState()
    {
        character = Controller.transform.GetComponentInChildren<Animator>();

        // run enter state animations here

        groundCheck = character.gameObject.GetComponentInChildren<PlayerGround>().transform;
        rb = Controller.gameObject.GetComponent<Rigidbody>();

        rb.freezeRotation = true;

        Debug.Log("Starting FPS State!");
    }


    public override void UpdateState()
    {
        UpdateMovementValues();
        ControlDrag();
        ControlSpeed();
        ControlJump();
    }

    public override void FixedUpdate()
    {
        if (!CanMove) return;
        
        HandleStepClimbingBeforeMovement();
        MovePlayer();
    }

    public override void CleanState()
    {
        _animationsManager.SetFloat("MoveX", 0f);
        _animationsManager.SetFloat("MoveY", 0f);
        _animationsManager.SetBool("Moving", false);

        Vector3 movementVelocity = new(0f, rb.linearVelocity.y, 0f);
        rb.linearVelocity = movementVelocity;

        // unsubscribe from Input Events
        Director.OnPlayerMoved -= _director_OnPlayerMoved;
        Director.OnPlayerMovedFinished -= _director_OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted -= _director_OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped -= _director_OnPlayerJumpStopped;
        Director.OnPlayerRunStarted -= _director_OnPlayerRunStarted;
        Director.OnPlayerRunStopped -= _director_OnPlayerRunStopped;

        Director.OnEnablePlayerMovement -= _director_OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement -= _director_OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled -= _director_OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled -= _director_OnPlayerRunDisabled;
    }


    // -------------------------------
    // Movement Functions
    // -------------------------------

    private bool OnSlope()
    {
        if (Physics.Raycast(playerTransform.position, Vector3.down, out _slopeHit, _playerHeight / 2 + 0.5f))
        {
            if (_slopeHit.normal != Vector3.up)
            {
                return true;
            }
        }
        return false;
    }

    private void ControlJump()
    {
        if (!_holdingJump || !isGrounded || IsJumping) return;
        
        IsJumping = true;
        Controller.StartCoroutine(ResetJump());
        rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0, rb.linearVelocity.z);
        rb.AddForce(playerTransform.up * JumpForce, ForceMode.Impulse);
    }

    private void ControlSpeed()
    {
        if (CanRun && _holdingSprint && isGrounded)
        {
            moveSpeed = Mathf.Lerp(moveSpeed, sprintSpeed, acceleration * Time.deltaTime);
        }
        else
        {
            moveSpeed = Mathf.Lerp(moveSpeed, walkSpeed, acceleration * Time.deltaTime);
        }
    }

    private void UpdateMovementValues()
    {
        MoveDirection = orientation.forward * _verticalMovement + orientation.right * _horizontalMovement;
        _normalizedMovementDirection = MoveDirection.normalized;
        _slopeMoveDirection = Vector3.ProjectOnPlane(MoveDirection, _slopeHit.normal);
        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, ~groundLayer);
    }
    
    private void ControlDrag()
    {
        if (isGrounded)
        {
            rb.linearDamping = groundDrag;
        }
        else
        {
            rb.linearDamping = airDrag;
        }
    }

    private void MovePlayer()
    {
        MoveDirection = _correctedWallMovement != Vector3.zero ? _correctedWallMovement : MoveDirection;
        
        switch (isGrounded)
        {
            case true when OnSlope():
                rb.AddForce(_slopeMoveDirection.normalized * (moveSpeed * _movementMultiplier), ForceMode.Acceleration);
                break;
            case true when !OnSlope():
                rb.AddForce(MoveDirection.normalized * (moveSpeed * _movementMultiplier), ForceMode.Acceleration);
                break;
            case false:
            {
                Vector3 downfallForce = MoveDirection.normalized * (moveSpeed * _movementMultiplier * airMultiplier);
                rb.AddForce(downfallForce, ForceMode.Acceleration);
                break;
            }
        }
        
        _correctedWallMovement = Vector3.zero;
    }

    /// <summary>
    /// detect and climb steps.
    /// must be called before movement, for this moves on the y-axis before bumping into the step.
    /// </summary>
    private void HandleStepClimbingBeforeMovement()
    {
        DetectStep();
        
        if (_isStepping)
        {
            StepForward();
        }
    }

    private void DetectStep()
    {
        // check if we got a step forward:
        Vector3 playerFootOrigin = playerTransform.position + Vector3.up * StepThreshold;
        
        // raycast low step:
        if (!Physics.Raycast(playerFootOrigin, _normalizedMovementDirection, out RaycastHit hit, stepCheckDistance,
                ~groundLayer)) return;
        
        // detect if step is climbable:
        Vector3 maxstepCheckOrigin = hit.point + Vector3.up * stepHeight;
        if (!Physics.Raycast(maxstepCheckOrigin, Vector3.down, out RaycastHit stepHit, stepHeight,
                ~groundLayer)) return;
        
        // check if step is worthy of snapping onto:
        detectedStepHeight = stepHit.point.y - playerTransform.position.y;
        if (!(detectedStepHeight > StepThreshold) || !(detectedStepHeight <= stepHeight)) return;
        
        // prepare jump onto step:
        _stepStartPos = rb.position;
        Vector3 forwardOffset = Vector3.ProjectOnPlane(_normalizedMovementDirection, Vector3.up) * 0.1f;
        _stepTargetPos = stepHit.point + forwardOffset;
        _stepProgress = 0f;
        _isStepping = true;
    }

    private void StepForward()
    {
        // lerp on the y-axis onto the step:
        _stepProgress += Time.fixedDeltaTime / StepDuration;
        // Scale factor: 0 for 0.5 height (full lerp), 1 for 0 height (instant jump)
        float stepFactor = Mathf.Clamp01(1f - (detectedStepHeight / stepHeight));
        // Make a non-linear influence (optional, use Mathf.Pow to exaggerate effect)
        float sharpness = Mathf.Lerp(_stepProgress, 1f, stepFactor);
        // final lerp
        float newYPosition = Mathf.Lerp(_stepStartPos.y, _stepTargetPos.y, sharpness);
        
        // move the player vertically to the step
        Vector3 nextPosition = rb.position;
        nextPosition.y = newYPosition;
        rb.MovePosition(nextPosition);

        // I finished stepping up, I'm a big man now.
        if (_stepProgress >= 1f)
            _isStepping = false;
    }
    
    // /// <summary>
    // /// events for detecting collision:
    // /// - wall check (walking into walls)
    // /// </summary>
    // /// <param name="collision"></param>
    // public override void OnCollisionStay(Collision collision)
    // {
    //     // foreach wall I collide with
    //     foreach (ContactPoint contact in collision.contacts)
    //     {
    //         // get the normal, and the projection to it
    //         Vector3 wallNormal = contact.normal;
    //         Vector3 projectedMoveDirection = Vector3.ProjectOnPlane(_normalizedMovementDirection, wallNormal);
    //
    //         // add movement to that projection
    //         _correctedWallMovement += projectedMoveDirection.normalized;
    //     }
    // }

    private IEnumerator ResetJump()
    {
        yield return new WaitForSeconds(0.5f);
        IsJumping = false;
    }

    // -------------------------------
    // Input Events
    // -------------------------------
    private void _director_OnPlayerMoved(Vector2 movementValue)
    {
        _horizontalMovement = movementValue.x;
        _verticalMovement = movementValue.y;

        MoveDirection = orientation.forward * _verticalMovement + orientation.right * _horizontalMovement;
    }

    private void _director_OnPlayerMovedFinished()
    {
        _horizontalMovement = 0f;
        _verticalMovement = 0f;

        MoveDirection = orientation.forward * _verticalMovement + orientation.right * _horizontalMovement;
        
        _animationsManager.SetBool("Moving", false);
    }

    private void _director_OnPlayerJumpStarted()
    {
        _holdingJump = true;
    }

    private void _director_OnPlayerJumpStopped()
    {
        _holdingJump = false;
    }

    private void _director_OnPlayerRunStarted()
    {
        _holdingSprint = true;
        _animationsManager.SetBool("Moving", true);
    }

    private void _director_OnPlayerRunStopped()
    {
        _holdingSprint = false;
        
        _animationsManager.SetBool("Moving", false);
    }

    private void _director_OnEnablePlayerMovement()
    {
        CanMove = true;
    }

    private void _director_OnDisablePlayerMovement()
    {
        CanMove = false;
        _animationsManager.SetBool("Moving", false);
    }

    private void _director_OnPlayerRunEnabled()
    {
        CanRun = true;
    }

    private void _director_OnPlayerRunDisabled()
    {
        CanRun = false;
    }
}
```

```PlayerAddons\rigidbody\FirstPerson\FPStoryExample.cs
using UnityEngine;

public class FPStoryExample : MonoBehaviour
{
    [SerializeField] private GameObject CinemachineCamera;
    private void Start()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
            return;

        MovementManager movementManager = player.GetComponent<MovementManager>();
        CameraManager cameraManager = player.GetComponent<CameraManager>();

        movementManager.ChangeState(new FpState());
        cameraManager.ChargeState(new FP_CameraState(), CinemachineCamera);
    }
}
```

```PlayerAddons\rigidbody\FirstPerson\SelfForDisable.cs
using UnityEngine;

public class SelfForDisable : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
```

```PlayerAddons\rigidbody\Hoverboard\HoverboardCameraState.cs
using UnityEngine;

public class HoverboardCameraState : CameraState
{
    [Header("Assignables")]
    [SerializeField] HoverboardState hoverboardState;

    [SerializeField] private float sensX = 150f;
    [SerializeField] private float sensY = 150f;

    [SerializeField] Camera cam = null;
    [SerializeField] Transform orientation = null;
    [SerializeField] Transform playerTransform;
    [SerializeField] GameObject _virtualCam;

    [Header("Input")]
    float mouseX;
    float mouseY;

    float multiplier = 0.01f;

    float xRotation;
    float yRotation;


    // -------------------------------
    // State Machine
    // -------------------------------
    public override void LoadState(CameraManager manager, InputDirector director)
    {
        InputDirector = director;
        Manager = manager;

        playerTransform = manager.transform.parent.transform;

        // subscribe to input events
        InputDirector.OnCameraMoved += _inputDirector_OnCameraMoved;
    }

    public override void EnterState()
    {
        orientation = Manager.transform.parent.GetComponentInChildren<Animator>().gameObject.transform;
        _virtualCam = Manager.CurrentCinemachineComponent.gameObject;
        cam = Camera.main;

        MovementManager movementManager = Manager.transform.parent.GetComponentInChildren<MovementManager>();
        hoverboardState = (HoverboardState)movementManager.CurrentState;

        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    public override void UpdateState()
    {
        CameraUpdate();
    }
    

    public override void FixedUpdate()
    {
        
    }


    public override void ClearState()
    {
        
    }

    public override void OnDestroy()
    {
        InputDirector.OnCameraMoved -= _inputDirector_OnCameraMoved;
    }

    // -------------------------------
    // State Functions
    // -------------------------------
    private void CameraUpdate()
    {
        mouseX = Input.GetAxisRaw("Mouse X");
        mouseY = Input.GetAxisRaw("Mouse Y");

        yRotation += mouseX * sensX * multiplier;
        xRotation -= mouseY * sensY * multiplier;

        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        _virtualCam.transform.rotation = Quaternion.Euler(xRotation, yRotation, 0f);
        orientation.transform.rotation = Quaternion.Euler(0, yRotation, 0);
    }

    // -------------------------------
    // Input Events
    // -------------------------------
    private void _inputDirector_OnCameraMoved(Vector2 camValue)
    {
        mouseX = camValue.x;
        mouseY = camValue.y;
    }
}
```

```PlayerAddons\rigidbody\Hoverboard\HoverboardState.cs
using System;
using System.Collections;
using UnityEngine;

[System.Serializable]
public class HoverboardState : MovementState
{
    float playerHeight = 2f;

    [Header("Assignables")]
    [SerializeField] Transform orientation;
    [SerializeField] Animator character;
    [SerializeField] Transform playerTransform;
    [SerializeField] Rigidbody rb;

    [Header("InputValues")]
    float horizontalMovement;
    float verticalMovement;

    bool holdingJump = false;
    bool holdingSprint = false;

    [Header("Movement")]
    [SerializeField] float moveSpeed = 6f;
    [SerializeField] float airMultiplier = 0.4f;
    float movementMultiplier = 10f;
    bool canMove = true;

    [Header("Sprinting")]
    [SerializeField] float walkSpeed = 6f;
    [SerializeField] float sprintSpeed = 10f;
    [SerializeField] float acceleration = 50f;

    [Header("Jumping")]
    public float jumpForce = 14f;
    public bool isJumping = false;
    [SerializeField] private float wallRunGravity = 1f;
    [SerializeField] private float wallRunJumpForce = 6f;

    [Header("Drag")]
    [SerializeField] float groundDrag = 6f;
    [SerializeField] float airDrag = 2f;

    [Header("Ground Detection")]
    [SerializeField] Transform groundCheck;
    [SerializeField] float groundDistance = 0.1f;
    public bool isGrounded { get; private set; }

    public Vector3 moveDirection;
    Vector3 slopeMoveDirection;

    public bool groundedCheck;
    RaycastHit slopeHit;

    // -------------------------------
    // State Machine
    // -------------------------------


    public override MovementComponentType ComponentType => MovementComponentType.Rigidbody;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        // Player Family
        Controller = manager;
        Director = director;

        // Assignables
        playerTransform = manager.transform.parent.transform;
        orientation = manager.transform.parent.GetComponentInChildren<Animator>().gameObject.transform;

        // Load movement data
        LocalData = Resources.Load<PlayerStateData>("playerStates/normalPlayer");

        // Input Events
        Director.OnPlayerMoved += _director_OnPlayerMoved;
        Director.OnPlayerMovedFinished += _director_OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted += _director_OnPlayerJumpStarted;
        Director.OnPlayerJumpStopped += _director_OnPlayerJumpStopped;
        Director.OnPlayerRunStarted += _director_OnPlayerRunStarted;
        Director.OnPlayerRunStopped += _director_OnPlayerRunStopped;

        Director.OnEnablePlayerMovement += _director_OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement += _director_OnDisablePlayerMovement;
        Director.OnCameraMoved += _director_OnCameraMoved;
    }

    private void _director_OnCameraMoved(Vector2 obj)
    {
        Debug.Log("Not Reloading Anything Anymore!");
    }

    public override void EnterState()
    {
        character = Controller.transform.parent.GetComponentInChildren<Animator>();

        // run enter state animations here

        groundCheck = character.gameObject.GetComponentInChildren<PlayerGround>().transform;
        rb = Controller.gameObject.GetComponent<Rigidbody>();

        rb.freezeRotation = true;

        Debug.Log("Starting HoverBoard State!");
    }


    public override void UpdateState()
    {
        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, ~3);

        groundedCheck = isGrounded;

        ControlDrag();
        ControlSpeed();

        if (holdingJump && isGrounded && !isJumping)
        {
            isJumping = true;
            Controller.StartCoroutine(ResetJump());
            jump();
        }

        slopeMoveDirection = Vector3.ProjectOnPlane(moveDirection, slopeHit.normal);
    }

    public override void FixedUpdate()
    {
        if (canMove)
            MovePlayer();
    }

    public override void CleanState()
    {
        Director.GetComponent<AnimationsManager>().SetFloat("MoveX", 0f);
        Director.GetComponent<AnimationsManager>().SetFloat("MoveY", 0f);

        Vector3 movementVelocity = new(0f, rb.linearVelocity.y, 0f);
        rb.linearVelocity = movementVelocity;
    }


    // -------------------------------
    // Movement Functions
    // -------------------------------

    private bool OnSlope()
    {
        if (Physics.Raycast(playerTransform.position, Vector3.down, out slopeHit, playerHeight / 2 + 0.5f))
        {
            if (slopeHit.normal != Vector3.up)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        return false;
    }

    void jump()
    {
        if (isGrounded)
        {
            rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0, rb.linearVelocity.z);
            rb.AddForce(playerTransform.up * jumpForce, ForceMode.Impulse);
        }
    }

    void ControlSpeed()
    {
        if (holdingSprint && isGrounded)
        {
            moveSpeed = Mathf.Lerp(moveSpeed, sprintSpeed, acceleration * Time.deltaTime);
        }
        else
        {
            moveSpeed = Mathf.Lerp(moveSpeed, walkSpeed, acceleration * Time.deltaTime);
        }
    }

    void ControlDrag()
    {
        if (isGrounded)
        {
            rb.linearDamping = groundDrag;
        }
        else
        {
            rb.linearDamping = airDrag;
        }
    }

    void MovePlayer()
    {   
        moveDirection = orientation.forward * verticalMovement + orientation.right * horizontalMovement;

        if (isGrounded && !OnSlope())
        {
            rb.AddForce(moveDirection.normalized * moveSpeed * movementMultiplier, ForceMode.Acceleration);
        }
        else if (isGrounded && OnSlope())
        {
            rb.AddForce(slopeMoveDirection.normalized * moveSpeed * movementMultiplier, ForceMode.Acceleration);
        }
        else if (!isGrounded)
        {
            Vector3 downfallForce = moveDirection.normalized * moveSpeed * movementMultiplier * airMultiplier;
            rb.AddForce(downfallForce, ForceMode.Acceleration);
        }
    }

    public void StartWallRun(bool wallLeft, bool wallRight, RaycastHit leftWallHit, RaycastHit rightWallHit)
    {
        rb.useGravity = false;

        rb.AddForce(Vector3.down * wallRunGravity, ForceMode.Force);

        if (holdingJump)
        {
            if (wallLeft)
            {
                Vector3 wallRunJumpDirection = playerTransform.up + leftWallHit.normal;
                rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0, rb.linearVelocity.z);
                rb.AddForce(wallRunJumpDirection * wallRunJumpForce * 100, ForceMode.Force);
            }
            else if (wallRight)
            {
                Vector3 wallRunJumpDirection = playerTransform.up + rightWallHit.normal;
                rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0, rb.linearVelocity.z);
                rb.AddForce(wallRunJumpDirection * wallRunJumpForce * 100, ForceMode.Force);
            }
        }
    }

    public void StopWallRun()
    {
        rb.useGravity = true;
    }

    private IEnumerator ResetJump()
    {
        yield return new WaitForSeconds(0.5f);
        isJumping = false;
    }

    // -------------------------------
    // Input Events
    // -------------------------------
    private void _director_OnPlayerMoved(Vector2 movementValue)
    {
        horizontalMovement = movementValue.x;
        verticalMovement = movementValue.y;

        moveDirection = orientation.forward * verticalMovement + orientation.right * horizontalMovement;
    }

    private void _director_OnPlayerMovedFinished()
    {
        horizontalMovement = 0f;
        verticalMovement = 0f;

        moveDirection = orientation.forward * verticalMovement + orientation.right * horizontalMovement;
    }

    private void _director_OnPlayerJumpStarted()
    {
        holdingJump = true;
    }

    private void _director_OnPlayerJumpStopped()
    {
        holdingJump = false;
    }

    private void _director_OnPlayerRunStarted()
    {
        holdingSprint = true;
    }

    private void _director_OnPlayerRunStopped()
    {
        holdingSprint = false;
    }

    private void _director_OnEnablePlayerMovement()
    {
        canMove = true;
    }

    private void _director_OnDisablePlayerMovement()
    {
        canMove = false;
    }
}
```

```PlayerAddons\rigidbody\Hoverboard\HoverboardStoryExample.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HoverboardStoryExample : MonoBehaviour
{
    private void Awake()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
            return;

        MovementManager movementManager = player.GetComponentInChildren<MovementManager>();
        CameraManager cameraManager = player.GetComponentInChildren<CameraManager>();

        movementManager.StartingState = new HoverboardState();
        cameraManager.StartingState = new HoverboardCameraState();
    }
}
```

```PlayerAddons\rigidbody\StoryControlled\StoryControlledPlayer.cs
using System;
using UnityEngine;

[System.Serializable]
public class StoryControlledPlayer : MovementState
{

    public override MovementComponentType ComponentType => MovementComponentType.None;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        throw new System.NotImplementedException();
    }

    public override void EnterState()
    {
        throw new System.NotImplementedException();
    }

    public override void UpdateState()
    {
        throw new System.NotImplementedException();
    }

    public override void FixedUpdate()
    {
        throw new System.NotImplementedException();
    }

    public override void CleanState()
    {
        throw new System.NotImplementedException();
    }
}
```

```PlayerAddons\rigidbody\ThirdPerson\ThirdPersonState.cs
using System;
using UnityEngine;

[System.Serializable]
public class ThirdPersonState : MovementState
{
    // rigidbody based
    private Rigidbody _rb;
    private Transform _camTransform;
    private Transform _playerTransform;

    // using a rotator
    private IPlayerRotator _playerRotator;

    // movement:
    private Vector2 _inputValue;
    Vector3 _moveDirection;

    public float MovementSpeed = 0f;

    // values (static)
    public float WalkingSpeed = 0f;
    public float RunningSpeed = 0f;
    public float JumpHeight = 0f;



    public override MovementComponentType ComponentType => MovementComponentType.Rigidbody;

    public override void LoadState(MovementManager manager, InputDirector director)
    {
        Controller = manager;

        _camTransform = Camera.main.transform;
        _playerTransform = GameObject.FindGameObjectWithTag("Player").transform;

        // load movement data
        LocalData = Resources.Load<PlayerStateData>("playerStates/normalPlayer");
        WalkingSpeed = LocalData.WalkingSpeed;
        RunningSpeed = LocalData.RunningSpeed;
        JumpHeight = LocalData.JumpHeight;

        _playerRotator = new PlayerRotator(_camTransform, LocalData.TimeToReachTargetRotation);
        MovementSpeed = WalkingSpeed;
        
        // Input Events
        Director = InputDirector.Instance;
        
        Director.OnPlayerMoved += _director_OnPlayerMoved;
        Director.OnPlayerMovedFinished += _director_OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted += Jump;
        Director.OnPlayerRunStarted += RunStart;
        Director.OnPlayerRunStopped += RunStop;
        
        Director.OnEnablePlayerMovement += _director_OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement += _director_OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled += _director_OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled += _director_OnPlayerRunDisabled;
    }

    public override void EnterState()
    {
        // start enter state animation HERE
        
        _rb = Controller.gameObject.GetComponent<Rigidbody>();
        
        Debug.Log("Entering Third Person state!");
    }

    public override void FixedUpdate()
    {
        // Calculate movement
        _moveDirection = new Vector3(_camTransform.forward.x, 0f, _camTransform.forward.z) * _inputValue.y;
        _moveDirection += _camTransform.right * _inputValue.x;
        _moveDirection.Normalize();
        _moveDirection *= MovementSpeed;
        _moveDirection.y = _rb.linearVelocity.y;

        // Apply animations
        Director.GetComponent<AnimationsManager>().SetFloat("MoveY", _inputValue.y != 0 || _inputValue.x != 0 ? 1: 0);

        // Move the player.
        Vector3 movementVelocity = _moveDirection;
        _rb.linearVelocity = movementVelocity;
    }

    public override void UpdateState()
    {
        _playerRotator.RotatePlayer(_inputValue);
        
        // Debug.Log("is grounded? " + isGrounded() + (isGrounded() ? playerTransform.position.y : ""));
        //Debug.DrawLine(playerTransform.position, playerTransform.position - new Vector3(0f, 0.2f, 0f));
    }

    private void MovePlayer(Vector3 dir)
    {
        Vector3 targetPositon = _rb.position + dir * MovementSpeed * Time.fixedDeltaTime;
        _rb.MovePosition(targetPositon);
    }

    bool IsGrounded()
    {
        float sphereRadius = 0.1f; // Adjust the radius as needed
        Vector3 rayStart = _playerTransform.position - new Vector3(0f, 0.3f, 0f);

        Collider[] hitColliders = new Collider[1];
        int numColliders = Physics.OverlapSphereNonAlloc(rayStart, sphereRadius, hitColliders, ~3);
        return numColliders > 0;
    }





    public void Jump()
    {
        if (!IsGrounded())
            return;
        Debug.Log("Aight lets jump!");
        _rb.linearVelocity = new Vector3(_rb.linearVelocity.x, JumpHeight, _rb.linearVelocity.z);
    }

    public void RunStart()
    {
        MovementSpeed = RunningSpeed;
    }
    public void RunStop()
    {
        MovementSpeed = WalkingSpeed;
    }
    public override void CleanState()
    {
        Director.GetComponent<AnimationsManager>().SetFloat("MoveX", 0f);
        Director.GetComponent<AnimationsManager>().SetFloat("MoveY", 0f);

        Vector3 movementVelocity = new(0f, _rb.linearVelocity.y, 0f);
        _moveDirection.x = 0;
        _moveDirection.z = 0;
        _rb.linearVelocity = movementVelocity;
        
        // unsubscribe from Input Events
        Director = InputDirector.Instance;
        
        Director.OnPlayerMoved -= _director_OnPlayerMoved;
        Director.OnPlayerMovedFinished -= _director_OnPlayerMovedFinished;
        Director.OnPlayerJumpStarted -= Jump;
        Director.OnPlayerRunStarted -= RunStart;
        Director.OnPlayerRunStopped -= RunStop;
        
        Director.OnEnablePlayerMovement -= _director_OnEnablePlayerMovement;
        Director.OnDisablePlayerMovement -= _director_OnDisablePlayerMovement;
        Director.OnPlayerRunEnabled -= _director_OnPlayerRunEnabled;
        Director.OnPlayerRunDisabled -= _director_OnPlayerRunDisabled;
    }
    
    // -------------------------------
    // Input Events
    // -------------------------------
    private void _director_OnPlayerMoved(Vector2 movementValue)
    {
        _inputValue.x = movementValue.x;
        _inputValue.y = movementValue.y;
    }

    private void _director_OnPlayerMovedFinished()
    {
        _inputValue.x = 0f;
        _inputValue.y = 0f;
    }

    private void _director_OnEnablePlayerMovement()
    {
        CanMove = true;
    }

    private void _director_OnDisablePlayerMovement()
    {
        CanMove = false;
    }

    private void _director_OnPlayerRunEnabled()
    {
        CanRun = true;
    }

    private void _director_OnPlayerRunDisabled()
    {
        CanRun = false;
    }
}
```

```PlayerSystems\Combat\Example\PuppetEnemy.cs
using UnityEngine;
using System.Collections;

/// <summary>
/// A simple, stationary enemy that takes damage and dies when health is depleted.
/// Implements IDamageable for compatibility with the gun system.
/// </summary>
[RequireComponent(typeof(Rigidbody))]
public class PuppetEnemy : MonoBehaviour, IDamageable
{
    [Header("Puppet Enemy Settings")]
    [SerializeField] private float maxHealth = 100f;
    private Rigidbody rb;

    public float knockbackForce = 10f;
    public float stillThreshold = 0.2f;
    private float currentHealth;

    private void Start()
    {
        rb = GetComponent<Rigidbody>();

        // Initialize health
        currentHealth = maxHealth;
    }

    /// <summary>
    /// Applies damage to the enemy. If health is zero or below, the enemy dies.
    /// </summary>
    /// <param name="damage">Amount of damage to apply.</param>
    public void TakeDamage(float damage)
    {
        currentHealth -= damage;
    }

    /// <summary>
    /// Handles the enemy's death.
    /// Rewards the player and destroys this GameObject.
    /// </summary>
    private void Die()
    {
        // Destroy the enemy GameObject
        Destroy(gameObject);
    }

    // <summary>
    // take knockback
    // <summary>
    private IEnumerator ApplyKnockback(Vector3 knockback)
    {
        // disable rigidbody while knockback
        rb.isKinematic = false;
        rb.useGravity = true;

        // Add knockback force
        rb.AddForce(knockback * knockbackForce, ForceMode.Impulse);

        // Wait until velocity is minimal
        yield return new WaitForFixedUpdate();
        yield return new WaitUntil(() => rb.linearVelocity.magnitude < stillThreshold);

        // Re-enable rigidbody
        rb.isKinematic = true;
        rb.useGravity = false;
    }
}
```

```PlayerSystems\Combat\Guns\GunBaseExtension.cs
using UnityEngine;

public abstract class GunBaseExtension : MonoBehaviour
{
    [Header("Gun Stats")]
    [SerializeField] protected float damage = 10f;
    [SerializeField] protected float maxCooldown = 0.5f;

    protected float cooldownTimer;
    protected Transform cam;
    protected InputDirector _director;

    protected virtual void Start()
    {
        // Find main camera by tag
        if (Camera.main != null) cam = Camera.main.transform;

        _director = GetComponent<InputDirector>();
        if (_director != null)
        {
            _director.OnFirePressed += OnFirePressed;
        }

        // Reset cooldown
        cooldownTimer = 0f;
    }

    protected virtual void Update()
    {
        // Decrement cooldown each frame
        if (cooldownTimer > 0)
        {
            cooldownTimer -= Time.deltaTime;
        }
    }

    private void OnFirePressed()
    {
        // If there's still cooldown, don't shoot
        if (cooldownTimer > 0) return;

        PerformShoot();

        // Reset cooldown
        cooldownTimer = maxCooldown;
    }

    /// <summary>
    /// Child classes must implement how to actually shoot (projectile vs. raycast).
    /// </summary>
    protected abstract void PerformShoot();
}
```

```PlayerSystems\Combat\Guns\ProjectileGun.cs
using UnityEngine;

public class ProjectileGun : GunBaseExtension
{
    [Header("Projectile Gun Settings")]
    // [SerializeField] private HS_ProjectileMover bulletPrefab;
    [SerializeField] private float bulletSpeed = 30f;

    [SerializeField] private Transform bulletSpawnPosition;

    protected override void PerformShoot()
    {
        // Early-exit checks
        // if (bulletPrefab == null || cam == null || bulletSpawnPosition == null)
        // {
        //     Debug.LogWarning("ProjectileGun: Missing bullet prefab, camera, or bulletSpawnPosition reference.");
        //     return;
        // }

        // 1. Raycast from the camera to see where we want the bullet to face
        Ray ray = new(cam.position, cam.forward);
        RaycastHit hit;

        // We'll default the direction to cam.forward if the ray hits nothing
        Vector3 targetDirection = cam.forward;

        if (Physics.Raycast(ray, out hit, 1000f))
        {
            // If we hit something, compute the direction from the spawn position to the hit point
            targetDirection = (hit.point - bulletSpawnPosition.position).normalized;
        }

        // 2. Determine the rotation so the bullet faces the target direction
        Quaternion spawnRot = Quaternion.LookRotation(targetDirection);

        // // 3. Instantiate the bullet at the bulletSpawnPosition with the calculated rotation
        // HS_ProjectileMover bulletInstance = Instantiate(
        //     bulletPrefab,
        //     bulletSpawnPosition.position,
        //     spawnRot
        // );

        // // 4. Give the bullet a velocity in the targetDirection
        // Rigidbody rb = bulletInstance.GetComponent<Rigidbody>();
        // if (rb != null)
        // {
        //     rb.linearVelocity = targetDirection * bulletSpeed;
        // }
        //
        // // 5. Subscribe to bullet collision event
        // bulletInstance.OnProjectileHit += OnBulletHit;
    }

    // private void OnBulletHit(Collision collision, HS_ProjectileMover projectile)
    // {
    //     // Unsubscribe to avoid memory leaks
    //     projectile.OnProjectileHit -= OnBulletHit;
    //
    //     // Check if the object we hit is IDamageable, then apply damage
    //     IDamageable damageable = collision.gameObject.GetComponent<IDamageable>();
    //     if (damageable != null)
    //     {
    //         damageable.TakeDamage(damage);
    //     }
    // }
}
```

```PlayerSystems\Combat\Guns\RaycastGun.cs
using UnityEngine;

public class RaycastGun : GunBaseExtension
{
    [Header("Raycast Gun Settings")]
    [SerializeField] private float maxRange = 100f;
    [SerializeField] private LayerMask hitLayers;
    private AnimationsManager _animationsManager;

    protected override void Start()
    {
        base.Start();
        _animationsManager = GetComponent<AnimationsManager>();
    }   

    protected override void PerformShoot()
    {
        if (cam == null)
        {
            Debug.LogWarning("RaycastGun: Missing camera reference.");
            return;
        }

        if (_animationsManager != null)
        {
            _animationsManager.Play("Shoot");
        }

        Ray ray = new(cam.position, cam.forward);
        
        if (Physics.Raycast(ray, out var hit, maxRange, hitLayers))
        {
            // We hit something: check for damageable
            IDamageable damageable = hit.collider.GetComponent<IDamageable>();
            if (damageable != null)
            {
                damageable.TakeDamage(damage);
            }
        }
    }
}
```

```PlayerSystems\Combat\Pillars\CrosshairHighlighter.cs
using UnityEngine;
using UnityEngine.UI;

public class CrosshairHighlighter : MonoBehaviour
{
    [SerializeField] private Image crosshairImage;
    [SerializeField] private Color defaultColor = Color.black;
    [SerializeField] private Color highlightColor = Color.red;
    [SerializeField] private float maxCheckRange = 100f;
    [SerializeField] private LayerMask aimLayers;
    [SerializeField] private bool debug;

    private Transform _cam;

    private void Start()
    {
        if (Camera.main != null)
            _cam = Camera.main.transform;

        if (crosshairImage != null)
        {
            crosshairImage.color = defaultColor;
        }
    }

    private void Update()
    {
        if (_cam is null || crosshairImage is null) return;
        
        Ray ray = new(_cam.position, _cam.forward);
        
        if (debug)
            DebugCrosshair(ray);

        RaycastHit hit;
        if (Physics.Raycast(ray, out hit, maxCheckRange, aimLayers))
        {
            // If what we hit can be damaged, highlight
            if (hit.collider.GetComponent<IDamageable>() != null)
            {
                crosshairImage.color = highlightColor;
                return;
            }
        }
        
        // If we got here, we didn't hit a damageable
        crosshairImage.color = defaultColor;
    }

    private void DebugCrosshair(Ray ray)
    {
        Debug.DrawRay(_cam.position, _cam.forward * 10, Color.cadetBlue);
        if (Physics.Raycast(ray, out RaycastHit hit, maxCheckRange))
            Debug.Log(hit.collider.name);
    }
}
```

```PlayerSystems\Combat\Pillars\Enemy.cs
using System.Collections;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.UI;

[RequireComponent(typeof(Rigidbody))]
public class Enemy : MonoBehaviour, IDamageable
{
    [SerializeField] private float maxHealth;
    [SerializeField] private float knockbackForce = 10f;
    [SerializeField] private float stillThreshold = 0.2f;
    [SerializeField] private float worth = 30f;

    private float health;
    private Rigidbody rb;
    private NavMeshAgent navMesh;
    private IGoapAgent goapAgent;
    private Slider slider;

    private void Start()
    {
        rb = GetComponent<Rigidbody>();
        navMesh = GetComponent<NavMeshAgent>();
        goapAgent = GetComponent<IGoapAgent>(); // could be null if not present
        slider = GetComponentInChildren<Slider>();

        slider.maxValue = maxHealth;
        slider.value = maxHealth;
        health = maxHealth;
    }

    private void Update()
    {
        slider.value = health;
    }

    /// <summary>
    /// Implementation of IDamageable interface.
    /// Takes in the damage amount and reduces health.
    /// </summary>
    public void TakeDamage(float damage)
    {
        health -= damage;
        if (health <= 0f)
        {
            KillSelf();
        }
    }

    /// <summary>
    /// Called by other things (like the player's fist).
    /// Applies a knockback force to the enemy.
    /// </summary>
    public void FistHit(Vector3 hitPosition)
    {
        Vector3 pushDirection = (transform.position - hitPosition).normalized;
        StartCoroutine(ApplyKnockback(pushDirection));
    }

    private IEnumerator ApplyKnockback(Vector3 knockback)
    {
        // If there's a GOAP agent, disable it while knocked back
        if (goapAgent != null) goapAgent.enabled = false;
        navMesh.enabled = false;
        rb.isKinematic = false;
        rb.useGravity = true;

        // Add knockback force
        rb.AddForce(knockback * knockbackForce, ForceMode.Impulse);

        // Wait until velocity is minimal
        yield return new WaitForFixedUpdate();
        yield return new WaitUntil(() => rb.linearVelocity.magnitude < stillThreshold);

        // Re-enable pathfinding
        navMesh.Warp(transform.position);
        navMesh.enabled = true;
        if (goapAgent != null) goapAgent.enabled = true;
        rb.isKinematic = true;
        rb.useGravity = false;
    }

    private void KillSelf()
    {
        // reward player if you have a StatsSingleton
        StatsSingleton.Instance.IncreamentStat(StatType.Snow, worth);

        // destroy the enemy
        Destroy(gameObject);
    }
}
```

```PlayerSystems\Combat\Pillars\IDamagable.cs
using UnityEngine;

/// <summary>
/// Interface for anything that can take damage.
/// This helps us avoid direct references to specific "Enemy" scripts.
/// </summary>
public interface IDamageable
{
    void TakeDamage(float damage);
}
```

```PlayerSystems\Combat\UniqeWeapons\Combat.cs
using System;
using UnityEngine;
using DG.Tweening;
using UnityEngine.VFX;

public class Combat : MonoBehaviour
{
    // melee:
    // check for hit
    // hit? nice get component as SnowEnemy
    // gameObject.enemy.playerHit(hp);

    InputDirector director;
    [SerializeField] Weapon equippedWeapon;
    [SerializeField] GameObject weaponSensor;
    [SerializeField] VisualEffect flamethrowerEffect;

    [SerializeField] float weaponRange = 3f;
    [SerializeField] float weaponCooldown = 0.1f;
    [SerializeField] float flamethrowerDamage = 1f;
    private float _weaponCooldown = 0.1f;
    private bool isFlameThrowering;
    private int combatLayerMask = 0;

    [SerializeField] Transform camPosition;
    [SerializeField] Transform weaponTransform;
    [SerializeField] Transform idlePosition;
    [SerializeField] Transform focusedPosition;

    [SerializeField] float transitionDuration = 0.3f;

    private Tween currentTween;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        director = GetComponent<InputDirector>();
        director.OnCombatPressed += OnCombatMeleePressed;
        director.OnPlayerFlameThrowerStart += Director_OnPlayerFlameThrowerStart;
        director.OnPlayerFlameThrowerStop += Director_OnPlayerFlameThrowerStop;

        weaponTransform.localPosition = idlePosition.localPosition;
        weaponTransform.localRotation = idlePosition.localRotation;
        weaponTransform.gameObject.SetActive(false);

        _weaponCooldown = weaponCooldown;

        combatLayerMask = LayerMask.GetMask("Characters");
    }

    private void OnDestroy()
    {
        director.OnCombatPressed -= OnCombatMeleePressed;
        director.OnPlayerFlameThrowerStart -= Director_OnPlayerFlameThrowerStart;
        director.OnPlayerFlameThrowerStop -= Director_OnPlayerFlameThrowerStop;
    }

    private void OnCombatMeleePressed()
    {
        Debug.Log("Combatting");

        Ray ray = new(camPosition.position, camPosition.forward);
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, 2f, combatLayerMask))
        {
            if (hit.collider.CompareTag("Enemy"))
            {
                if (hit.collider.TryGetComponent(out Enemy enemy))
                    enemy.FistHit(camPosition.position);
            }
        }
    }

    private void Director_OnPlayerFlameThrowerStart()
    {
        weaponTransform.gameObject.SetActive(true);
        isFlameThrowering = true;
        MoveAndRotateWeapon(focusedPosition.localPosition, focusedPosition.localRotation.eulerAngles);
    }

    private void OnPlayerFlameThrowerContinue()
    {
        Debug.Log("That's a fucking FlameThrower!!!");

        // reset cooldown
        if (_weaponCooldown <= 0f)
            _weaponCooldown = weaponCooldown;
        else
            return;

        // actual weapon hit check
        Ray ray = new(weaponSensor.transform.position, weaponSensor.transform.forward);

        RaycastHit hit;
        if (Physics.Raycast(ray, out hit, weaponRange, combatLayerMask))
        {
            if (!hit.collider.CompareTag("Enemy"))
                return;

            Debug.Log("Hit an Enemy!");

            Enemy enemy = hit.collider.GetComponent<Enemy>();

            if (enemy != null)
                enemy.TakeDamage(flamethrowerDamage);
            else
                Debug.Log("WTF Enemy has no Enemy component!");
        }
    }

    private void Director_OnPlayerFlameThrowerStop()
    {
        isFlameThrowering = false;
        MoveAndRotateWeapon(idlePosition.localPosition, idlePosition.localRotation.eulerAngles, false);
    }
    
    public void MoveAndRotateWeapon(Vector3 targetPosition, Vector3 targetRotation, bool startTweek=true)
    {
        // kill any running tweens
        currentTween?.Kill();

        // move the weapon
        currentTween = DOTween.Sequence()
            .Append(weaponTransform.DOLocalMove(targetPosition, transitionDuration).SetEase(Ease.OutQuad))
            .Join(weaponTransform.DOLocalRotate(targetRotation, transitionDuration).SetEase(Ease.OutQuad).OnComplete(() =>
            {
                if (startTweek)
                {
                    flamethrowerEffect.Play();
                }
                else
                {
                    weaponTransform.gameObject.SetActive(false);
                    flamethrowerEffect.Stop();
                }
            }));
    }

    public void EquipWeapon(Weapon newWeapon)
    {
        equippedWeapon = newWeapon;
    }

    private void Update()
    {
        _weaponCooldown -= Time.deltaTime;

        if (isFlameThrowering)
            OnPlayerFlameThrowerContinue();
    }
}

public class Weapon
{
    public int Damage;
}
```

```PlayerSystems\Cutscenes\CameraKnotRotation.cs
using UnityEngine;
using Unity.Cinemachine;
using UnityEngine.Splines;
using Unity.Mathematics;

public class CameraKnotRotation : MonoBehaviour
{
    [SerializeField] CinemachineCamera vcam;
    CinemachineSplineDolly dolly;
    SplineContainer spline;

    private void Start()
    {
        if (!vcam)
            vcam = transform.parent.GetComponentInChildren<CinemachineCamera>();

        dolly = vcam.GetComponent<CinemachineSplineDolly>();
        spline = dolly?.Spline;
    }

    private void LateUpdate()
    {
        if (!dolly || !spline) return;
        
        // normalized position along spline
        float cameraPosition = dolly.CameraPosition;

        var knots = spline.Spline.ToArray();
        int count = knots.Length;
        if (count < 2) return;
        
        // compute knot indices
        float closestKnotPosition = cameraPosition * (count - 1);
        int closestKnotIndex = Mathf.FloorToInt(closestKnotPosition);
        int lastKnotIndex = Mathf.Clamp(closestKnotIndex + 1, 0, count - 1);

        float difference = closestKnotPosition - closestKnotIndex;

        if (closestKnotIndex < 0 || closestKnotIndex >= knots.Length 
                                 || lastKnotIndex < 0 || lastKnotIndex >= knots.Length) return;
        
        quaternion startRotation = knots[closestKnotIndex].Rotation;
        quaternion endRotation = knots[lastKnotIndex].Rotation;

        quaternion newRotation = math.slerp(startRotation, endRotation, difference);

        // Set camera rotation
        vcam.transform.rotation = newRotation;
    }
}
```

```PlayerSystems\Cutscenes\Cutscene.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class Cutscene : MonoBehaviour
{
    public string CutsceneId;
    public List<CutsceneCamera> CutsceneCameras = new ();
    
    public void ConfigSpawnedCamera(Transform newCamera)
    {
        newCamera.SetParent(transform);
        CutsceneCameras.Add(newCamera.GetComponent<CutsceneCamera>());
    }

    private void Awake()
    {
        CutsceneCameras = GetComponentsInChildren<CutsceneCamera>().ToList();
    }
}
```

```PlayerSystems\Cutscenes\CutsceneCamera.cs
using System;
using UnityEngine;
using Unity.Cinemachine;

public class CutsceneCamera : MonoBehaviour
{
    public string CutsceneCameraName;
    public CinemachineCamera VirtualCamera;
    public Action OnCameraReachedTheEnd;
    private CutsceneCameraType _cameraType;
    private bool _cameraFinishedAnimation;
    private bool _blendStarted;
    private bool _waitingForBlend;
    
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    private void Start()
    {
        if (TryGetComponent(out CinemachineCamera virtualCamera))
        {
            VirtualCamera = virtualCamera;
            _cameraType = CutsceneCameraType.StaticCamera;
        }
        else if (GetComponentInChildren<CinemachineCamera>())
        {
            VirtualCamera = GetComponentInChildren<CinemachineCamera>();
            _cameraType = CutsceneCameraType.TrailCamera;
        }
        else
            Debug.LogError("Virtual camera not found on cutscene camera object");
    }

    private void Update()
    {
        if (_cameraFinishedAnimation)
            return;
        
        if (_cameraType == CutsceneCameraType.TrailCamera && VirtualCamera.TryGetComponent<CinemachineSplineDolly>(out var dollyCamera))
            if (dollyCamera.CameraPosition >= 1f)
            {
                _cameraFinishedAnimation = true;
                OnCameraReachedTheEnd?.Invoke();
                
                // release camera, unblock swap camera execution on the next cutscene camera
                CutscenesHelper.CurrentCutsceneCamera = null;
            }
    }

    public void Play(float cameraSpeed=0.2f)
    {
        switch (_cameraType)
        {
            case CutsceneCameraType.StaticCamera:
                break;
            case CutsceneCameraType.TrailCamera:
                PlayDollyCamera(cameraSpeed);
                break;
            default:
                Debug.LogError("if this case happens God is real and I'm a fool doomed to Grok");
                break;
        }
    }
    
    private void PlayDollyCamera(float cameraSpeed)
    {
        CinemachineSplineDolly cameraDolly = VirtualCamera.GetComponent<CinemachineSplineDolly>();
        if (!cameraDolly)
        {
            Debug.LogError("Dolly not found on camera of type TrailCamera!");
            return;
        }

        cameraDolly.CameraPosition = 0f;
        cameraDolly.AutomaticDolly = new SplineAutoDolly
        {
            Enabled = true,
            Method = new SplineAutoDolly.FixedSpeed { Speed = cameraSpeed }
        };
    }

    /// <summary>
    /// Gives priority to this cutscene camera.
    /// this means it will be the active camera, a blend will start from the previous camera to this one.
    /// </summary>
    public void SetAsActiveCamera()
    {
        var brain = CutscenesHelper.GetActive().GetComponent<CinemachineBrain>();
        bool isAlreadyActive = ReferenceEquals(brain.ActiveVirtualCamera, VirtualCamera);
        
        CutscenesHelper.GiveCameraPriority(VirtualCamera);
        _blendStarted = true;
        
        if (isAlreadyActive)
            _waitingForBlend = true;
    }
    
    public void SetFollowTarget(Transform target) => VirtualCamera.Follow = target;

    /// <summary>
    /// Function to check if blend finished
    /// 
    /// IMPORTANT NOTE:
    /// When the very first cutscene camera becomes active, there is no previous
    /// virtual camera to blend from, so Cinemachine will NOT create an ActiveBlend.
    /// Without a blend, our story logic would get stuck waiting for something
    /// that never starts.
    ///
    /// To solve this, we detect if this is the first time this camera is becoming
    /// active (meaning it was already the brain's ActiveVirtualCamera). In that case
    /// we mark the "blend" as already completed.
    ///
    /// Later transitions (camera A  camera B) WILL produce real blends, and
    /// _waitingForBlend will be handled normally.
    /// </summary>
    public bool IsBlendFinished()
    {
        var brain = CutscenesHelper.GetActive().GetComponent<CinemachineBrain>();
        if (!brain) return false;

        var blend = brain.ActiveBlend;

        // If blend never started, were not done yet
        if (_blendStarted && !_waitingForBlend && blend == null)
            return false;
        
        // mark that blending actually started
        if (blend != null)
            _waitingForBlend = true;
        
        if (_waitingForBlend)
            return blend == null;
        
        return false;
    }
    
    public bool IsFinishedPlaying() => _cameraFinishedAnimation;

    public CutsceneCameraType GetCameraType() => _cameraType;
}

public enum CutsceneCameraType
{
    StaticCamera,
    TrailCamera
}
```

```PlayerSystems\Cutscenes\CutscenesHelper.cs
using System;
using System.Collections.Generic;
using System.Linq;
using Unity.Cinemachine;
using UnityEngine;
using Object = UnityEngine.Object;

public class CutscenesHelper
{
    public static CutsceneCamera CurrentCutsceneCamera;
    
    public static Dictionary<String, CutsceneCamera> GatherCutsceneCameras()
    {
        // Gather all cutscenes in the scene
        Dictionary<string, CutsceneCamera> cutscenesCameras = Object.FindObjectsByType<CutsceneCamera>(FindObjectsSortMode.None)
            .ToDictionary(cutsceneCam => cutsceneCam.CutsceneCameraName, cutsceneCam => cutsceneCam);

        // verify cutscenes
        if (cutscenesCameras.Count == 0)
        {
            Debug.LogError("No cutscenes found in scene!");
            return new Dictionary<string, CutsceneCamera>();
        }

        return cutscenesCameras;
    }

    public static CutsceneCamera LocateCamera(string cutsceneCameraName)
    {
        var cameras = GatherCutsceneCameras();
        
        return cameras[cutsceneCameraName];
    }

    /// <summary>
    /// Gives priority to a cutscene camera.
    /// this means it will be the active camera, a blend/transition will start from the previous camera to this one.
    /// </summary>
    /// <param name="cinemachineCamera">New active camera</param>
    public static void GiveCameraPriority(CinemachineCamera cinemachineCamera)
    {
        var availableCameras = Object.FindObjectsByType<CinemachineCamera>(FindObjectsSortMode.None);

        if (availableCameras.Length == 0)
        {
            Debug.LogError($"No Cinemachine Cameras found in scene! how can {cinemachineCamera.name} exist?");
            return;
        }
        
        // lower priority of all cameras
        foreach (var camera in availableCameras)
            camera.Priority = 1;
        
        cinemachineCamera.Priority = 10;
    }

    /// <summary>
    /// in the future this will be replaced when we have different types of cameras.
    /// </summary>
    public static Transform GetActive() => Camera.main?.transform;
    
    
    // todo: cutscene helper editor script possibly sits on the story object that has input boxes, allows inputting name of camera, story object and story character, 3 select buttons which select the corresponding thing in the editor.
}
```

```PlayerSystems\Cutscenes\KnotAligner.cs
using UnityEngine;

public class KnotAligner : MonoBehaviour
{
    private void Start()
    {
        
    }
}
```

```PlayerSystems\Cutscenes\MovieBars.cs
using UnityEngine;
using DG.Tweening;

public class MovieBars : MonoBehaviour
{
    [SerializeField] RectTransform topBar;
    [SerializeField] RectTransform bottomBar;

    Vector2 _topOriginal;
    Vector2 _bottomOriginal;

    void Awake()
    {
        _topOriginal = topBar.anchoredPosition;
        _bottomOriginal = bottomBar.anchoredPosition;
    }

    public void PlayEnterAnimation(float duration, System.Action onComplete)
    {
        float topHeight = topBar.rect.height;
        float bottomHeight = bottomBar.rect.height;
        
        // kill if accidentally there were previous tweens
        DOTween.Kill(topBar);
        DOTween.Kill(bottomBar);

        // teleport offscreen (relative to final)
        topBar.anchoredPosition += new Vector2(0,  topHeight);
        bottomBar.anchoredPosition += new Vector2(0, -bottomHeight);

        var tweenCount = 2;
        void OneDone()
        {
            tweenCount--;
            if (tweenCount <= 0)
                onComplete?.Invoke();
        }

        topBar.DOAnchorPos(_topOriginal, duration)
            .SetEase(Ease.OutQuad)
            .OnComplete(OneDone);
        
        bottomBar.DOAnchorPos(_bottomOriginal, duration)
            .SetEase(Ease.OutQuad)
            .OnComplete(OneDone);
    }

    public void PlayExitAnimation(float duration, System.Action onComplete)
    {
        float topHeight = topBar.rect.height;
        float bottomHeight = bottomBar.rect.height;
        
        // teleport offscreen (relative to final)
        var newTop = topBar.anchoredPosition + new Vector2(0,  topHeight);
        var newBottom = bottomBar.anchoredPosition + new Vector2(0, -bottomHeight);
        
        // kill if accidentally there were previous tweens
        DOTween.Kill(topBar);
        DOTween.Kill(bottomBar);

        var tweenCount = 2;
        void OneDone()
        {
            tweenCount--;
            if (tweenCount <= 0)
                onComplete?.Invoke();
        }

        topBar.DOAnchorPos(newTop, duration)
            .SetEase(Ease.OutQuad)
            .OnComplete(OneDone);
        
        bottomBar.DOAnchorPos(newBottom, duration)
            .SetEase(Ease.OutQuad)
            .OnComplete(OneDone);
    }
}
```

```PlayerSystems\Cutscenes\Editor\CreateCutsceneMenu.cs
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

public class CreateCutsceneMenu
{
    [MenuItem("GameObject/New Cutscene", false, 20)]
    static void CreateCutscene()
    {
        var cutscenePrefab = Resources.Load<GameObject>("Cutscene");
        if (!cutscenePrefab)
        {
            Debug.LogError("Cutscene Prefab not found in Resources!");
            return;
        }
        
        var cutsceneInstance = PrefabUtility.InstantiatePrefab(cutscenePrefab) as GameObject;
        if (!cutsceneInstance)
        {
            Debug.LogError("Could not instantiate Cutscene Prefab!");
            return;
        }
        
        cutsceneInstance.transform.position = Vector3.zero;
        Selection.activeObject = cutsceneInstance;
    }
}
```

```PlayerSystems\Cutscenes\Editor\SpawnCutsceneCamera.cs
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

[CustomEditor(typeof(Cutscene))]
public class SpawnCutsceneCamera : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        Cutscene cutscene = (Cutscene)target;

        if (GUILayout.Button("Spawn new Cutscene Camera"))
        {
            var newCam = SpawnNewaCutsceneCamera("CutsceneCamera");
            if (!newCam)
                return;
            
            SetCutsceneCameraPositionAsSceneView(newCam);
            cutscene.ConfigSpawnedCamera(newCam);
        }

        if (GUILayout.Button("Spawn new Trail Camera"))
        {
            var newCam = SpawnNewaCutsceneCamera("TrailCamera");
            if (!newCam)
                return;
            
            ResetCutsceneCameraPosition(newCam);
            cutscene.ConfigSpawnedCamera(newCam);
        }
    }

    private Transform SpawnNewaCutsceneCamera(string cameraType)
    {
        Debug.Log($"Spawning New Cutscene Camera of type {cameraType}");
        
        // load camera prefab
        var cameraPrefab = Resources.Load<GameObject>(cameraType);
        if (!cameraPrefab)
        {
            Debug.LogError("Camera prefab not found in resources.");
            return null;
        }
        
        // spawn camera outside playmode
        GameObject instance = (GameObject)PrefabUtility.InstantiatePrefab(cameraPrefab);
        
        // actually save it in the editor
        Undo.RegisterCreatedObjectUndo(instance, "Created Cutscene Camera");
        
        // setup new camera
        Selection.activeObject = instance;
        
        return instance.transform;
    }

    /// <summary>
    /// Regular cameras should spawn where the SceneView is
    /// </summary>
    private void SetCutsceneCameraPositionAsSceneView(Transform cameraTransform)
    {
        var sceneView = SceneView.lastActiveSceneView;
        var sceneCamera = sceneView.camera;
        
        cameraTransform.transform.position = sceneCamera.transform.position;
        cameraTransform.transform.rotation = sceneCamera.transform.rotation;
    }
    
    /// <summary>
    /// Trail cameras should spawn at world zero
    /// </summary>
    private void ResetCutsceneCameraPosition(Transform cameraTransform)
    {
        cameraTransform.position = Vector3.zero;
        cameraTransform.rotation = Quaternion.Euler(Vector3.zero);
    }
}
```

```PlayerSystems\Cutscenes\Editor\SplineKnotAligner.cs
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Splines;
#endif
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Splines;
using UnityEditor.SceneManagement;

[CustomEditor(typeof(KnotAligner))]
public class SplineKnotAligner : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        // MoveKnot moveKnot = (MoveKnot)target;
        
        if (GUILayout.Button("Move Knot to SceneView Camera"))
            MoveSelectedKnotToCamera();
    }
    public void MoveSelectedKnotToCamera()
    {
        if (Application.isPlaying)
        {
            Debug.LogWarning("Move Knot To Camera: run this in Edit mode, not Play mode.");
            return;
        }
        Debug.Log("Moving selected knot to Sceneview Camera");
        
        // --------------------------
        // get active selected knot
        // --------------------------
        List<SplineInfo> splineInfos = new List<SplineInfo>();
        
        // get selected spline
        var activeObject = Selection.activeGameObject;
        if (!activeObject) return;
        var splineContainer = activeObject.GetComponent<SplineContainer>();
        if (!splineContainer) return;
        var availableSplines = splineContainer.Splines;

        // create list of spline infos (there should only be one, in my game I will never make more per object)
        for (int i = 0; i < availableSplines.Count; i++)
        {
            splineInfos.Add(new SplineInfo(splineContainer, i));
        }

        // check for the active knot
        var active = SplineSelection.GetActiveElement(splineInfos);
        if (active == null)
        {
            Debug.LogWarning("No spline selected!");
            return;
        }
        var splineInfo = active.SplineInfo.Spline;
        
        var knot = splineInfo[active.KnotIndex];
        
        // --------------------------
        // move selected knot to camera
        // --------------------------
        var sceneView = SceneView.lastActiveSceneView;
        if (!sceneView) return;
        
        var sceneViewCamera = sceneView.camera;
        if (!sceneViewCamera) return;
        
        knot.Position = sceneViewCamera.transform.position;
        knot.Rotation = sceneViewCamera.transform.rotation;
        
        // re-assign knot
        Undo.RecordObject(splineContainer, "Move Knot to SceneView Camera");
        splineContainer.Spline.SetKnot(active.KnotIndex, knot);
        EditorUtility.SetDirty(splineContainer);
    }
}
```

```PlayerSystems\Inventory + Interactables\Example\PotionItem.cs
using UnityEngine;

[SelectionBase]
public class PotionItem : InventoryItem, ItemAction, Interactable
{
    [SerializeField] private string interactableType;
    public string InteractableType { get; }
    
    private void Awake()
    {
        DisplayableInInventoryMenu = true;
    }

    public void Interact()
    {
        Debug.Log("MUCH <3");
        InventorySingleton.Instance.AddItem(this);
        Cursor.visible = true;
        Destroy(gameObject);
    }

    public void Use()
    {
        Debug.Log("Healled by 1200f!");
        StatsSingleton.Instance.IncreamentStat(StatType.Health, 1200f);
    }

    public void MarkAsInteractable()
    {
        Debug.Log("I am Interactable!");
    }
}
```

```PlayerSystems\Inventory + Interactables\Pillars\Interactable.cs
using UnityEngine;

public interface Interactable
{
    public string InteractableType { get; }
    
    void Interact();
    void MarkAsInteractable();
    void StopMarking()
    {
        Debug.Log("Stop marking interactable");
    }
}
```

```PlayerSystems\Inventory + Interactables\Pillars\InventoryItem.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public abstract class InventoryItem : MonoBehaviour
{
    public string Name;
    public Sprite Icon;

    public bool Stackable;
    public bool PickupAble;
    public bool DisplayableInInventoryMenu;

    public int MaxCount = 1;

    public ItemType Type;
    public ItemAction Action;
}

public enum ItemType
{
    None,
    Modifier,
    Potion,
    World,
    Weapon
}
```

```PlayerSystems\Inventory + Interactables\Pillars\InventorySingleton.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class InventorySingleton
{
    static InventorySingleton mInstance;

    public static InventorySingleton Instance
    {
        get
        {
            if (mInstance == null)
            {
                mInstance = new InventorySingleton();

                // maybe I should load this from save data. Oh Well...
                mInstance.m_items = new List<InventoryItem>();
            }
            return mInstance;
        }
    }

    private List<InventoryItem> m_items;

    public void AddItem(InventoryItem item)
    {
        m_items.Add(item);
        InventoryManager._Instance.AddGeneralItem(item);
    }

    public void RemoveItem(InventoryItem item)
    {
        m_items.Remove(item);
    }

    public IEnumerable<InventoryItem> RerieveAllItems(ItemType itemType = ItemType.None)
    {
        if (itemType == ItemType.None)
            return m_items;
        else
            return m_items.Where(item => item.Type == itemType);
    }

    public IEnumerable<InventoryItem> RerieveAllItemsDisplayable(ItemType itemType = ItemType.None)
    {
        if (itemType == ItemType.None)
            return m_items.Where(item => item.DisplayableInInventoryMenu);
        else
            return m_items.Where(item => item.Type == itemType && item.DisplayableInInventoryMenu);
    }

    // From this point on the code is system independent.
    // feel free to remove all of this if you don't want the gui.
    public void EnableInventory()
    {

    }
}
```

```PlayerSystems\Inventory + Interactables\Pillars\ItemAction.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface ItemAction
{
    public void Use();
}
```

```PlayerSystems\Inventory + Interactables\UI Inventory\DraggableItem.cs
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;

public class DraggableItem : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerClickHandler
{
    public int Count = 1;
    TextMeshProUGUI CountText;
    Image image;
    [HideInInspector] public InventoryItem item;
    [HideInInspector] public Transform parentAfterDrag;
    
    public void InitialiseItem(InventoryItem newItem)
    {
        image = GetComponent<Image>();
        CountText = GetComponentInChildren<TextMeshProUGUI>();

        item = newItem;
        image.sprite = item.Icon;
        RefreshCount();
    }

    public void RefreshCount()
    {
        CountText.text = Count.ToString();
        CountText.gameObject.SetActive(Count > 1);
    }

    #region UI Actions
    public void OnBeginDrag(PointerEventData eventData)
    {
        parentAfterDrag = transform.parent;
        transform.SetParent(transform.root.GetComponentInChildren<Canvas>().transform);
        transform.SetAsLastSibling();
        image.raycastTarget = false;
    }

    public void OnDrag(PointerEventData eventData)
    {
        transform.position = Input.mousePosition;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        transform.SetParent(parentAfterDrag);
        image.raycastTarget = true;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        InventoryManager._Instance.UseItem(this);
    }
    #endregion
}
```

```PlayerSystems\Inventory + Interactables\UI Inventory\InventoryManager.cs
using System;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public class InventoryManager : MonoBehaviour
{
    InventorySlot[] InventorySlots;
    DraggableItem InventoryItemPrefab;

    public static InventoryManager _Instance;

    private void Awake()
    {
        if (_Instance == null)
            _Instance = this;
        else
            Destroy(this);

        // collect all slots
        _Instance.InventorySlots = FindObjectsByType<InventorySlot>(FindObjectsSortMode.InstanceID);

        // order slots by position set in editor
        Array.Sort(_Instance.InventorySlots, (slot1, slot2) => slot1.SlotID.CompareTo(slot2.SlotID));

        // Load Addressables
        GetItemDisplayerObject();
    }

    async void GetItemDisplayerObject()
    {
        if (InventoryItemPrefab != null)
            return;

        AsyncOperationHandle<GameObject> handle = Addressables.LoadAssetAsync<GameObject>("DisplayedItem");

        await handle.Task;

        if (handle.Status != AsyncOperationStatus.Succeeded)
        {
            Debug.LogError($"Failed to load InventoryItemPrefab from Addressable with address: {{DisplayedItem}}");
            return;
        }

        InventoryItemPrefab = handle.Result.gameObject.GetComponent<DraggableItem>();
    }

    public bool AddGeneralItem(InventoryItem item)
    {
        // Update existing items
        foreach (InventorySlot slot in InventorySlots)
        {
            DraggableItem itemInSlot = slot.GetComponentInChildren<DraggableItem>();

            if (itemInSlot == null)
                continue;

            // does the item already exist in that slot?
            if (itemInSlot.item.Name == item.Name &&
                itemInSlot.Count < itemInSlot.item.MaxCount &&
                itemInSlot.item.Stackable)
            {
                itemInSlot.Count++;
                itemInSlot.RefreshCount();
                return true;
            }
        }

        // Item doesn't exist. Add it to an empty slot
        foreach (InventorySlot slot in InventorySlots)
        {
            DraggableItem itemInSlot = slot.GetComponentInChildren<DraggableItem>();

            // is the slot empty?
            if (itemInSlot == null)
            {
                SpawnNewItem(item, slot);
                return true;
            }
        }

        return false;
    }

    void SpawnNewItem(InventoryItem item, InventorySlot slot)
    {
        DraggableItem inventoryItem = Instantiate(InventoryItemPrefab, slot.transform);
        inventoryItem.InitialiseItem(item);
    }

    public void UseItem(DraggableItem itemInSlot)
    {
        InventoryItem item = itemInSlot.item;

        itemInSlot.Count--;
        itemInSlot.RefreshCount();

        if (itemInSlot.Count == 0)
            Destroy(itemInSlot.gameObject);

        if (item is ItemAction usableItem)
            usableItem.Use();
    }
}
```

```PlayerSystems\Inventory + Interactables\UI Inventory\InventorySlot.cs
using UnityEngine;
using UnityEngine.EventSystems;

public class InventorySlot : MonoBehaviour, IDropHandler
{
    public int SlotID;

    public void OnDrop(PointerEventData eventData)
    {
        // item already exists on this slot
        if (transform.childCount != 0)
            return;

        GameObject dropped = eventData.pointerDrag;
        DraggableItem draggableItem = dropped.GetComponent<DraggableItem>();

        // a different item was dragged here
        if (draggableItem == null)
            return;

        draggableItem.parentAfterDrag = transform;
    }
}
```

```PlayerSystems\RNGSystem\ExampleLootRoll.cs
using UnityEngine;

public class ExampleLootRoll : MonoBehaviour
{
    private LootGenerator magicItemsGenerator;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        magicItemsGenerator = new LootGenerator.Builder("Magic Items")
            .WithItem(50, "Magic Cape",    () => Debug.Log("You won the cape!"))
            .WithItem(25, "Magic Coat",    () => Debug.Log("Wait, isn't that the cape?"))
            .WithItem(25, "Never happens", () => Debug.Log("That's wild"))
            .Build();
    }

    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.E))
            magicItemsGenerator.Roll();
    }
}
```

```PlayerSystems\RNGSystem\LootGenerator.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class LootGenerator
{
    private class LootEntry
    {
        public string Name;
        public int ChanceWeight;
        public Action WinResult;
    }

    public class Builder
    {
        // name for the loot generator
        private readonly string builderName;

        // all available loot
        private readonly List<LootEntry> entries = new();

        // the function result of a loot roll
        private readonly Action<String> defaultLootResult = name => Debug.Log($"You won {name}!");

        public Builder(string builderName)
        {
            this.builderName = builderName;
        }

        public Builder WithItem(int chanceWeight, string name, Action result = null)
        {
            entries.Add(new LootEntry
            {
                Name = name,
                ChanceWeight = chanceWeight,
                WinResult = result ?? (() => defaultLootResult(name))
            });

            return this;
        }

        public LootGenerator Build()
        {
            // check if total Loot Weight is 100
            int totalWeight = entries.Sum(e => e.ChanceWeight);
            if (totalWeight != 100)
                throw new InvalidOperationException($"Total Chance Weight for your items must be exactly 100. got {totalWeight} for {builderName}");
            
            return new LootGenerator(entries);
        }
    }

    private readonly List<LootEntry> entries;
    private readonly int totalWeight;

    private LootGenerator(List<LootEntry> entries)
    {
        this.entries = entries;
        totalWeight = entries.Sum(e => e.ChanceWeight);
    }

    public void Roll()
    {
        // get a random roll up to the total weight
        int rolledValue = UnityEngine.Random.Range(0, totalWeight);
        int accumulatedRollWeight = 0;

        // find the item that has that roll
        foreach (var entry in entries)
        {
            accumulatedRollWeight += entry.ChanceWeight;

            if (rolledValue < accumulatedRollWeight)
            {
                entry.WinResult?.Invoke();
                break;
            }
        }
    }
}
```

```PlayerSystems\Stats\StatsSingleton.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class StatsSingleton : MonoBehaviour
{
    #region Singleton
    static StatsSingleton mInstance;

    public static StatsSingleton Instance
    {
        get
        {
            if (mInstance == null)
            {
                GameObject go = new("StatsManager");
                mInstance = go.AddComponent<StatsSingleton>();

                mInstance.m_stats = new Dictionary<StatType, Stat>
                {
                    { StatType.Money, new Stat(0f) },
                    { StatType.Health, new Stat(100f) }
                };

                mInstance.m_modifiers = new HashSet<Modifier>();
            }
            return mInstance;
        }
    }
    
    #endregion

    public void ResetStats(Dictionary<StatType, Stat> stats) => mInstance.m_stats = stats;

    private Dictionary<StatType, Stat> m_stats;
    private HashSet<Modifier> m_modifiers;

    private void Update()
    {
        foreach (Modifier modifier in m_modifiers)
        {
            modifier.TimeRemaining -= Time.deltaTime;
            if (modifier.TimeRemaining <= 0f)
                RemoveModifier(modifier);
        }
    }

    public Stat GetStat(StatType type) => m_stats[type];

    public void SetStat(StatType type, float value) => m_stats[type].Value = value;

    public void AddStat(StatType type, float baseValue = 0f)
    {
        if (!m_stats.ContainsKey(type))
        {
            m_stats.Add(type, new Stat(baseValue));
        }
    }

    public void IncreamentStat(StatType type, float amount)
    {
        if (m_stats.ContainsKey(type))
            m_stats[type].Value += amount;
        else
            Debug.LogError($"Could not find stat {type}!");
    }

    public void DecreamentStat(StatType type, float amount)
    {
        if (m_stats.ContainsKey(type))
            m_stats[type].Value -= amount;
        else
            Debug.LogError($"Could not find stat {type}!");
    }

    public void AddOrResetModifier(Modifier modifier)
    {
        IEnumerable<Modifier> existingModifiersOfSameType = m_modifiers.Where(_modifier => _modifier.StatType == modifier.StatType);

        if (existingModifiersOfSameType.Count() == 0)
        {
            m_modifiers.Add(modifier);
            m_stats[modifier.StatType].ActivateModifier(modifier);
            return;
        }

        Modifier highestPriority = existingModifiersOfSameType
            .OrderByDescending(_modifier => _modifier.Priority)
            .FirstOrDefault();

        Modifier toActivate = modifier.Priority > highestPriority.Priority ?
            modifier : highestPriority;

        m_stats[modifier.StatType].DeactivateModifier();
        m_stats[modifier.StatType].ActivateModifier(toActivate);
    }

    public void RemoveModifier(Modifier modifier)
    {
        m_modifiers.Remove(modifier);

        m_stats[modifier.StatType].DeactivateModifier();

        IEnumerable<Modifier> existingModifiersOfSameType = m_modifiers.Where(_modifier => _modifier.StatType == modifier.StatType);

        if (existingModifiersOfSameType.Count() == 0)
            return;

        Modifier highestPriority = existingModifiersOfSameType
            .OrderByDescending(_modifier => _modifier.Priority)
            .FirstOrDefault();

        m_stats[modifier.StatType].ActivateModifier(modifier);
    }
    
    private void OnDestroy()
    {
        if (mInstance == this)
            mInstance = null;
    }
}

public class Stat
{
    private StatType m_type;
    private float m_Value;
    public event Action<float> OnStatChanged;

    private bool canBeModified;
    private float ValuebeforeModifier;
    private bool modifierAcivated;

    // Property to get/set the stat value
    public float Value
    {
        get => m_Value;
        set
        {
            if (Mathf.Approximately(m_Value, value)) return;
            
            m_Value = value;
            OnStatChanged?.Invoke(m_Value);
        }
    }

    public Stat(float initialValue, bool allowModifiers = false) => (m_Value, canBeModified) = (initialValue, allowModifiers);

    public void ActivateModifier(Modifier modifier)
    {
        if (!canBeModified)
        {
            Debug.LogError($"tried to activate a modifier that can't be modified! {modifier.StatType}");
            return;
        }
        if (modifierAcivated)
            Debug.LogError($"modifier is already activated for {modifier.StatType}!");
        else
        {
            modifierAcivated = true;
            ValuebeforeModifier = m_Value;
            m_Value += modifier.Value;
        }
    }

    public void DeactivateModifier()
    {
        if (!canBeModified)
        {
            Debug.LogError($"tried to deactivate a modifier that can't be modified! {m_type}");
            return;
        }
        if (!modifierAcivated)
            Debug.LogError($"No modifier is activated for {m_type}!");
        else
        {
            modifierAcivated = false;
            m_Value = ValuebeforeModifier;
        }
    }
}
```

```PlayerSystems\Stats\stats.cs
using UnityEditor;

public enum StatType
{
    Health,
    Speed,
    Strength,
    Money,
    Luck,
    Snow,
    Diamonds
}

public class Modifier
{
    public StatType StatType;
    public float Value;
    public int Priority;
    public float BaseTime;
    public float TimeRemaining;
}
```

```PlayerSystems\story\story.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class story : MonoBehaviour
{
    private StoryExecuter _storyExecuter;
    public bool StartStoryOnStart = false;

    private void Start()
    {
        _storyExecuter = StoryExecuter.Instance;

        if (StartStoryOnStart)
            startStory();
    }

    public void startStory()
    {
        // setup chapter
        Dictionary<Characters, StoryCharacter> storyCharacters = FindObjectsByType<StoryCharacter>(FindObjectsSortMode.None).ToDictionary(sc => sc.CharacterStory.character);
        StoryCharacter bigFoot = storyCharacters[Characters.Bigfoot];
        _storyExecuter.SetChapter("start");

        // play chapter
        Debug.Log("starting");
        bigFoot.DebugSay("hey");
        bigFoot.GoTo(new Vector3(10, bigFoot.transform.position.y, 1));
        bigFoot.DebugSay("I think it worked!");
        bigFoot.GoTo(new Vector3(1, bigFoot.transform.position.y, 1));
        Debug.Log("ending");

        _storyExecuter.startChapter();
    }
}
```

```PlayerSystems\story\Other\CharacterInteract.cs
public class CharacterInteract : Interactable
{
    public string InteractableType { get; set; }

    public void Interact()
    {
        
    }

    public void MarkAsInteractable()
    {
        
    }

    public void StopMarking()
    {
        
    }
}
```

```PlayerSystems\story\Other\DefaultAnimation.cs
using UnityEngine;

public class DefaultAnimation : MonoBehaviour
{
    [SerializeField] private string animationName;
    
    void Start()
    {
        int animationHash = Animator.StringToHash(animationName);
        GetComponent<Animator>().Play(animationHash);
    }
}
```

```PlayerSystems\story\Speech\SpeechCanvas.cs
using System;
using UnityEngine;
using TMPro;

public class SpeechCanvas : MonoBehaviour
{
    [Header("Assignables")]
    private Camera _cam;
    private RectTransform _chatBubbleRectTransform;
    public GameObject ChatBubble;
    
    [Header("Pointing Stuff")]
    public RectTransform BubblePointer; // that points at who is talking
    public TextMeshProUGUI TextBox;
    private Transform _pointTo;
    private bool _isPointing = false;

    private void OnEnable()
    {
        _cam = Camera.main;
        _chatBubbleRectTransform = ChatBubble.GetComponent<RectTransform>();
    }

    public void SetText(string text)
    {
        TextBox.text = text;
    }

    private void Update()
    {
        if (_isPointing)
        {
            PointTo(_pointTo.position);
        }
    }

    public void StartPointing(Transform worldTransform)
    {
        _pointTo = worldTransform;
        _isPointing = true;
    }

    public void StopPointing()
    {
        _isPointing = false;
    }

    private void PointTo(Vector3 worldPos)
    {
        if (!IsCharacterOnScreen(worldPos))
            return;
        
        // 1. Convert both ends of the tail to *screen* coordinates
        Vector2 bubbleScreen = RectTransformUtility
            .WorldToScreenPoint(null, _chatBubbleRectTransform.position); // UI  screen
        Vector2 targetScreen = _cam.WorldToScreenPoint(worldPos);                            // 3-D  screen

        // 2. Convert those screen coords into the local space of the Pointers parent
        RectTransform parent = (RectTransform)BubblePointer.parent;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            parent, bubbleScreen, null, out Vector2 localStart);  //  camera is null
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            parent, targetScreen, null, out Vector2 localEnd);    //  camera is null

        // 3. Stretch & rotate the pointer
        Vector2 dir    = localEnd - localStart;
        float   length = dir.magnitude;
        
        BubblePointer.localPosition = localStart + dir * 0.5f;
        BubblePointer.sizeDelta     = new Vector2(BubblePointer.sizeDelta.x, length);
        float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg - 90f;
        BubblePointer.localRotation = Quaternion.Euler(0, 0, angle);
    }

    private bool IsCharacterOnScreen(Vector3 worldPos)
    {
        Vector3 vp = _cam.WorldToViewportPoint(worldPos);
        bool onScreen = vp.z > 0f                // in front of the camera
                        && vp.x is >= 0f and <= 1f  // inside left/right
                        && vp.y is >= 0f and <= 1f; // inside top/bottom

        BubblePointer.gameObject.SetActive(onScreen);
        
        return onScreen;
    }
}
```

```PlayerSystems\story\Speech\SpeechManager.cs
using System.Collections;
using UnityEngine;

/// <summary>
/// SpeechManager - Singleton
///
/// get: creates new monobehaviour gameobject (for the UI)
/// SpeechManager.Instance.AnimateText(text);
///
/// OnEnable: textAnimationSpeed = StoryGameSettings.GetSpeed();
/// </summary>
public class SpeechManager : MonoBehaviour
{
    [SerializeField] GameObject canvasObject;
    public bool Finished;
    
    private static SpeechManager _instance;

    public static SpeechManager Instance
    {
        get
        {
            if (!_instance)
            {
                // find an existing one in the scene
                _instance = FindFirstObjectByType<SpeechManager>();

                if (!_instance)
                {
                    // doesn't exist. let's create a new one.
                    GameObject go = new GameObject("SpeechManager");
                    _instance = go.AddComponent<SpeechManager>();
                    DontDestroyOnLoad(go);
                    Debug.Log("New SpeechManager created.");
                }
            }
            
            return _instance;
        }
    }

    private void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Debug.LogError("a Speach Manager already exists!");
            Destroy(gameObject);
            return;
        }

        _instance = this;
        DontDestroyOnLoad(gameObject);
    }


    void LoadActiveCanvas(out SpeechCanvas activeCanvas, Transform characterTransform)
    {
        activeCanvas = FindFirstObjectByType<SpeechCanvas>();
        if (!activeCanvas)
        {
            Debug.Log("No active canvas found!");
            canvasObject = Resources.Load<GameObject>("ActiveCanvas");
            if (!canvasObject)
                Debug.LogError("SpeechManager: Failed to load canvasObject from Resources.");
            activeCanvas = Instantiate(canvasObject).GetComponent<SpeechCanvas>();
        }
        
        // enable canvas
        activeCanvas.ChatBubble.SetActive(true);
        
        // enable speech arrow pointer
        if (characterTransform != null)
        {
            activeCanvas.BubblePointer.gameObject.SetActive(true);
            activeCanvas.StartPointing(characterTransform);
        }
    }

    /// <summary>
    /// starts a new dialogue in the text box
    /// </summary>
    /// <param name="speechMessage"></param>
    /// <param name="letterDelay"></param>
    /// <param name="characterTransform"></param>
    public void LoadDialogue(string speechMessage, Transform characterTransform, float letterDelay=0.2f)
    {
        Finished = false;
        
        LoadActiveCanvas(out SpeechCanvas activeCanvas, characterTransform);
        
        // StopAllCoroutines();
        StartCoroutine(AnimateText(activeCanvas, speechMessage, letterDelay));
    }


    /// <summary>
    /// animating the text letter by letter
    /// </summary>
    IEnumerator AnimateText(SpeechCanvas activeCanvas, string fullMessage, float letterDelay)
    {
        string curentText = "";
        for (int i = 0; i < fullMessage.Length; i++)
        {
            curentText += fullMessage[i];
            activeCanvas.SetText(curentText);
            yield return new WaitForSeconds(letterDelay);
        }
        
        // disable canvas
        while (true)
        {
            if (Input.GetMouseButtonDown(0))
            {
                activeCanvas.StopPointing();
                activeCanvas.ChatBubble.SetActive(false);
                activeCanvas.BubblePointer.gameObject.SetActive(false);
                Finished = true;
                break;
            }
            yield return null;
        }
    }

    public void ResetSpeech()
    {
        SpeechCanvas activeCanvas = FindFirstObjectByType<SpeechCanvas>();
        
        activeCanvas.StopPointing();
        activeCanvas.ChatBubble.SetActive(false);
        activeCanvas.BubblePointer.gameObject.SetActive(false);
        Finished = true;
    }
}
```

```PlayerSystems\story\StoryCheckpoints\Checkpoint.cs
using UnityEngine;

public class Checkpoint : MonoBehaviour
{
    public string CheckpointName;
    [HideInInspector] public Vector3 position;
    [HideInInspector] public Transform transformPosition;

    private void Awake()
    {
        position = transform.position;
        transformPosition = transform;
    }

    static Checkpoint GetCheckpointByName(string checkpointName)
    {
        // are there any checkpoints?
        Checkpoint[] checkpoints = FindObjectsByType<Checkpoint>(FindObjectsSortMode.None);
        if (checkpoints.Length == 0)
        {
            Debug.LogError("No Checkpoints Found!!!");
            return null;
        }

        // get the specific one
        foreach (Checkpoint checkpoint in checkpoints)
        {
            if (checkpoint.CheckpointName == checkpointName)
                return checkpoint;
        }

        Debug.LogError("Checkpoint " + checkpointName + " Doesn't Exist!");
        return null;
    }
}
```

```PlayerSystems\story\StoryData\Chapters.cs
// chapters list
public enum StoryChapters
{
    empty,
    start,
    end
}

public enum ChristmasChapters
{
    Empty,
    NewGame,
    End
}
```

```PlayerSystems\story\StoryData\Characters.cs
using UnityEngine;

public enum Characters
{
    NewSystem,
    
    // playground
    System,
    Player,
    Dummy,
    
    // NewStory
    Doctor,

    // Main game
    Yeti,
    Bigfoot,

    // Christmas game
    DragonGirl,
    
    // Unity 20th Anniversary Game Jam
    TimelessRobot,
    TimelessRobot2,
    
    // GrokStory
    WitchDoctor,
    XAI_Dolphin,
    
    // 90 Perscent
    MechanicSteampunk,
    LadySteampunk,
    Titan,
}
```

```PlayerSystems\story\StoryData\Emotions.cs
public enum Emotions
{
    happy,
    sad,
    mad,
    excited
}
```

```PlayerSystems\story\StoryObjects\StoryObject.cs
using UnityEngine;

/// <summary>
/// registered object in the story, that exists in the scene.
/// </summary>
public class StoryObject : MonoBehaviour
{
    public string Id;

    public Vector3 GetLocation()
    {
        return transform.position;
    }
}
```

```PlayerSystems\story\StorySystem\StoryCharacter.cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class StoryCharacter : MonoBehaviour
{
    public StoryCharacterPrefab CharacterStory;
    public string CutsceneId;
    [SerializeField] private Transform headPosition;
    private StoryExecuter _storyExecuter;
    private NavMeshAgent _navMeshAgent;

    /// <summary>
    /// setup self (story character)
    /// adds script variables
    /// </summary>
    public void SetUp()
    {
        _storyExecuter = StoryExecuter.Instance;
        _navMeshAgent = GetComponent<NavMeshAgent>(); // can be null
    }

    /// <summary>
    /// setup all story characters
    /// </summary>
    public void SetUp(Dictionary<Characters, StoryCharacter> characters)
    {
        foreach (StoryCharacter character in characters.Values)
            character.SetUp();
    }

    public void DebugSay(string text)
    {
        _storyExecuter.addAction(new DebugSay(text));
    }

    public void Say(string text, bool speakWhatHeSays=false)
    {
        Transform characterTransform = CharacterStory.ShowTailWhenTalking
            ? GetCharacterHeadTransform() : null;

        _storyExecuter.addAction(new Say(text, characterTransform));
    }
    
    public void GoTo(Vector3 targetPosition, float speed = 4f)
    {
        _storyExecuter.addAction(new GoTo(transform, targetPosition, speed, _navMeshAgent));
    }
    public void GoTo(GameObject targetObject, float speed = 4f)
    {
        _storyExecuter.addAction(new GoTo(transform, targetObject.transform.position, speed, _navMeshAgent));
    }
    public void GoTo(StoryObject targetObject, float speed = 4f)
    {
        _storyExecuter.addAction(new GoTo(transform, targetObject.GetLocation(), speed, _navMeshAgent));
    }
    public void GoTo(string storyObjectId, float speed = 4f)
    {
        if (StoryHelper.FindStoryObjectInScene(storyObjectId, out StoryObject gotoObject))
            _storyExecuter.addAction(new GoTo(transform, gotoObject.GetLocation(), speed, _navMeshAgent));
    }

    public void LookAt(Transform targetTransform, float speed = 4f)
    {
        _storyExecuter.addAction(new LookAt(transform, targetTransform, speed));
    }
    
    public void LookAt(GameObject targetObject, float speed = 4f)
    {
        _storyExecuter.addAction(new LookAt(transform, targetObject.transform, speed));
    }
    
    public void LookAt(StoryObject targetTransform, float speed = 4f)
    {
        _storyExecuter.addAction(new LookAt(transform, targetTransform.transform, speed));
    }
    
    public void LookAtActiveCamera(float speed = 4f)
    {
        var activeCamera = CutscenesHelper.GetActive();
        _storyExecuter.addAction(new LookAt(transform, activeCamera, speed: speed));
    }

    public void WalkToPositionWithoutRotating(Vector3 position, Vector3? lookTo = null)
    {
        lookTo ??= Vector3.zero;

        Debug.LogError("I think I forgot to do this one");
        Debug.Log("going (without rotating) to " + position);
    }

    public void RotateTo(Quaternion rotation)
    {

    }

    public void TeleportTo(Vector3 position)
    {

    }


    public void WaitForPlayerToGetTo(GameObject targetObject)
    {
        GameObject player = GameObject.FindWithTag("Player");
        _storyExecuter.addAction(new WaitUntilPlayerNearGameobject(player.transform, targetObject.transform.position));
    }

    /// <summary>
    /// plays given animation
    /// </summary>
    public void Behave(string animationName, bool continueStoryWhilePlaying=false)
    {
        var animator = GetComponent<Animator>();
        if (animator == null)
            animator = gameObject.GetComponentInChildren<Animator>();
        if (animator == null)
        {
            Debug.LogError("no animator found when requested behave!");
            return;
        }
        
        _storyExecuter.addAction(new PlayAnimation(animator, animationName, continueStoryWhilePlaying));
    }

    /// <summary>
    /// Camera & Cutscene Controls
    /// </summary>
    
    public void SwapPlayerState<TNewMovementState, TNewCameraState>()
    where TNewMovementState : MovementState, new()
    where TNewCameraState : CameraState, new()
    {
        _storyExecuter.addAction(new SwapPlayerState<TNewMovementState, TNewCameraState>());
    }
    
    public void SwapCamera(
        CutsceneCamera vcam,
        Transform followTargetTransform=null,
        float speed=0.2f,
        bool continueStoryOverCamera=true
        ) => _storyExecuter.addAction(new SwapCamera(
            vcam, speed, continueStoryOverCamera, followTargetTransform));
    
    public void ShowMovieBars(bool waitForCompletion = false, float duration = 0.6f)
        => _storyExecuter.addAction(new ShowMovieLines(
            waitForCompletion, duration));
    
    public void HideMovieBars(float duration = 0.6f) 
        => _storyExecuter.addAction(new HideMovieLines(
            duration));
    
    /// <summary>
    /// System Story Commands
    /// </summary>

    public void EnableInput() => _storyExecuter.addAction(new EnableInput());
    
    public void DisableInput() => _storyExecuter.addAction(new DisableInput());
    
    public void ShowCursor() => _storyExecuter.addAction(new ShowCursor());
    
    public void HideCursor() => _storyExecuter.addAction(new HideCursor());

    public void EnableJump() => _storyExecuter.addAction(new EnableJumpInput());
    
    public void DisableJump() => _storyExecuter.addAction(new DisableJumpInput());
    
    public void DelayedAction(Action action)
    {
        _storyExecuter.addAction(new DelayedStoryAction(action));
    }

    public void Delay(float time)
    {
        _storyExecuter.addAction(new Delay(time));
    }

    public static void SpawnCharacter(GameObject character, Vector3 position, Quaternion? rotationDirection = null)
    {
        Quaternion quaternion = Quaternion.identity;
        if (rotationDirection.HasValue)
            quaternion = rotationDirection.Value;

        Instantiate(character, position, quaternion);
    }
    
    /// <summary>
    /// Non-Story actions
    /// </summary>
    private Transform GetCharacterHeadTransform()
    {
        if (headPosition)
            return headPosition;
        return transform;
    }
}
```

```PlayerSystems\story\StorySystem\StoryCharacterPrefab.cs
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "StoryCharacterPrefab", menuName = "Zero/StoryCharacter")]
public class StoryCharacterPrefab : ScriptableObject
{
    public string CharacterName;
    public Characters character;
    public GameObject prefab;
    public bool ShowTailWhenTalking = true;
    private Dictionary<Emotions, Sprite> _faces;

    public Sprite getFace(Emotions emotion)
    {
        if (!_faces.ContainsKey(emotion))
            emotion = Emotions.happy;

        return _faces[emotion];
    }
}
```

```PlayerSystems\story\StorySystem\StoryCommand.cs
using System;
using UnityEngine;
using UnityEngine.AI;
using Object = UnityEngine.Object;

public interface StoryCommand
{
    public bool Execute();
}

// -- Story Commands --
public class DebugSay : StoryCommand
{
    private readonly string _text;
    public DebugSay(string text)
    {
        _text = text;
    }

    public bool Execute()
    {
        Debug.Log(_text);
        return true;
    }
}

public class EmptyCommand : StoryCommand
{
    public bool Execute()
    {
        Debug.Log("hello there!");
        return true;
    }
}

public class Say : StoryCommand
{
    private readonly float _letterDelay;
    private readonly string _text;
    private readonly Transform? _characterTransform;
    private bool _initiated;
    
    public Say(string text, Transform? characterTransform=null, float letterDelay=0.04f)
    {
        _text = text;
        _letterDelay = letterDelay;
        _characterTransform = characterTransform;
    }

    public bool Execute()
    {
        if (!_initiated)
        {
            SpeechManager.Instance.LoadDialogue(_text, _characterTransform, _letterDelay);
            _initiated = true;
        }
        
        return SpeechManager.Instance.Finished;
    }
}

public class GoTo : StoryCommand
{
    private readonly Vector3 _targetPosition;
    private readonly Transform _character;
    private readonly float _speed;

    private bool _useNavmesh;
    private NavMeshAgent _agent;

    public GoTo(Transform character, Vector3 position, float speed, NavMeshAgent agent=null)
    {
        _character = character;
        _targetPosition = position;
        _speed = speed;
        _agent = agent;
        _useNavmesh = agent;
    }

    public bool Execute()
    {
        if (_useNavmesh)
        {
            _agent.speed = _speed;
            _agent.SetDestination(_targetPosition);
        
            if (!_agent.pathPending && _agent.remainingDistance < 0.4f && !_agent.hasPath)
                return true;
        }
        else
        {
            _character.position = Vector3.MoveTowards(_character.position, _targetPosition, Time.deltaTime * _speed);
            if (Vector3.Distance(_character.position, _targetPosition) < 0.4f)
                return true;
        }

        return false;
    }
}

public class PlayAnimation : StoryCommand
{
    private Animator _animator;
    private string _animationName;
    private bool _continueStoryWhilePlaying;

    private bool _startedPlayingAnimation;
    private bool _finishedAnimation;
    
    public PlayAnimation(Animator animator, string animationName, bool continueStoryWhilePlaying=false)
    {
        _animator = animator;
        _animationName = animationName;
        _continueStoryWhilePlaying = continueStoryWhilePlaying;
    }
    
    public bool Execute()
    {
        // wait for animation to finish
        if (_startedPlayingAnimation)
            return _finishedAnimation || _continueStoryWhilePlaying;
        
        // play animation once
        CrossplayAnimationUsingTimer(_animationName, () =>
        {
            _finishedAnimation = true;
        });
        
        return false;
    }
    
    private void CrossplayAnimationUsingTimer(string animationClipName, Action onAnimationFinished = null)
    {
        if (_startedPlayingAnimation)
            return;
        _startedPlayingAnimation = true;
        
        var timer = new CountdownTimer(GetAnimationLength(animationClipName));
        timer.OnTimerStart += () => _animator.CrossFade(animationClipName, 0.2f);

        timer.OnTimerStop += onAnimationFinished;

        timer.Start();
    }
    
    private float GetAnimationLength(string animationClipName)
    {
        int animationClipHash = Animator.StringToHash(animationClipName);
        
        foreach (AnimationClip clip in _animator.runtimeAnimatorController.animationClips) {
            if (Animator.StringToHash(clip.name) == animationClipHash) {
                return clip.length;
            }
        }

        return -1f;
    }
}

public class DelayedStoryAction : StoryCommand
{
    private readonly Action _delayedAction;

    public DelayedStoryAction(Action delayedAction)
    {
        _delayedAction = delayedAction;
    }

    public bool Execute()
    {
        _delayedAction();
        
        return true;
    }
}

public class Delay : StoryCommand
{
    private readonly float _time;
    private bool _startedTimer;
    private bool _finishedTimer;
    private CountdownTimer _timer;
    
    public Delay(float time)
    {
        _time = time;
    }

    public bool Execute()
    {
        if (_startedTimer)
        {
            _timer.Tick(Time.deltaTime);
            return _finishedTimer;
        }
        
        _timer = new CountdownTimer(_time);
        _timer.OnTimerStart += () => _startedTimer = true;
        _timer.OnTimerStop += () => _finishedTimer = true;
        
        _timer.Start();
        
        return false;
    }
}

public class LookAt : StoryCommand
{
    private Transform _targetLook;
    private readonly Transform _character;
    private readonly float _lookSpeed;

    public LookAt(Transform character, Transform targetLook, float speed=4f)
    {
        _character = character;
        _targetLook = targetLook;
        _lookSpeed = speed;
    }

    public bool Execute()
    {
        Vector3 targetDirection = _targetLook.position - _character.position;
        targetDirection.y = 0f;
        Quaternion targetRotation = Quaternion.LookRotation(targetDirection);
        
        // smoothly rotate:
        Quaternion newRotation = Quaternion.Slerp(
            _character.rotation,
            targetRotation,
            _lookSpeed * Time.deltaTime);

        // constrain rotation only around Y
        newRotation = Quaternion.Euler(0, newRotation.eulerAngles.y, 0);
        _character.rotation = newRotation;
        
        // check if reached close enough to target rotation
        float angle = Quaternion.Angle(_character.rotation, targetRotation);
        return angle < 1f;
    }
}

public class DisableInput : StoryCommand
{
    public bool Execute()
    {
        InputDirector.Instance.DisableInput();
        return true;
    }
}

public class EnableInput : StoryCommand
{
    public bool Execute()
    {
        InputDirector.Instance.EnableInput();
        return true;
    }
}

public class DisableJumpInput : StoryCommand
{
    public bool Execute()
    {
        InputDirector.Instance.DisableJumpInput();
        return true;
    }
}

public class EnableJumpInput : StoryCommand
{
    public bool Execute()
    {
        InputDirector.Instance.EnableJumpInput();
        return true;
    }
}

public class ShowCursor : StoryCommand
{
    public bool Execute()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
        return true;
    }
}

public class HideCursor : StoryCommand
{
    public bool Execute()
    {
        Cursor.visible = false;
        Cursor.lockState = CursorLockMode.Locked;
        return true;
    }
}

public class WaitUntilPlayerNearGameobject : StoryCommand
{
    private readonly Vector3 _targetObject;
    private readonly Transform _player;
    private readonly float _speed;

    public WaitUntilPlayerNearGameobject(Transform player, Vector3 position)
    {
        _player = player;
        _targetObject = position;
    }

    public bool Execute()
    {
        if (Vector3.Distance(_player.position, _targetObject) < 0.4f)
            return true;
        return false;
    }
}

public class SwapPlayerState<TMovementState, TCameraState> : StoryCommand
    where TMovementState : MovementState, new()
    where TCameraState : CameraState, new()
{
    public bool Execute()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (!player)
            return true; // nothing to do, skip
        
        var movementManager = player.GetComponentInChildren<MovementManager>();
        var cameraManager = player.GetComponentInChildren<CameraManager>();

        if (!movementManager || !cameraManager)
            return true; // also skip instead of breaking story

        movementManager.ChangeState(new TMovementState());
        cameraManager.ChargeState(new TCameraState());

        return true;
    }
}

public class SwapCamera : StoryCommand
{
    private readonly CutsceneCamera _cutsceneCamera;
    private readonly float _cameraSpeed;
    private readonly bool _continueStoryOverCamera;
    private readonly Transform _followTarget;

    private bool _gavePriorityOnce;
    private bool _playedCameraOnce;
    private bool _finishedCameraAnimation;

    public SwapCamera(CutsceneCamera cutsceneCamera,
        float cameraSpeed,
        bool continueStoryOverCamera,
        Transform followTarget = null)
    {
        _cutsceneCamera = cutsceneCamera;
        _cameraSpeed = cameraSpeed;
        _continueStoryOverCamera = continueStoryOverCamera;
        _followTarget = followTarget;
        
        _gavePriorityOnce = false;
        _playedCameraOnce = false;
    }
    
    public bool Execute()
    {
        // Block Execution if another camera is running
        if (BlockUntilCutsceneCameraFree())
            return false;
        
        // Start Transition (Blend) to new virtual camera
        if (!_gavePriorityOnce)
            GivePriorityOnce();
                
        // wait for blend to finish
        if (!_cutsceneCamera.IsBlendFinished())
            return false;
        
        // ok, finished, play camera
        if (!_playedCameraOnce)
            PlayCameraOnce();
        
        // can the story continue while the camera is still playing?
        if (_continueStoryOverCamera)
            return true;

        // go to the next story action once the camera finished its animation.
        return _finishedCameraAnimation;
    }
    
    /// <summary>
    /// sometimes we let the camera run while the story keeps playing.
    /// if the story gets to a point where it asks for another camera to play (this one),
    /// we will pause execution until the other camera finishes, only than start.
    /// </summary>
    public bool BlockUntilCutsceneCameraFree()
    {
        // If another camera is playing, don't activate yet
        if (CutscenesHelper.CurrentCutsceneCamera 
            && CutscenesHelper.CurrentCutsceneCamera != _cutsceneCamera 
            && !CutscenesHelper.CurrentCutsceneCamera.IsFinishedPlaying())
        {
            return true;
        }
        
        CutscenesHelper.CurrentCutsceneCamera = _cutsceneCamera;
        return false;
    }
    
    private void GivePriorityOnce()
    {
        _gavePriorityOnce = true;
        _cutsceneCamera.SetAsActiveCamera();
    }
    
    private void PlayCameraOnce()
    {
        _playedCameraOnce = true;

        switch (_cutsceneCamera.GetCameraType())
        {
            case CutsceneCameraType.StaticCamera:
                if (_followTarget)
                    _cutsceneCamera.SetFollowTarget(_followTarget);
                _finishedCameraAnimation = true;  // static: immediately done
                
                // release camera, unblock swap camera execution on the next cutscene camera
                CutscenesHelper.CurrentCutsceneCamera = null;
                break;

            case CutsceneCameraType.TrailCamera:
                _cutsceneCamera.OnCameraReachedTheEnd += () => _finishedCameraAnimation = true;
                _cutsceneCamera.Play(_cameraSpeed);
                break;
        }
    }
}

public class ShowMovieLines : StoryCommand
{
    private float _duration;
    private bool _waitForCompletion;
    private bool _spawned;
    private bool _completed;

    public ShowMovieLines(bool waitForCompletion = false, float duration=0.6f)
    {
        _waitForCompletion = waitForCompletion;
        _duration = duration;
    }
    
    public bool Execute()
    {
        if (_completed)
            return true;
        
        if (_spawned)
            return false;
        
        // look for existing bars
        var existing = Object.FindObjectOfType<MovieBars>();
        if (existing)
        {
            Debug.LogError("Movie bars already shown!");
            return true;
        }

        // Load
        var prefab = Resources.Load<GameObject>("MovieBars");
        if (!prefab)
        {
            Debug.LogError("Movie bars prefab not found!");
            return true;
        }
        
        // Instantiate bars
        var barsObj = Object.Instantiate(prefab);
        var bars = barsObj.GetComponentInChildren<MovieBars>();
        _spawned = true;

        bars.PlayEnterAnimation(_duration, () => {
            _completed = true;
        });

        return !_waitForCompletion;   // keep running until animation ends
        // or continue if not waiting for completion.
    }
}

public class HideMovieLines : StoryCommand
{
    private float _duration;
    private bool _waitForCompletion;
    private bool _found;
    private bool _completed;

    public HideMovieLines(float duration=0.6f)
    {
        _duration = duration;
    }
    
    public bool Execute()
    {
        if (_completed)
            return true;
        
        if (_found)
            return false;
        
        // look for existing bars
        var existing = Object.FindObjectOfType<MovieBars>();
        if (!existing)
        {
            Debug.LogError("Movie bars not found!");
            return true;
        }

        // Load
        var barsInScene = Object.FindFirstObjectByType<MovieBars>();
        if (!barsInScene)
        {
            Debug.LogError("Movie bars prefab not found!");
            return true;
        }
        
        // start bars exit animation
        _found = true;
        barsInScene.PlayExitAnimation(_duration, () => {
            _completed = true;
            Object.Destroy(barsInScene.transform.parent.gameObject);
        });

        return !_waitForCompletion;   // keep running until animation ends
        // or continue if not waiting for completion.
    }
}
```

```PlayerSystems\story\StorySystem\StoryExecuter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// a singleton which "runs" the story.
/// we use it to play / pause a running story.
/// </summary>
public class StoryExecuter : MonoBehaviour
{
    public StoryCommand CurrentAction;
    public Queue<StoryCommand> Story = new();
    public string CurrentChapter;
    public Action<string> OnChapterFinished;
    private bool _allowDebug;
    
    public bool IsStoryRunning { get; private set; }

    private static StoryExecuter _instance;

    public static StoryExecuter Instance
    {
        get
        {
            if (!_instance)
            {
                // find an existing one in the scene
                _instance = FindFirstObjectByType<StoryExecuter>();

                if (!_instance)
                {
                    // doesn't exist. let's create a new one.
                    GameObject go = new GameObject("StoryExecuter");
                    _instance = go.AddComponent<StoryExecuter>();
                    DontDestroyOnLoad(go);
                    Debug.Log("New StoryExecuter created.");
                }
            }
            
            return _instance;
        }
    }

    private void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Debug.LogError("a story executer already exists!");
            Destroy(gameObject);
            return;
        }

        _instance = this;
        DontDestroyOnLoad(gameObject);
    }

    // Update is called once per frame
    void Update()
    {
        if (!IsStoryRunning) return;        // story isnt playing
        
        // run the current Action; when it reports done (returns true) we move on
        if (CurrentAction != null && CurrentAction.Execute())
        {
            StoryLog("Finished Action.");
            
            if (Story.Count > 0)            // theres another command waiting
            {
                CurrentAction = Story.Dequeue();
                StoryLog("Starting Action.");
            }
            else                            // nothing left  chapter finished
            {
                Debug.Log($"Chapter: '{CurrentChapter}': finished");
            
                string finishedChapter = CurrentChapter;
                IsStoryRunning  = false;
                CurrentChapter  = "";
                CurrentAction   = null;
                
                OnChapterFinished?.Invoke(finishedChapter);
            }
        }
    }

    /// <summary>
    /// adds a new "action" to the story.
    /// can be to speak,
    /// go somewhere, lookat something.
    /// </summary>
    /// <param name="action"></param>
    public void addAction(StoryCommand action)
    {
        Story.Enqueue(action);
    }

    public void LogCurrentChapter()
    {
        if (!string.IsNullOrEmpty(CurrentChapter))
            Debug.Log("No chapter selected");
        else
            Debug.Log(CurrentChapter);
    }
    
    /// <summary>
    /// visual only. will be used to differ between chapters.
    /// this makes sure that no "two" chapters run at the same time.
    /// we tell the story that I am now starting to enqueue commands for chapter X.
    /// </summary>
    /// <param name="chapter"></param>
    public void SetChapter(string chapter)
    {
        if (!string.IsNullOrEmpty(CurrentChapter))
            throw new Exception(
                $"setting a new chapter: \"{chapter}\", but did not finish current chapter: \"{CurrentChapter}\"!");

        CurrentChapter = chapter;
    }

    /// <summary>
    /// after we enqueued commands for a chapter, in order to "Play" the story,
    /// we run this function.
    /// </summary>
    public void startChapter()
    {
        Debug.Log("Starting new chapter: " + CurrentChapter);

        if (!string.IsNullOrEmpty(CurrentChapter))
        {
            Debug.Log("No chapter selected, Playing empty chapter");
        }
        
        if (Story.Count is 0)
        {
            Debug.Log("Chapter is empty! story will not play anything.");
            return;
        }
        
        CurrentAction = Story.Dequeue();
        IsStoryRunning = true;
    }

    public void ResetChapter()
    {
        CurrentChapter = "";
        CurrentAction = null;
        Story.Clear();
        
        SpeechManager.Instance.ResetSpeech();
    }

    private void StoryLog(string log)
    {
        if (_allowDebug)
            Debug.Log($"(Story) Chapter: '{CurrentChapter}': '{CurrentAction}': {log}");
    }
    
    public void AllowDebug() => _allowDebug = true;
    public void DisableDebug() => _allowDebug = false;

    public StoryCharacter GetSystem()
    {
        // check if exists in scene
        var allCharacters = StoryHelper.GatherAllCharacters();

        foreach (var character in allCharacters.Where(character
                     => character.CharacterStory.character == Characters.System))
            return character;

        // if doesn't, create it
        var systemPrefab = Resources.Load<StoryCharacter>("System");
        if (!systemPrefab)
        {
            Debug.LogError("couldn't find system in resources!");
            return null;
        }
        
        return Instantiate(systemPrefab, Vector3.zero, Quaternion.identity);
    }
}
```

```PlayerSystems\story\StorySystem\StoryHelper.cs
using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Object = UnityEngine.Object;

public class StoryHelper
{
    #region StoryCharacters

    /// <summary>
    /// Gather all characters present in the scene, dictionary format
    /// </summary>
    /// <returns>dictionary of available characters in the scene:
    /// (character id, character object)</returns>
    [Obsolete("Use GatherCharacters() of Dictionary<String, StoryCharacter> instead")]
    public static Dictionary<Characters, StoryCharacter> GatherCharactersByEnum()
    {
        // Gather all characters in the scene
        StoryCharacter[] foundCharacters = Object.FindObjectsByType<StoryCharacter>(FindObjectsSortMode.None);

        // verify characters are built correctly
        if (foundCharacters.Length == 0)
        {
            Debug.LogError("No story characters found!");
            return new ();
        }
        foreach (StoryCharacter character in foundCharacters)
        {
            if (character.CharacterStory is null)
                Debug.LogError($"Character {character.name} has no StoryCharacter assigned!");
        }
        
        // save them to dictionary and setup them
        try
        {
            Dictionary<Characters, StoryCharacter> storyCharacters = foundCharacters
                .ToDictionary(sc => sc.CharacterStory.character);

            SetUpAll(storyCharacters);
        
            return storyCharacters;
        }
        catch (ArgumentException e)
        {
            Debug.LogError("Likely used old story gathering system of enums! use GatherCharacters instead.");
            Debug.LogError("OR made a new character? you forgot to change it's CharacterType.");
            Debug.LogError(e);
            return new Dictionary<Characters, StoryCharacter>();
        }
    }

    /// <summary>
    /// Gather all characters present in the scene
    /// </summary>
    public static StoryCharacter[] GatherAllCharacters()
    {
        // Gather all characters in the scene
        StoryCharacter[] foundCharacters =
            Object.FindObjectsByType<StoryCharacter>(FindObjectsSortMode.None);

        // verify characters are built correctly
        if (foundCharacters.Length == 0)
        {
            Debug.LogError("No story characters found!");
            return Array.Empty<StoryCharacter>();
        }

        return foundCharacters;
    }

    /// <summary>
    /// Gather all characters present in the scene for a specific cutscene
    /// </summary>
    /// <param name="cutsceneId">Cutscene identifier</param>
    public static Dictionary<string, StoryCharacter> GatherCharacters(string cutsceneId)
    {
        // Gather all characters in the scene
        StoryCharacter[] foundCharacters = GatherAllCharacters();

        if (foundCharacters.Length == 0)
            return new Dictionary<string, StoryCharacter>();

        // Filter by cutscene
        var filteredCharacters = foundCharacters
            .Where(sc => sc.CutsceneId == cutsceneId);

        var filteredCharactersList = filteredCharacters.ToList();
        if (!filteredCharactersList.Any())
        {
            Debug.LogWarning($"No characters found for cutscene '{cutsceneId}'.");
            return new Dictionary<string, StoryCharacter>();
        }

        // Validate
        foreach (StoryCharacter character in filteredCharactersList)
        {
            if (character.CharacterStory == null)
                Debug.LogError($"Character {character.name} has no CharacterStory assigned!");
            else if (string.IsNullOrWhiteSpace(character.CharacterStory.CharacterName))
                Debug.LogError($"Character {character.name} has an empty CharacterName!");
        }

        // save them to dictionary and setup them
        try
        {
            Dictionary<string, StoryCharacter> storyCharacters =
                filteredCharactersList.ToDictionary(
                    sc => sc.CharacterStory.CharacterName
                );

            SetUpAll(storyCharacters);
            return storyCharacters;
        }
        catch (ArgumentException e)
        {
            Debug.LogError(
                $"Duplicate CharacterName detected in cutscene '{cutsceneId}'."
            );
            Debug.LogError(e);
            throw;
        }
    }

    public static StoryCharacter GatherSpecific(string requestedName)
    {
        var allCharacters = GatherAllCharacters();
        foreach (var character in allCharacters)
        {
            if (character.CharacterStory.CharacterName == requestedName)
                return character;
        }
        
        throw new ArgumentException($"Character with name {requestedName} not found in scene!");
    }
    
    /// <summary>
    /// Gather all characters in the scene, string[] format
    /// </summary>
    /// <returns>string array of available characters in the scene</returns>
    public static string[] GatherCharactersIds(bool ignoreSystemCharacter = true)
    {
        // Gather all characters in the scene
        StoryCharacter[] foundCharacters = Object.FindObjectsByType<StoryCharacter>(FindObjectsSortMode.None);
        var resultCharacters = new List<string>();
        
        // verify characters are built correctly
        if (foundCharacters.Length == 0)
        {
            Debug.LogError("No story characters found!");
            return Array.Empty<string>();
        }
        foreach (StoryCharacter character in foundCharacters)
        {
            if (character.CharacterStory is null)
            {
                Debug.LogError($"Character {character.name} has no StoryCharacter assigned!");
                continue;
            }
            
            if (character.CharacterStory.character is Characters.System && ignoreSystemCharacter)
                continue;
            
            resultCharacters.Add(character.CharacterStory.character.ToString());
        }
        
        return resultCharacters.ToArray();
    }
    
    // sets their script variables
    private static void SetUpAll(Dictionary<Characters, StoryCharacter> characters)
    {
        foreach (StoryCharacter character in characters.Values)
            character.SetUp();
    }

    private static void SetUpAll(Dictionary<string, StoryCharacter> characters)
    {
        foreach (StoryCharacter character in characters.Values)
            character.SetUp();
    }

    #endregion

    #region StoryObjects

    
    /// <summary>
    /// gathers all story objects present in the scene
    /// </summary>
    /// <returns>Dictionary: (StoryObject Id, StoryObject)</returns>
    public static Dictionary<string, StoryObject> GatherStoryObjects()
    {
        StoryObject[] foundObjects = Object.FindObjectsOfType<StoryObject>();
        
        if (foundObjects.Length == 0)
        {
            Debug.LogError("No story Objects found!");
            return new ();
        }
        
        return foundObjects.ToDictionary(so => so.Id, sc => sc);
    }
    
    /// <summary>
    /// gathers all story objects present in the scene
    /// </summary>
    /// <returns>array of all their names</returns>
    public static string[] GatherStoryObjectsIds(bool ignoreSystemCharacter = true)
    {
        StoryObject[] foundObjects = Object.FindObjectsOfType<StoryObject>();
        
        if (foundObjects.Length == 0)
        {
            Debug.LogError("No story Objects found!");
            return Array.Empty<string>();
        }

        var resultObjects = foundObjects.Select(sc => sc.Id).ToList();

        // remove system object
        if (ignoreSystemCharacter && resultObjects.Contains("SystemObject"))
            resultObjects.Remove("SystemObject");

        return resultObjects.ToArray();
    }
    
    /// <summary>
    /// returns a storyObject object from the scene by id
    /// </summary>
    public static bool FindStoryObjectInScene(string storyObjectId, out StoryObject storyObject)
    {
        var objectsInScene = GatherStoryObjects();
        if (objectsInScene.TryGetValue(storyObjectId, out var gotoObject))
        {
            storyObject = gotoObject;
            return true;
        }
        
        Debug.LogError($"Cannot find StoryObject {storyObjectId} in scene!");
        storyObject = null;
        return false;
    }

    #endregion
}
```

```PlayerSystems\story\StorySystem\StoryTrigger.cs
using System;
using UnityEngine;
using UnityEngine.Events;

public class StoryTrigger : MonoBehaviour
{
    public bool AllowRerun;
    public bool RunOnTrigger = true;
    public float RerunCooldown = 10f;
    
    public bool _triggerActivated;
    
    /// <summary>
    /// future Yonatan: feel free to create another story trigger script
    /// and add parameters to the UnityEvent from there.
    /// </summary>
    [SerializeField] private UnityEvent storyTrigger;

    private void OnTriggerEnter(Collider other)
    {
        if (!RunOnTrigger)
            return;
        
        if (_triggerActivated)
            return;

        if (other.CompareTag("Player"))
        {
            _triggerActivated = true;
            storyTrigger?.Invoke();
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (!AllowRerun ||
            !_triggerActivated ||
            !RunOnTrigger)
            return;
        
        if (other.CompareTag("Player"))
            Invoke(nameof(ResetTrigger), RerunCooldown);
    }

    private void ResetTrigger() => _triggerActivated = false;
}
```

```Scenes\Player\PlayerStory.cs
using UnityEngine;

public class PlayerStory : MonoBehaviour
{
    private void Start()
    {
        StoryExecuter executer = StoryExecuter.Instance;
        var characters = StoryHelper.GatherCharactersByEnum();
        
        executer.SetChapter("testing player story");
        
        var system = characters[Characters.System];
        system.SwapPlayerState<cc_tpState, TP_CameraState>();
        
        executer.startChapter();
    }
}
```

```WorldSystems\DayNight\DayClock.cs
using System;
using UnityEngine;
using UnityEngine.Events;
using System.Collections.Generic;

/// <summary>
/// In Game Clock
/// Opens up events
/// </summary>
public class DayClock : MonoBehaviour
{
#region Configurations
    // normalized time. 0 = midnight, 0.5 = noon.
    [Range(0f, 1f)] public float CurrentTime = 0f;

    [Tooltip("Seconds for 24-hour cycle")]
    public float CycleLength = 1200f; // 20 min by default

    [Tooltip("Global multiplier for speed-up/down")]
    public float TimeScale = 1f;

    // event for every time change
    [SerializableAttribute] public class FloatEvent : UnityEvent<float> { }
    public FloatEvent OnTimeChanged = new();
#endregion

#region Timed_Events
    // Time events
    public UnityEvent OnSunrise = new();
    public UnityEvent OnNoon = new();
    public UnityEvent OnSunset = new();
    public UnityEvent OnMidnight = new();

    // Generic time event - allowing calls for specific times
    private readonly SortedDictionary<float, UnityEvent> customTimeEvents = new();
    private float previousTime;

    /// <summary>
    /// Adds a time-based event at a normalized time (0 - 1)
    /// If repeatDaily is false, it will only trigger once.
    /// </summary>
    public UnityEvent AddEventNormlized(float normalizedTime, bool repeatDaily = true)
    {
        // Normalize the time
        normalizedTime = Mathf.Repeat(normalizedTime, 1f);
        
        // get or create the event for this time
        if (!customTimeEvents.TryGetValue(normalizedTime, out var timedEvent))
        {
            timedEvent = new UnityEvent();
            customTimeEvents.Add(normalizedTime, timedEvent);
        }

        if (!repeatDaily)
        {
            // create Wrapper for the event that triggers once
            UnityEvent singleUseEvent = new();
            singleUseEvent.AddListener(() =>
            {
                timedEvent.Invoke();
                customTimeEvents.Remove(normalizedTime);
            });
            return singleUseEvent;
        }

        return timedEvent;
    }

    public UnityEvent AddEventHHMM(int hhmm, bool repeatDaily = true)
    {
        int hour   = hhmm / 100;
        int minute = hhmm % 100;

        float normalized = ((hour * 60f) + minute); // 1440f
        
        return AddEventNormlized(normalized, repeatDaily);
    }
#endregion

#region HandleTime
    private void Update()
    {
        // calculate normalized "current time"
        previousTime = CurrentTime;
        CurrentTime = Mathf.Repeat(CurrentTime + (Time.deltaTime * TimeScale) / CycleLength, 1f);

        // Fire generic update
        OnTimeChanged?.Invoke(CurrentTime);

        // Built-in events
        CheckAndInvokeTimedEvent(0f, OnMidnight);
        CheckAndInvokeTimedEvent(0.25f, OnSunrise);
        CheckAndInvokeTimedEvent(0.5f, OnNoon);
        CheckAndInvokeTimedEvent(0.75f, OnSunset);

        // Custom events call
        foreach (var customEvent in customTimeEvents)
        {
            CheckAndInvokeTimedEvent(customEvent.Key, customEvent.Value);
        }
    }

    private void CheckAndInvokeTimedEvent(float triggerTime, UnityEvent timedEventToInvoke)
    {
        if (HasCrossed(triggerTime, previousTime, CurrentTime))
        {
            timedEventToInvoke?.Invoke();
        }
    }

    // checks if we crossed a specific time
    // example: if we moved from 0.24 to 0.26 and sunrise is 0.25 "sunrise() just happpened"
    // but: if we moved from 0.99 back to 0.01, special case for midnight() which is at 0.0.
    private bool HasCrossed(float triggerTime, float previousTime, float currentTime)
    {
        bool regularTimeCheck = previousTime <= currentTime;
        bool lastFrameWeWereBeforeTheTrigger = previousTime < triggerTime;
        bool nowWeAreAfterTheTrigger = currentTime >= triggerTime;

        if (regularTimeCheck)
            return lastFrameWeWereBeforeTheTrigger && nowWeAreAfterTheTrigger;
        else
        { // midnight event (0.99 -> 0.01)
            // midnight could be called twice at low times
            if (Mathf.Approximately(triggerTime, 0f))
                return previousTime > 0.9f && currentTime < 0.1f;

            return lastFrameWeWereBeforeTheTrigger || nowWeAreAfterTheTrigger;
        }
    }
#endregion
}
```

```WorldSystems\DayNight\DayNightSystem.cs
using UnityEngine;

/// <summary>
/// Central System that holds reference to the core DayNightSystem components.
/// it will decide if they are active, or not.
/// </summary>

[DisallowMultipleComponent]
public class DayNightSystem : MonoBehaviour
{
    #region singleton
    // singleton this
    private static DayNightSystem _instance;

    public static DayNightSystem Singleton
    {
        get
        {
            if (_instance == null)
            {
                // find existing instance in scene
                _instance = FindFirstObjectByType<DayNightSystem>();

                // if none exist, something wrong happened.
                if (_instance == null)
                    Debug.LogError("I tried accessing the daynight system when it doesn't exist.");
            }

            return _instance;
        }
    }

    private void Awake()
    {
        // ensure this is destroyed if singleton already exists
        if (_instance != null && _instance != this)
        {
            Destroy(gameObject);
            return;
        }

        _instance = this;
        DontDestroyOnLoad(gameObject);
    }
    #endregion

    #region DayTime_ActiveStatus
    public void Config(ActiveStatus status)
    {
        DayNightSystemStatus = status;
    }

    public class ActiveStatus
    {
        public bool DayClockActive = true;
        public bool LightingControllerActive = true;
        public bool SkyboxControllerActive = true;
        public bool StarfieldControllerActive = true;
        public bool LightProbeControllerActive = true;
        public bool BiomeManagerActive = true;
        public bool DayNightDebuggerActive = true;
    }
    #endregion

    public ActiveStatus DayNightSystemStatus = new ActiveStatus();
    
    private DayClock dayClock;
    private LightingController lightingController;
    private SkyboxController skyboxController;
    private StarfieldController starfieldController;
    private LightProbeController lightProbeController;
    private BiomeManager biomeManager;
    private DayNightDebugger debugger;
}
```

```WorldSystems\DayNight\Extensions\BiomeManager.cs
using UnityEngine;
using UnityEngine.Events;
using System.Collections.Generic;

public class BiomeManager : MonoBehaviour
{
    [System.Serializable] public class BiomeEvent : UnityEvent<BiomeProfile> { }
    public BiomeEvent OnBiomeChanged = new();

    [Tooltip("Default biome if none active")] public BiomeProfile defaultBiome;
    [Tooltip("If false, this component does nothing")]
    public bool overwriteCurrentSettings = true;

    private readonly Dictionary<string, BiomeProfile> biomes = new();
    private BiomeProfile current;

    // ------------------------- API
    public void ResetManager()
    {
        biomes.Clear();
        current = defaultBiome;
        OnBiomeChanged.Invoke(current);
    }

    public void AddBiome(string name, BiomeProfile profile)
    {
        if (!biomes.ContainsKey(name))
            biomes.Add(name, profile);
    }

    public void AddAllBiomes()
    {
        foreach (var lb in FindObjectsByType<LevelBiome>(FindObjectsSortMode.None))
        {
            AddBiome(lb.BiomeName, lb.Profile);
        }
    }

    public void SetBiome(string name)
    {
        if (!overwriteCurrentSettings) return;
        if (biomes.TryGetValue(name, out var profile) && profile != current)
        {
            current = profile;
            OnBiomeChanged.Invoke(current);
        }
    }

    public BiomeProfile GetCurrentProfile() => current ?? defaultBiome;
}
```

```WorldSystems\DayNight\Extensions\BiomeProfile.cs
using UnityEngine;

[CreateAssetMenu(fileName="BiomeProfile", menuName="DayNight/Biome Profile", order=0)]
public class BiomeProfile : ScriptableObject
{
    [Header("Lighting Curves (evaluated by time 01)")]
    public Gradient lightColor;
    public AnimationCurve lightIntensity = AnimationCurve.Linear(0, 1, 1, 0);

    public Gradient ambientColor;
    public Gradient fogColor;
    public AnimationCurve fogDensity = AnimationCurve.Constant(0, 1, 0.01f);

    [Header("Skybox")]
    public Material skyboxDay;
    public Material skyboxNight;
    public AnimationCurve skyboxExposure = AnimationCurve.EaseInOut(0, 1f, 1, 0.05f);

    [Header("Starfield")] public AnimationCurve starsAlpha = AnimationCurve.Linear(0, 0, 1, 1);
}
```

```WorldSystems\DayNight\Extensions\DayNightDebugger.cs
internal class DayNightDebugger
{
}
```

```WorldSystems\DayNight\Extensions\LevelBiome.cs
using UnityEngine;

class LevelBiome : MonoBehaviour
{
    public string BiomeName;
    public BiomeProfile Profile;
}
```

```WorldSystems\DayNight\Extensions\LightProbeController.cs
internal class LightProbeController
{
}
```

```WorldSystems\DayNight\Extensions\LightingController.cs
internal class LightingController
{
}
```

```WorldSystems\DayNight\Extensions\SkyboxController.cs
internal class SkyboxController
{
}
```

```WorldSystems\DayNight\Extensions\StarfieldController.cs
internal class StarfieldController
{
}
```

```WorldSystems\GoapAI\GoapAgent.cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

[SelectionBase]
[RequireComponent(typeof(Rigidbody))]
[RequireComponent(typeof(NavMeshAgent))]
[RequireComponent(typeof(GoapAnimator))]
public class GoapAgent : IGoapAgent
{
    [Header("Sensors")]
    private Sensor ChaseSensor => Sensors["ChaseSensor"];
    private Sensor AttackSensor => Sensors["AttackSensor"];
    
    [Header("Known Locations")]
    private Transform RestingPosition => Locations["RestingPosition"];
    private Transform FoodShack => Locations["FoodShack"];
    private Transform DoorOnePosition => Locations["DoorOnePosition"];
    private Transform DoorTwoPosition => Locations["DoorTwoPosition"];


    [Header("Stats")]
    private float _health = 100;
    private float _stamina = 100;

    #region Goap

    protected override void SetupBeliefs()
    {
        Beliefs = new Dictionary<string, AgentBelief>();
        BeliefFactory factory = new(this, Beliefs);

        factory.AddBelief("Nothing", () => false);

        factory.AddBelief("AgentIdle", () => !AgentNavmesh.hasPath);
        factory.AddBelief("AgentMoving", () => AgentNavmesh.hasPath);
        factory.AddBelief("AgentHealthLow", () => _health < 30);
        factory.AddBelief("AgentIsHealthy", () => _health >= 50);
        factory.AddBelief("AgentStaminaLow", () => _stamina < 10);
        factory.AddBelief("AgentIsRested", () => _stamina >= 50);

        factory.AddLocationBelief("AgentAtDoorOne", 3f, DoorOnePosition);
        factory.AddLocationBelief("AgentAtDoorTwo", 3f, DoorTwoPosition);
        factory.AddLocationBelief("AgentAtRestingPosition", 3f, RestingPosition);
        factory.AddLocationBelief("AgentAtFoodShack", 3f, FoodShack);

        factory.AddSensorBelief("PlayerInChaseRange", ChaseSensor);
        factory.AddSensorBelief("PlayerInAttackRange", AttackSensor);

        factory.AddBelief("AttackingPlayer", () => false); // Player can always be attacked, this will never become true
    }

    protected override void SetupActions()
    {
        Actions = new HashSet<AgentAction>
        {
            new AgentAction.Builder("Relax")
            .WithStrategy(new IdleStrategy(5))
            .AddEffect(Beliefs["Nothing"])
            .Build(),
            
            new AgentAction.Builder("Wander Around")
            .WithStrategy(new WanderStrategy(AgentNavmesh, 10))
            .AddEffect(Beliefs["AgentMoving"])
            .Build(),

            new AgentAction.Builder("MoveToEatingPosition")
            .WithStrategy(new MoveStrategy(AgentNavmesh, () => FoodShack.position, GAnimator))
            .AddEffect(Beliefs["AgentAtFoodShack"])
            .Build(),

            new AgentAction.Builder("Eat")
            .WithStrategy(new IdleStrategy(5)) // Later replace with a Command
            .AddPrecondition(Beliefs["AgentAtFoodShack"])
            .AddEffect(Beliefs["AgentIsHealthy"])
            .Build(),

            new AgentAction.Builder("MoveToDoorOne")
            .WithStrategy(new MoveStrategy(AgentNavmesh, () => DoorOnePosition.position, GAnimator))
            .AddEffect(Beliefs["AgentAtDoorOne"])
            .Build(),

            new AgentAction.Builder("MoveToDoorTwo")
            .WithStrategy(new MoveStrategy(AgentNavmesh, () => DoorTwoPosition.position, GAnimator))
            .AddEffect(Beliefs["AgentAtDoorTwo"])
            .Build(),

            new AgentAction.Builder("MoveFromDoorOneToRestArea")
            .WithStrategy(new MoveStrategy(AgentNavmesh, () => RestingPosition.position, GAnimator))
            .AddPrecondition(Beliefs["AgentAtDoorOne"])
            .AddEffect(Beliefs["AgentAtRestingPosition"])
            .Build(),

            new AgentAction.Builder("MoveFromDoorTwoToRestArea")
            .WithStrategy(new MoveStrategy(AgentNavmesh, () => RestingPosition.position, GAnimator))
            .WithCost(2)
            .AddPrecondition(Beliefs["AgentAtDoorTwo"])
            .AddEffect(Beliefs["AgentAtRestingPosition"])
            .Build(),

            new AgentAction.Builder("Rest")
            .WithStrategy(new IdleStrategy(5))
            .AddPrecondition(Beliefs["AgentAtRestingPosition"])
            .AddEffect(Beliefs["AgentIsRested"])
            .Build(),

            new AgentAction.Builder("ChasePlayer")
            .WithStrategy(new MoveStrategy(AgentNavmesh, () => Beliefs["PlayerInChaseRange"].Location, GAnimator))
            .AddPrecondition(Beliefs["PlayerInChaseRange"])
            .AddEffect(Beliefs["PlayerInAttackRange"])
            .Build(),
            
            new AgentAction.Builder("AttackPlayer")
            .WithStrategy(new AttackStrategy(GAnimator))
            .AddPrecondition(Beliefs["PlayerInAttackRange"])
            .AddEffect(Beliefs["AttackingPlayer"])
            .Build()
        };
    }

    protected override void SetupGoals()
    {
        Goals = new HashSet<AgentGoal>
        {
            new AgentGoal.Builder("Chill Out")
            .WithPriority(1)
            .WithDesiredEffect(Beliefs["Nothing"])
            .Build(),

            new AgentGoal.Builder("Wander")
            .WithPriority(1)
            .WithDesiredEffect(Beliefs["AgentMoving"])
            .Build(),

            new AgentGoal.Builder("KeepHealthUp")
            .WithPriority(2)
            .WithDesiredEffect(Beliefs["AgentIsHealthy"])
            .Build(),

            new AgentGoal.Builder("KeepStaminaUp")
            .WithPriority(2)
            .WithDesiredEffect(Beliefs["AgentIsRested"])
            .Build(),
            
            new AgentGoal.Builder("SeekAndDestroy")
            .WithPriority(3)
            .WithDesiredEffect(Beliefs["AttackingPlayer"])
            .Build()
        };
    }

    #endregion

    #region Updates

    protected override void UpdateStats()
    {
        _stamina += InRangeOf(RestingPosition.position, 3f) ? 20 : -10;
        _health += InRangeOf(FoodShack.position, 3f) ? 20 : -5;
        _stamina = Mathf.Clamp(_stamina, 0, 100);
        _health = Mathf.Clamp(_health, 0, 100);
    }

    #endregion


    #region HelperFunctions

    bool InRangeOf(Vector3 pos, float range) => Vector3.Distance(transform.position, pos) < range;

    void OnEnable() => ChaseSensor.OnTargetChanged += HandleTargetChanged;
    void OnDisable() => ChaseSensor.OnTargetChanged -= HandleTargetChanged;

    void HandleTargetChanged()
    {
        Debug.Log("GOAP: Target changed, clearing current action and goal");
        
        ResetActionAndGoal();
    }

    #endregion
}
```

```WorldSystems\GoapAI\Pillars\Actions.cs
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

public class AgentAction
{
    public string Name { get; }
    public float Cost { get; private set; }

    public HashSet<AgentBelief> Preconditions { get; } = new();
    public HashSet<AgentBelief> Effects { get; } = new(); // Results of this strategy

    IActionStrategy strategy;
    public bool Complete => strategy.Complete;

    public Action OnComplete = () => { };

    AgentAction(string name)
    {
        Name = name;
    }

    public void Start() => strategy.Start();

    public void Update(float deltaTime)
    {
        // Check if aciton can be performed and update the strategy
        if (strategy.CanPerform)
        {
            strategy.Update(deltaTime);
        }

        // Bail out if the strategy is still executing
        if (!strategy.Complete) return;

        // Apply effects
        foreach (var effect in Effects)
        {
            effect.Evaluate();
        }
    }

    public void Stop() => strategy.Stop();

    public class Builder
    {
        readonly AgentAction action;

        public Builder(string name)
        {
            action = new AgentAction(name)
            {
                Cost = 1
            };
        }

        public Builder WithCost(float cost)
        {
            action.Cost = cost;
            return this;
        }

        public Builder WithStrategy(IActionStrategy strategy)
        {
            action.strategy = strategy;
            return this;
        }

        public Builder AddPrecondition(AgentBelief precondition)
        {
            action.Preconditions.Add(precondition);
            return this;
        }

        public Builder AddEffect(AgentBelief effect)
        {
            action.Effects.Add(effect);
            return this;
        }

        public AgentAction Build()
        {
            return action;
        }
    }
}
```

```WorldSystems\GoapAI\Pillars\Beliefs.cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BeliefFactory
{
    readonly IGoapAgent agent;
    readonly Dictionary<string, AgentBelief> beliefs;

    public BeliefFactory(IGoapAgent agent, Dictionary<string, AgentBelief> beliefs)
    {
        this.agent = agent;
        this.beliefs = beliefs;
    }

    public void AddBelief(string key, Func<bool> condition)
    {
        beliefs.Add(key, new AgentBelief.Builder(key)
            .WithCondition(condition)
            .Build());
    }
    
    public void AddFalseBelief(string key, Func<bool> condition)
    {
        beliefs.Add(key, new AgentBelief.Builder(key)
            .WithCondition(()  => !condition())
            .Build());
    }

    public void AddSensorBelief(string key, params Sensor[] sensors)
    {
        beliefs.Add(key, new AgentBelief.Builder(key)
            .WithCondition(() => // condition to activate the sensor
            {
                foreach (Sensor sensor in sensors)
                    if (sensor.IsTargetInRange)
                        return true;
                return false;
            })
            .WithLocation(() => // location for when the sensor detected something
            {
                foreach (Sensor sensor in sensors)
                    if (sensor.IsTargetInRange)
                        return sensor.TargetPosition;
                
                foreach (Sensor sensor in sensors)
                    Debug.Log(sensor.name + ": " + sensor.IsTargetInRange);
                Debug.LogError($"WTF? Sensor {key} detected something but does not hold anything!");
                Debug.Break();
                return Vector3.zero;
            })
            .Build());
    }

    public void AddSensorFalseBelief(string key, Sensor sensor)
    {
        beliefs.Add(key, new AgentBelief.Builder(key)
            .WithCondition(() => !sensor.IsTargetInRange)
            .WithLocation(() => sensor.TargetPosition)
            .Build());
    }

    public void AddLocationBelief(string key, float distance, Transform locationCondition)
    {
        AddLocationBelief(key, distance, locationCondition.position);
    }

    public void AddLocationBelief(string key, float distance, Vector3 locationCondition)
    {
        beliefs.Add(key, new AgentBelief.Builder(key)
            .WithCondition(() => InRangeOf(locationCondition, distance))
            .WithLocation(() => locationCondition)
            .Build());
    }

    bool InRangeOf(Vector3 pos, float range) => Vector3.Distance(agent.transform.position, pos) < range;
}

public class AgentBelief
{
    public string Name { get; }

    Func<bool> condition = () => false;
    Func<Vector3> observedLocation = () => Vector3.zero;

    public Vector3 Location => observedLocation();

    AgentBelief(string name)
    {
        Name = name;
    }

    public bool Evaluate() => condition();

    public class Builder
    {
        readonly AgentBelief belief;

        public Builder(string name)
        {
            belief = new AgentBelief(name);
        }

        public Builder WithCondition(Func<bool> condition)
        {
            belief.condition = condition;
            return this;
        }

        public Builder WithLocation(Func<Vector3> observedLocation)
        {
            belief.observedLocation = observedLocation;
            return this;
        }

        public AgentBelief Build()
        {
            return belief;
        }
    }
}
```

```WorldSystems\GoapAI\Pillars\Goals.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AgentGoal
{
    public string Name { get; }
    public float Priority { get; private set; }
    public HashSet<AgentBelief> DesiredEffects { get; } = new();

    AgentGoal(string name)
    {
        Name = name;
    }

    public class Builder
    {
        readonly AgentGoal goal;

        public Builder(string name)
        {
            goal = new AgentGoal(name);
        }

        public Builder WithPriority(float priority)
        {
            goal.Priority = priority;
            return this;
        }

        public Builder WithDesiredEffect(AgentBelief effect)
        {
            goal.DesiredEffects.Add(effect);
            return this;
        }

        public AgentGoal Build()
        {
            return goal;
        }
    }
}
```

```WorldSystems\GoapAI\Pillars\GoapAnimationMapper.cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class GoapAnimationMapper : MonoBehaviour
{
    public string Fight = "fight";
    public string Dance = "dance";
    public string Falldown = "falldown";
}
```

```WorldSystems\GoapAI\Pillars\GoapAnimator.cs
using System;
using UnityEngine;

public class GoapAnimator
{
    private const int DefaultAnimationClip = 0;
    private const float CrossfadeDuration = 0.1f;
    
    private readonly Animator AgentAnimator;
    public readonly GoapAnimationMapper AnimationMapper;
    private CountdownTimer _timer;

    public GoapAnimator(Animator agentAnimator, GoapAnimationMapper animationMapper)
    {
        AgentAnimator = agentAnimator;
        AnimationMapper = animationMapper;
    }

    public void CrossplayAnimationUsingTimer(string animationClipName, Action onAnimationFinished = null)
    {
        if (!AgentAnimator)
        {
            onAnimationFinished?.Invoke();
            return;
        }
        
        _timer = new CountdownTimer(GetAnimationLength(animationClipName));
        _timer.OnTimerStart += () => AgentAnimator.CrossFade(animationClipName, CrossfadeDuration);

        _timer.OnTimerStop += onAnimationFinished ?? (
            () => AgentAnimator.CrossFade(DefaultAnimationClip, CrossfadeDuration));

        _timer.Start();
    }

    /// <summary>
    /// sets a trigger on animator and throws event after animation ends.
    /// </summary>
    /// <param name="animationClipName">name of the imported clip! the one you drag to animator controller.</param>
    /// <param name="animationTrigger">name of trigger to activate in animator controller.</param>
    /// <param name="onAnimationFinished">event to throw after animation finished playing.</param>
    public void TriggerAnimationUsingTimer(string animationClipName, string animationTrigger, Action onAnimationFinished = null)
    {
        if (!AgentAnimator)
        {
            onAnimationFinished?.Invoke();
            return;
        }
        
        _timer = new CountdownTimer(GetAnimationLength(animationClipName));
        _timer.OnTimerStart += () => AgentAnimator.SetTrigger(animationTrigger);

        _timer.OnTimerStop += onAnimationFinished ?? (
            () => AgentAnimator.CrossFade(DefaultAnimationClip, CrossfadeDuration));

        _timer.Start();
    }
    

    public void PlayAnimationImmediately(string animationClipName, Action onAnimationFinished = null)
    {
        if (!AgentAnimator)
        {
            onAnimationFinished?.Invoke();
            return;
        }
        
        AgentAnimator.CrossFade(animationClipName, CrossfadeDuration);

        onAnimationFinished?.Invoke();

        _timer.Start();
    }
    
    public void SetFloat(string animationClipName, float value) => AgentAnimator?.SetFloat(animationClipName, value);
    public void SetBool(string animationClipName, bool value) => AgentAnimator?.SetBool(animationClipName, value);
    public void SetTrigger(string animationClipName) => AgentAnimator?.SetTrigger(animationClipName);

    public void UpdateAnimationsTimer(float deltaTime)
        => _timer?.Tick(deltaTime);
    
    /// helper functions
    private float GetAnimationLength(string animationClipName)
    {
        int animationClipHash = Animator.StringToHash(animationClipName);
        
        foreach (AnimationClip clip in AgentAnimator.runtimeAnimatorController.animationClips) {
            if (Animator.StringToHash(clip.name) == animationClipHash) {
                return clip.length;
            }
        }

        return -1f;
    }
}
```

```WorldSystems\GoapAI\Pillars\GoapPlanner.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public interface IGoapPlanner
{
    ActionPlan Plan(HashSet<AgentAction> agentActions, HashSet<AgentGoal> goals, AgentGoal mostRecentGoal = null);
}

public class GoapPlanner : IGoapPlanner
{
    private readonly bool _logAgent;

    public GoapPlanner(bool logAgent=false)
    {
        _logAgent = logAgent;
    }

    public ActionPlan Plan(HashSet<AgentAction> agentActions, HashSet<AgentGoal> goals, AgentGoal mostRecentGoal = null)
    {
        // Order goals by priority, descending
        List<AgentGoal> orderedGoals = goals
            .Where(g => g.DesiredEffects.Any(b => !b.Evaluate()))
            .OrderByDescending(g => g == mostRecentGoal ? g.Priority - 0.01 : g.Priority)
            .ToList();

        // Try to solve each goal in order
        foreach (var goal in orderedGoals)
        {
            Node goalNode = new(null, goal.DesiredEffects, 0);

            // If we can find a path to the goal, return the plan
            if (FindPath(goalNode, agentActions))
            {
                // If the goalNode has no leaves and no action to perform try a different goal
                if (goalNode.IsLeafDead) continue;

                Stack<AgentAction> actionStack = new();
                while (goalNode.Leaves.Count > 0)
                {
                    var cheapestLeaf = goalNode.Leaves.OrderBy(leaf => leaf.Cost).First();
                    goalNode = cheapestLeaf;
                    actionStack.Push(cheapestLeaf.Action);
                }

                return new ActionPlan(goal, actionStack);
            }
        }

        GoapLog("No plan found");
        return null;
    }

    bool FindPath(Node parent, HashSet<AgentAction> actions)
    {
        // Order actions by cost, ascending
        var orderedActions = actions.OrderBy(a => a.Cost);

        foreach (var action in orderedActions)
        {
            var requiredEffects = parent.RequiredEffects;

            // Remove any effects that evaluate to true, there is no action to take
            requiredEffects.RemoveWhere(b => b.Evaluate());

            // If there are no required effects to fulfill, we have a plan
            if (requiredEffects.Count == 0)
            {
                return true;
            }

            if (action.Effects.Any(requiredEffects.Contains))
            {
                var newRequiredEffects = new HashSet<AgentBelief>(requiredEffects);
                newRequiredEffects.ExceptWith(action.Effects);
                newRequiredEffects.UnionWith(action.Preconditions);

                var newAvailableActions = new HashSet<AgentAction>(actions);
                newAvailableActions.Remove(action);

                var newNode = new Node(action, newRequiredEffects, parent.Cost + action.Cost);

                // Explore the new node recursively
                if (FindPath(newNode, newAvailableActions))
                {
                    parent.Leaves.Add(newNode);
                    newRequiredEffects.ExceptWith(newNode.Action.Preconditions);
                }

                // If all effects at this depth have been satisfied, return true
                if (newRequiredEffects.Count == 0)
                {
                    return true;
                }
            }
        }

        return parent.Leaves.Count > 0;
    }

    private void GoapLog(string radioMessage)
    {
        if (_logAgent)
            Debug.LogWarning(radioMessage);
    }
}

public class Node
{
    public AgentAction Action { get; }
    public HashSet<AgentBelief> RequiredEffects { get; }
    public List<Node> Leaves { get; }
    public float Cost { get; }

    public bool IsLeafDead => Leaves.Count == 0 && Action == null;

    public Node(AgentAction action, HashSet<AgentBelief> effects, float cost)
    {
        Action = action;
        RequiredEffects = new HashSet<AgentBelief>(effects);
        Leaves = new List<Node>();
        Cost = cost;
    }
}

// GOAP Planning Algorithm
public class ActionPlan
{
    public AgentGoal AgentGoal { get; }
    public Stack<AgentAction> Actions { get; }

    public ActionPlan(AgentGoal agentGoal, Stack<AgentAction> actions)
    {
        AgentGoal = agentGoal;
        Actions = actions;
    }
}
```

```WorldSystems\GoapAI\Pillars\GoapRunner.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class GoapRunner
{
    // goap
    private Dictionary<string, AgentBelief> _beliefs;
    private HashSet<AgentAction> _actions;
    private HashSet<AgentGoal> _goals;
    
    // runner
    private ActionPlan _actionPlan;
    private AgentAction _currentAction;
    private AgentGoal _currentGoal;
    private AgentGoal _lastGoal;

    private readonly IGoapPlanner _gPlanner;
    private readonly UnityAction _preActionReset;

    private bool _logGoap;

    public GoapRunner(
        Dictionary<string, AgentBelief> beliefs,
        HashSet<AgentAction> actions,
        HashSet<AgentGoal> goals,
        UnityAction preActionReset,
        bool logAgent)
    {
        _preActionReset = preActionReset;
        _beliefs = beliefs;
        _actions = actions;
        _goals = goals;
        
        _logGoap = logAgent;
        _gPlanner = new GoapPlanner(logAgent);
    }

    public void UpdateRunner(
        Dictionary<string, AgentBelief> beliefs,
        HashSet<AgentAction> actions,
        HashSet<AgentGoal> goals)
    {
        _beliefs = beliefs;
        _actions = actions;
        _goals = goals;
    }
    
    public void Perform()
    {
        // Update the plan and current action if there is one
        if (_currentAction == null)
        {
            UpdatePlanAndAction();
        }

        // If we have a current action, execute it
        if (_actionPlan != null && _currentAction != null)
        {
            ExecuteAction();
        }
    }

    private void UpdatePlanAndAction()
    {
        LogGoap("GOAP: Calculating any potential new plan");
        CalculatePlan();

        if (_actionPlan != null && _actionPlan.Actions.Count > 0)
        {
            _preActionReset();

            _currentGoal = _actionPlan.AgentGoal;
            string planToPrint = string.Join("-> ", _actionPlan.Actions.Select(g => g.Name));
            LogGoap($"GOAP: Goal: {_currentGoal.Name} with {_actionPlan.Actions.Count} actions in plan: {planToPrint}");
            _currentAction = _actionPlan.Actions.Pop();
            LogGoap($"GOAP: Popped action: {_currentAction.Name}");
            if (_logGoap) LogPreconditions();
            // Verify all precondition effects are true
            if (_currentAction.Preconditions.All(b => b.Evaluate()))
            {
                _currentAction.Start();
            }
            else
            {
                LogGoap("Preconditions not met, clearing current action and goal");
                _currentAction = null;
                _currentGoal = null;
            }
        }
    }

    private void ExecuteAction()
    {
        _currentAction.Update(Time.deltaTime);

        if (_currentAction.Complete)
        {
            Debug.Log($"GOAP: {_currentAction.Name} complete");
            _currentAction.Stop();
            _currentAction = null;

            if (_actionPlan.Actions.Count == 0)
            {
                Debug.Log("GOAP: Plan complete");
                _lastGoal = _currentGoal;
                _currentGoal = null;
            }
        }
    }
    
    private void CalculatePlan()
    {
        var priorityLevel = _currentGoal?.Priority ?? 0;

        HashSet<AgentGoal> goalsToCheck = _goals;

        // If we have a current goal, we only want to check goals with higher priority
        if (_currentGoal != null)
        {
            Debug.Log("GOAP: Current goal exists, checking goals with higher priority");
            goalsToCheck = new HashSet<AgentGoal>(_goals.Where(g => g.Priority > priorityLevel));
        }

        var potentialPlan = _gPlanner.Plan(_actions, goalsToCheck, _lastGoal);
        if (potentialPlan != null)
        {
            _actionPlan = potentialPlan;
        }
    }

    public void ResetActionAndGoal()
    {
        // Forces the planner to re-evaluate the plan
        _currentAction = null;
        _currentGoal = null;
    }

    private void LogPreconditions()
    {
        foreach (var precondition in _currentAction.Preconditions)
        {
            Debug.Log($"GOAP: Precondition: {precondition.Name} - {precondition.Evaluate()}");
        }
    }

    private void LogGoap(string logMessage)
    {
        if (!_logGoap)
            return;

        Debug.Log(logMessage);
    }
}
```

```WorldSystems\GoapAI\Pillars\IGoapAgent.cs
using System.Collections.Generic;
using System.Linq;
using AYellowpaper.SerializedCollections;
using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(GoapAnimationMapper))]
public abstract class IGoapAgent : MonoBehaviour
{
    // goap
    protected Dictionary<string, AgentBelief> Beliefs;
    protected HashSet<AgentAction> Actions;
    protected HashSet<AgentGoal> Goals;
    
    private GoapRunner _gRunner;
    protected GoapAnimator GAnimator;

    [SerializeField] protected bool goapAgentEnabled = true;
    
    // values
    [SerializeField] protected bool logAgent;
    
    // goap functions
    protected abstract void SetupBeliefs();
    protected abstract void SetupActions();
    protected abstract void SetupGoals();
    
    // optional functions
    protected virtual void UpdateStats() {}
    protected virtual void OnStart() {}
    
    // references from the user
    [SerializedDictionary] public SerializedDictionary<string, Sensor> Sensors;
    [SerializedDictionary] public SerializedDictionary<string, Transform> Locations;
    
    // components
    private GoapAnimationMapper _animationMapper;
    private CountdownTimer _goapTimer;
    protected NavMeshAgent AgentNavmesh;
    protected Rigidbody Rb;
    
    // MonoBehaviour functions
    private void Awake()
    {
        var animator = GetComponent<Animator>();
        var animationMapper = GetComponent<GoapAnimationMapper>();
        AgentNavmesh = GetComponent<NavMeshAgent>();
        Rb = GetComponent<Rigidbody>();
        if (Rb != null)
            Rb.freezeRotation = true;
        
        _gRunner = new GoapRunner(Beliefs, Actions, Goals, PreActionReset, logAgent);
        GAnimator = new GoapAnimator(animator, animationMapper);
    }
    
    private void Start()
    {
        OnStart();
        SetupTimers();
        SetupBeliefs();
        SetupActions();
        SetupGoals();
        
        // update runner after settingup goap stuff
        _gRunner.UpdateRunner(Beliefs, Actions, Goals);

        // subscribe to sensor detection event
        foreach (var sensor in Sensors.Values.Where(sensor => sensor.ResetGoapOnTargetChange))
            sensor.OnTargetChanged += ResetActionAndGoal;
    }
    
    protected void Update()
    {
        // update timers
        _goapTimer.Tick(Time.deltaTime);
        GAnimator.UpdateAnimationsTimer(Time.deltaTime);
        
        // don't control the agent if disabled.
        if (!goapAgentEnabled)
            return;
        
        // tell goap system to find what to do next or perform current action.
        _gRunner.Perform();
    }

    private void OnDestroy()
    {
        // Unsubscribe from sensor detection event
        foreach (var sensor in Sensors.Values.Where(sensor => sensor.ResetGoapOnTargetChange))
            sensor.OnTargetChanged -= ResetActionAndGoal;
    }

    // helper functions
    public void ResetActionAndGoal()
    {
        _gRunner.ResetActionAndGoal();
    }
    
    void SetupTimers()
    {
        _goapTimer = new CountdownTimer(2f);
        _goapTimer.OnTimerStop += () =>
        {
            UpdateStats();
            _goapTimer.Start();
        };
        _goapTimer.Start();
    }
    
    // this will happen before a new action occurs
    protected virtual void PreActionReset()
    {
        AgentNavmesh?.ResetPath();
    }

    public void EnableGoap()
    {
        goapAgentEnabled = true;
    }

    public void DisableGoap()
    {
        ResetActionAndGoal();
        AgentNavmesh?.ResetPath();
        
        goapAgentEnabled = false;
    }

    public void StopGoap()
    {
        goapAgentEnabled = false;
    }

    public bool IsEnabled()
    {
        return goapAgentEnabled;
    }
}
```

```WorldSystems\GoapAI\Pillars\Sensor.cs
using System;
using UnityEngine;

[RequireComponent(typeof(SphereCollider))]
public class Sensor : MonoBehaviour
{
    [SerializeField] private string detectionTag = "Player";
    [SerializeField] private float detectionRadius = 5f;
    [SerializeField] private float timerInterval = 1f;
    [SerializeField] private Color sensorColor = Color.green;
    public bool ResetGoapOnTargetChange = true;

    private SphereCollider _detectionRange;

    public event Action OnTargetChanged = delegate { };

    public Vector3 TargetPosition => _target ? _target.transform.position : Vector3.zero;
    public bool IsTargetInRange => TargetPosition != Vector3.zero;

    private GameObject _target;
    private Vector3 _lastKnownPosition;
    private CountdownTimer _timer;


    private void Awake()
    {
        _detectionRange = GetComponent<SphereCollider>();
        _detectionRange.isTrigger = true;
        _detectionRange.radius = detectionRadius;
        transform.localScale = Vector3.one;
    }

    private void Start()
    {
        _timer = new CountdownTimer(timerInterval);
        _timer.OnTimerStop += () =>
        {
            UpdateTargetPosition(_target.OrNull());
            _timer.Start();
        };
        _timer.Start();
    }

    private void Update()
    {
        _timer.Tick(Time.deltaTime);
    }

    private void UpdateTargetPosition(GameObject target = null)
    {
        _target = target;
        
        if (IsTargetInRange && (_lastKnownPosition != TargetPosition || _lastKnownPosition != Vector3.zero))
        {
            _lastKnownPosition = TargetPosition;
            OnTargetChanged.Invoke();
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!other.CompareTag(detectionTag)) return;
        UpdateTargetPosition(other.gameObject);
    }

    private void OnTriggerExit(Collider other)
    {
        if (!other.CompareTag(detectionTag)) return;
        UpdateTargetPosition();
    }

    private void OnDrawGizmos()
    {
        Gizmos.color = IsTargetInRange ? Color.red : sensorColor;
        Gizmos.DrawWireSphere(transform.position, detectionRadius);
    }
}
```

```WorldSystems\GoapAI\Pillars\Strategies.cs
using System;
using UnityEngine;
using UnityEngine.AI;

public interface IActionStrategy
{
    bool CanPerform { get; }
    bool Complete { get; }

    void Start()
    {
        
    }

    void Update(float deltaTime)
    {

    }

    void Stop()
    {

    }
}

public class IdleStrategy : IActionStrategy
{
    public bool CanPerform => true;
    public bool Complete { get; private set; }

    private readonly CountdownTimer _timer;

    public IdleStrategy(float duration)
    {
        _timer = new CountdownTimer(duration);
        _timer.OnTimerStart += () => Complete = false;
        _timer.OnTimerStop += () => Complete = true;
    }

    public void Start() => _timer.Start();
    public void Update(float deltaTime) => _timer.Tick(deltaTime);
}

public class WanderStrategy : IActionStrategy
{
    private readonly NavMeshAgent _agent;
    private readonly float _wanderRadius;

    public bool CanPerform => !Complete;
    public bool Complete => _agent.remainingDistance <= 2f && !_agent.pathPending;

    public WanderStrategy(NavMeshAgent agent, float wanderRadius)
    {
        _agent = agent;
        _wanderRadius = wanderRadius;
    }

    public void Start()
    {
        for (int i = 0; i < 5; i++)
        {
            Vector3 randomDirection = (UnityEngine.Random.insideUnitSphere * _wanderRadius).With(y: 0);
            NavMeshHit hit;

            if (NavMesh.SamplePosition(_agent.transform.position + randomDirection, out hit, _wanderRadius, 1))
            {
                _agent.SetDestination(hit.position);
                return;
            }
        }
    }
}

public class MoveStrategy : IActionStrategy
{
    private readonly NavMeshAgent _agent;
    private readonly Func<Vector3> _destination;
    private readonly GoapAnimator _goapAnimator;
    private readonly Action _onComplete;

    public bool CanPerform => !Complete;
    public bool Complete => _agent is { remainingDistance: <= 1f, pathPending: false };

    public MoveStrategy(
        NavMeshAgent agent,
        Func<Vector3> destination,
        GoapAnimator goapAnimator,
        Action onComplete = null)
    {
        _agent = agent;
        _destination = destination;
        _goapAnimator = goapAnimator;
        _onComplete = onComplete;
    }

    public void Start()
    {
        _agent.SetDestination(_destination());
    }

    public void Update(float deltaTime)
    {
        _goapAnimator.SetBool("IsMoving", _agent.velocity.sqrMagnitude >= 0.04f);
        _goapAnimator.SetFloat("Speed", _agent.velocity.magnitude);
    }

    public void Stop()
    {
        _goapAnimator.SetBool("IsMoving", false);
        _onComplete?.Invoke();
        _agent.ResetPath();
    }
}

public class ChaseStrategy : IActionStrategy
{
    private readonly NavMeshAgent _agent;
    private readonly Func<Vector3> _destination;

    public bool CanPerform => !Complete;
    public bool Complete => _agent.remainingDistance <= 1f && !_agent.pathPending;
    public Action OnComplete = null;

    public ChaseStrategy(NavMeshAgent agent, Func<Vector3> destination, Action onComplete = null)
    {
        _agent = agent;
        _destination = destination;
        OnComplete = onComplete;
    }

    public void Start()
    {
        _agent.SetDestination(_destination());
    }

    public void Stop()
    {
        if (OnComplete != null)
            OnComplete();
        _agent.ResetPath();
    }
}

public class AttackStrategy : IActionStrategy
{
    private readonly string _animationNameFromMapper;
    public bool CanPerform => true;
    public bool Complete { get; private set; }

    private readonly CountdownTimer _timer;
    private readonly GoapAnimator _goapAnimator;
    
    public AttackStrategy(GoapAnimator goapAnimator)
    {
        _animationNameFromMapper = goapAnimator.AnimationMapper.Fight;
        _goapAnimator = goapAnimator;
        Complete = false;
    }

    public void Start()
    {
        _goapAnimator.TriggerAnimationUsingTimer(_animationNameFromMapper, "Attack", () => Complete = true);
    }
}
public class DanceStrategy : IActionStrategy
{
    public bool CanPerform => true;
    public bool Complete { get; private set; }

    private readonly string _animationNameFromMapper;
    private readonly GoapAnimator _goapAnimator;

    public DanceStrategy(GoapAnimator goapAnimator)
    {
        _animationNameFromMapper = goapAnimator.AnimationMapper.Dance;
        _goapAnimator = goapAnimator;
        Complete = false;
    }

    public void Start()
    {
        _goapAnimator.CrossplayAnimationUsingTimer(_animationNameFromMapper, () => Complete = true);
    }
}

public class WaitUntilBeliefFalseStrategy : IActionStrategy
{
    private readonly AgentBelief _waitingBelief;
    public bool CanPerform => true;

    public bool Complete { get; private set; }

    public WaitUntilBeliefFalseStrategy(AgentBelief beleif)
    {
        _waitingBelief = beleif;
        Complete = false;
    }

    public void Start()
    {
        // Initialize any necessary state
        Complete = false;
    }

    public void Update(float deltaTime)
    {
        // Keep waiting as long as the player is in cashier range
        if (!_waitingBelief.Evaluate())
        {
            Complete = true;
        }
    }
}

public class LookAtStrategy : IActionStrategy
{
    private readonly Func<Vector3> _lookAtPosition;
    private readonly Transform _transform;
    private readonly float _rotationSpeed;

    public bool CanPerform => !Complete;
    public bool Complete { get; private set; }
    public Action OnComplete = null;

    public LookAtStrategy(Transform agentTransform, Func<Vector3> lookAtPosition, float rotationSpeed = 5f, Action onComplete = null)
    {
        _transform = agentTransform;
        _lookAtPosition = lookAtPosition;
        _rotationSpeed = rotationSpeed;
        OnComplete = onComplete;
    }

    public void Start()
    {
        Complete = false;
    }

    public void Update(float deltaTime)
    {
        Vector3 destination = _lookAtPosition();
        Vector3 direction = (destination - _transform.position).With(y: 0f);

        if (direction.sqrMagnitude < 0.001f) return;

        Quaternion targetRotation = Quaternion.LookRotation(direction.normalized);
        _transform.rotation = Quaternion.RotateTowards(
            _transform.rotation, targetRotation, _rotationSpeed * deltaTime * 100f);

        // Mark complete when mostly facing the target
        float angle = Quaternion.Angle(_transform.rotation, targetRotation);
        if (angle < 5f)
        {
            Complete = true;
            OnComplete?.Invoke();
        }
    }

    public void Stop()
    {
        OnComplete?.Invoke();
    }
}
```

```WorldSystems\SegmentGenerator\Segment.cs
using UnityEngine;

public class Segment : MonoBehaviour
{
    public Transform EntrancePoint;
    public Transform ExitPoint;

    public virtual void OnSegmentSpawned(Transform previousSegment)
    {
        
    }
}
```

```WorldSystems\SegmentGenerator\SegmentEntranceTrigger.cs
using UnityEngine;

public class SegmentEntranceTrigger : MonoBehaviour
{
    private Segment _parentSegment;
    private bool _segmentActivated;

    private void Start()
    {
        _parentSegment = gameObject.GetComponentInParent<Segment>();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!other.CompareTag("Player"))
            return;

        if (_segmentActivated)
            return;

        SegmentStreamer.Instance.SpawnRandomSegment(_parentSegment.ExitPoint);

        _segmentActivated = true;
        gameObject.SetActive(false);
    }
}
```

```WorldSystems\SegmentGenerator\SegmentStreamer.cs
using UnityEngine;

[RequireComponent(typeof(SegmentStreamingAlgorithm))]
public class SegmentStreamer : MonoBehaviour
{
    // A simple Singleton approach for easy access
    public static SegmentStreamer Instance;
    private SegmentStreamingAlgorithm _segmentStreamingAlgorithm;

    private void Awake()
    {
        // Basic singleton check
        if (Instance == null)
        {
            Instance = this;
            _segmentStreamingAlgorithm = GetComponent<SegmentStreamingAlgorithm>();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Spawns a random segment at the Exit Point (Connected to the Entry Point)
    /// </summary>
    /// <param name="exitTransform">Old segment's Exit, Where we want to align the new segment's entrance.</param>
    public void SpawnRandomSegment(Transform exitTransform)
    {
        // Pick one segment prefab randomly
        Segment chosenSegmentPrefab = _segmentStreamingAlgorithm.GenerateSegment();
        if (chosenSegmentPrefab == null)
        {
            Debug.LogError("Error choosing a segment to spawn!\n" +
                           "spawning nothing.");
            return;
        }

        // Instantiate the new segment
        Segment newSegment = Instantiate(chosenSegmentPrefab);

        // Find the 'Entrance' transform inside the new segment (so we can align it correctly)
        Transform entrance = newSegment.EntrancePoint;
        if (entrance != null)
        {
            // Align rotation first
            var deltaRot = Quaternion.Inverse(entrance.rotation) * newSegment.transform.rotation;
            newSegment.transform.rotation = exitTransform.rotation * deltaRot;
            
            // We want the segment's 'Entrance' to match up exactly with the spawnTransform's position
            Vector3 offset = newSegment.transform.position - entrance.position;
            newSegment.transform.position = exitTransform.position + offset;

            // turn off the exit transform
            exitTransform.gameObject.SetActive(false);
            
            newSegment.OnSegmentSpawned(exitTransform.parent);
        }
        else
        {
            Debug.LogWarning("No Entrance transform found in the newly spawned segment. " +
                             "Make sure your segment prefab has a child named 'Entrance'!");
        }
    }
}
```

```WorldSystems\SegmentGenerator\StreamingAlgorithms\MilestoneUnlockAlgorithm.cs
using System;
using UnityEngine;
using Random = UnityEngine.Random;

public class MilestoneUnlockAlgorithm : SegmentStreamingAlgorithm
{
    [SerializeField] private MilestoneSegment[] segments;
    [SerializeField] private int countSpawnedSegments;

    private Segment PickRandom(Segment[] arr) => arr[Random.Range(0, arr.Length)];

    public override Segment GenerateSegment()
    {
        if (segments == null || segments.Length == 0) { return null; }
        
        // find the highest milestone we can create segments from
        MilestoneSegment chosenMilestone = segments[0];
        foreach (var milestone in segments)
        {
            if (countSpawnedSegments > milestone.MilestoneToActivate)
                chosenMilestone = milestone;
        }
        
        Debug.Log(chosenMilestone.Name);
        countSpawnedSegments++;
        return PickRandom(chosenMilestone.AvailableSegments);
    }
}

[Serializable]
public class MilestoneSegment
{
    public string Name;
    public int MilestoneToActivate;
    public Segment[] AvailableSegments;
}
```

```WorldSystems\SegmentGenerator\StreamingAlgorithms\RandomSegmentAlgorithm.cs
using UnityEngine;

public class RandomSegmentAlgorithm : SegmentStreamingAlgorithm
{
    [SerializeField] private Segment[] segments;
    
    public override Segment GenerateSegment()
    {
        if (segments == null || segments.Length == 0)
            return null;
        
        int randomIndex = Random.Range(0, segments.Length);
        return segments[randomIndex];
    }
}
```

```WorldSystems\SegmentGenerator\StreamingAlgorithms\SegmentStreamingAlgorithm.cs
using UnityEngine;

public abstract class SegmentStreamingAlgorithm : MonoBehaviour
{
    public virtual Segment GenerateSegment() { return null; }
}
```

```WorldSystems\Shops\Shop.cs
using System.Collections.Generic;
using UnityEngine;

public class Shop : MonoBehaviour, Interactable
{
    public string ShopName;
    public List<ShopItem> ShopItems;
    [HideInInspector] public bool ShopOpen;
    public string InteractableType { get; set; }

    private void Start()
    {
        ShopOpen = false;
    }

    public void MarkAsInteractable()
    {
        
    }

    public void Interact()
    {
        if (ShopOpen)
            return;

        ShopOpen = true;

        OpenShopUI();
    }

    private void OpenShopUI()
    {
        ShopManager.instance.OpenShop(ShopName);
    }


}
```

```WorldSystems\Shops\ShopItem.cs
using UnityEngine;

[CreateAssetMenu(menuName ="Zero/ShopItem", fileName ="ShopItem")]
public class ShopItem : ScriptableObject
{
    public string ItemName;
    public int ItemPrice;
    public Sprite ItemDisplayImage;
    public Sprite ItemPreviewImage;
    public bool Sold = false;
}
```

```WorldSystems\Shops\ShopManager.cs
using AYellowpaper.SerializedCollections;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;

public class ShopManager : MonoBehaviour
{
    public static ShopManager instance;
    
    [Header("Spawning")]
    [SerializedDictionary("string", "Shop")]
    public Dictionary<string, Shop> Shops = new();

    [Header("Displaying")]
    [SerializeField] private GameObject ShopUI;
    [SerializeField] private GameObject ShopPreviewUI;
    [SerializeField] private GameObject ShopCardsHolder;
    [SerializeField] private GameObject ShopCard;
    [SerializeField] private GameObject ShopItemPrice;

    private string currentlyOpenShop;

    private void Start()
    {
        if (instance != null && instance != this)
        {
            Destroy(gameObject);
            return;
        }
        else
            instance = this;

        DontDestroyOnLoad(gameObject);

        SetupShops();
    }

    private void SetupShops()
    {
        Shop[] foundShops = FindObjectsByType<Shop>(FindObjectsSortMode.None);

        Shops.Clear();

        foreach (Shop shop in foundShops)
        {
            if (!Shops.ContainsKey(shop.ShopName))
                Shops.Add(shop.ShopName, shop);
            else
                Debug.LogError("Duplicate shop: " + shop.ShopName);
        }
    }

    public void OpenShop(string shopName)
    {
        // Disable Player
        InputDirector.Instance.DisableInput();
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;

        // Enable Shop UI
        ShopUI.SetActive(true);
        currentlyOpenShop = shopName;

        // Clean UI
        foreach (Transform item in ShopCardsHolder.transform)
        {
            Debug.Log(item.name);
            item.parent = null;
            Destroy(item.gameObject);
        }

        // Force layout rebuild
        LayoutRebuilder.ForceRebuildLayoutImmediate(ShopCardsHolder.GetComponent<RectTransform>());

        Image previewImage = ShopPreviewUI.GetComponent<Image>();
        previewImage.sprite = null;
        Color imageColor = previewImage.color;
        imageColor.a = 0f;
        previewImage.color = imageColor;
        ShopItemPrice.GetComponent<TextMeshProUGUI>().text = "-";

        // Place new shop cards
        Shop shopToPopulate;
        if (!Shops.TryGetValue(shopName, out shopToPopulate))
            return;

        foreach (ShopItem item in shopToPopulate.ShopItems)
        {
            GameObject newCard = Instantiate(ShopCard, ShopCardsHolder.transform);

            newCard.GetComponentsInChildren<Image>()[1].sprite = item.ItemDisplayImage;
            newCard.GetComponentInChildren<TextMeshProUGUI>().text = item.ItemName;

            Button cardButton = newCard.GetComponent<Button>();
            if (cardButton != null)
                cardButton.onClick.AddListener(() => SelectItem(item));
        }
    }

    public void SelectItem(ShopItem item)
    {
        Image previewImage = ShopPreviewUI.GetComponent<Image>();
        previewImage.sprite = item.ItemPreviewImage;
        Color imageColor = previewImage.color;
        imageColor.a = 255f;
        previewImage.color = imageColor;

        ShopItemPrice.GetComponent<TextMeshProUGUI>().text = item.ItemPrice.ToString();
    }

    public void CloseShop()
    {
        ShopUI.SetActive(false);

        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
        InputDirector.Instance.EnableInput();
        Shops[currentlyOpenShop].ShopOpen = false;
    }
}
```

```YonderExtras\YieldedScripts\Multiplayer\ExtensionMultiplayer.cs
#if FISHNET
using FishNet.Connection;
using FishNet.Object;
#endif
using System;
using FishNet;
using UnityEngine;

public class ExtensionMultiplayer : NetworkBehaviour, IPlayerBehavior
{
    [TargetRpc]
    public void SetupTPSPlayerRpc(NetworkConnection conn)
    {
        // give authority
        var player = GetComponent<Player>();
        player.PlayerId = OwnerId;
        player.SetAuthority(true);
        player.EnablePlayerBehaviors();
        
        // Load State
        player.Awake();
        player.OnEnable();
        player.Start();
        
        player.SwapPlayerState<cc_tpState, TP_CameraState>();
    }
}
```

```YonderExtras\YieldedScripts\Multiplayer\MultiplayerManager.cs
using FishNet.Connection;
using UnityEngine;

#if FISHNET
using FishNet;
using FishNet.Managing;
using FishNet.Object;
using FishNet.Transporting;
using UnityEngine.Events;
#endif

public class MultiplayerManager : NetworkBehaviour
{
#if FISHNET
    #region Singleton
    
    public static MultiplayerManager Instance;
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }

        networkManager = InstanceFinder.NetworkManager;
    }

    #endregion
    
    [SerializeField] private NetworkManager networkManager;
    
    /// <summary> Runs only on the Server </summary>
    public UnityAction<NetworkConnection> OnClientConnected;
    /// <summary> Runs only on the Server </summary>
    public UnityAction<NetworkConnection> OnClientDisconnected; 
    
    #region StartStop

    
    public void StartHost()
    {
        networkManager.ServerManager.StartConnection();
        networkManager.ClientManager.StartConnection();
    }

    public void StartServer()
    {
        networkManager.ServerManager.StartConnection();
    }

    public void JoinAsClient(string address = "localhost")
    {
        networkManager.ClientManager.StartConnection(address);
    }

    public void Leave()
    {
        networkManager.ClientManager.StopConnection();
        networkManager.ServerManager.StopConnection(false);
    }

    #endregion

    #region MultiplayerEvents
    
    private void OnEnable()
    {
        networkManager.ServerManager.OnRemoteConnectionState += RemoteConnectionChanged;
    }

    private void RemoteConnectionChanged(NetworkConnection connection, RemoteConnectionStateArgs args)
    {
        if (!networkManager.IsServerStarted)
            return;
        
        switch (args.ConnectionState)
        {
            case RemoteConnectionState.Started:
                Debug.Log("New Player Connected");
                connection.OnLoadedStartScenes += ConnectionSceneLoaded;
                break;
            case RemoteConnectionState.Stopped:
                Debug.Log("Player Disconnected");
                connection.OnLoadedStartScenes -= ConnectionSceneLoaded;
                OnClientDisconnected?.Invoke(connection);
                break;
        }
    }

    private void ConnectionSceneLoaded(NetworkConnection connection, bool isServer)
    {
        if (!isServer)
            return;
        
        OnClientConnected?.Invoke(connection);
    }

    private void OnDisable()
    {
        networkManager.ServerManager.OnRemoteConnectionState -= RemoteConnectionChanged;
    }

    #endregion

    #region MultiplayerFunctions

    public Player SpawnPlayer(
        NetworkConnection clientConnection,
        NetworkObject playerPrefab,
        Vector3 position,
        Quaternion rotation)
    {
        if (playerPrefab == null || clientConnection == null) return null;
        Debug.Log($"Spawning Player for client {clientConnection.ClientId}");

        NetworkObject spawnedPlayer = Instantiate(playerPrefab, position, rotation);
        networkManager.ServerManager.Spawn(spawnedPlayer, clientConnection);
        
        // Authority is given locally.

        return spawnedPlayer.GetComponent<Player>();
    }

    public void DespawnPlayer(Player player)
    {
        if (player == null) return;
        Debug.Log($"Despawning Player for client {player.PlayerId}");
        
        networkManager.ServerManager.Despawn(player.gameObject);
    }
    
    #endregion
    
#endif
}
```

```YonderExtras\YieldedScripts\Multiplayer\MultiplayerStoryExample.cs
using FishNet.Connection;
using FishNet.Object;
using UnityEngine;

public class MultiplayerStoryExample : NetworkBehaviour
{
    [SerializeField] private NetworkObject playerPrefab;
    [SerializeField] private Transform spawnPoint;
    private MultiplayerManager _mm;

    private void Start()
    {
        _mm = MultiplayerManager.Instance;
        _mm.OnClientConnected += OnClientConnected;
        _mm.OnClientDisconnected += OnClientDisconnected;
    }

    private void OnDestroy()
    {
        _mm.OnClientConnected -= OnClientConnected;
        _mm.OnClientDisconnected -= OnClientDisconnected;
    }

    private void OnClientConnected(NetworkConnection connection)
    {
        var spawnedPlayer = _mm.SpawnPlayer(
            connection,
            playerPrefab,
            spawnPoint.position,
            Quaternion.identity);
        
        spawnedPlayer.PlayerId = connection.ClientId;
        
        spawnedPlayer.GetComponent<ExtensionMultiplayer>().SetupTPSPlayerRpc(connection);
    }

    private void OnClientDisconnected(NetworkConnection connection)
    {
        var players = FindObjectsByType<Player>(FindObjectsSortMode.InstanceID);
        
        foreach (var player in players)
        {
            if (player.PlayerId != connection.ClientId)
                continue;
            
            _mm.DespawnPlayer(player);
            return;
        }
    }
}
```

```YonderExtras\YieldedScripts\Multiplayer\Helpers\HueClones.cs
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using ParrelSync;

[InitializeOnLoad]
public static class HueClones
{
    // Very subtle, I chose colors with this website https://rgbcolorpicker.com/0-1
    static readonly Color CloneHue = new (0.851f, 0f, 1f  , 0.05f);

    static HueClones()
    {
        SceneView.duringSceneGui += OnSceneGUI;
        EditorApplication.delayCall += RepaintAll;
    }

    static void OnSceneGUI(SceneView view)
    {
        DrawOverlay();
    }

    static void DrawOverlay()
    {
        if (!ClonesManager.IsClone())
            return;

        Handles.BeginGUI();
        EditorGUI.DrawRect(
            new Rect(0, 0, Screen.width, Screen.height),
            CloneHue
        );
        Handles.EndGUI();
    }

    static void RepaintAll()
    {
        SceneView.RepaintAll();
    }
}
#endif
```

```YonderExtras\YieldedScripts\ObjectExtensions\GameObjectExtensions.cs
using UnityEngine;
using System.Linq;

// See https://github.com/adammyhre/Unity-Utils for more extension methods
public static class GameObjectExtensions {
    /// <summary>
    /// Returns the object itself if it exists, null otherwise.
    /// </summary>
    /// <remarks>
    /// This method helps differentiate between a null reference and a destroyed Unity object. Unity's "== null" check
    /// can incorrectly return true for destroyed objects, leading to misleading behaviour. The OrNull method use
    /// Unity's "null check", and if the object has been marked for destruction, it ensures an actual null reference is returned,
    /// aiding in correctly chaining operations and preventing NullReferenceExceptions.
    /// </remarks>
    /// <typeparam name="T">The type of the object.</typeparam>
    /// <param name="obj">The object being checked.</param>
    /// <returns>The object itself if it exists and not destroyed, null otherwise.</returns>
    public static T OrNull<T>(this T obj) where T : Object => obj ? obj : null;
}
```

```YonderExtras\YieldedScripts\ObjectExtensions\Vector3Extensions.cs
using UnityEngine;

// See https://github.com/adammyhre/Unity-Utils for more extension methods
public static class Vector3Extensions {
    /// <summary>
    /// Sets any x y z values of a Vector3
    /// </summary>
    public static Vector3 With(this Vector3 vector, float? x = null, float? y = null, float? z = null) {
        return new Vector3(x ?? vector.x, y ?? vector.y, z ?? vector.z);
    }
}
```

```YonderExtras\YieldedScripts\Timer\Timer.cs
using System;

public abstract class Timer {
    protected float initialTime;
    public float Time { get; set; }
    public bool IsRunning { get; protected set; }

    public float Progress => Time / initialTime;

    public Action OnTimerStart = delegate { };
    public Action OnTimerStop = delegate { };

    protected Timer(float value) {
        initialTime = value;
        IsRunning = false;
    }

    public void Start() {
        Time = initialTime;
        if (!IsRunning) {
            IsRunning = true;
            OnTimerStart.Invoke();
        }
    }

    public void Stop() {
        if (IsRunning) {
            IsRunning = false;
            OnTimerStop.Invoke();
        }
    }

    public void Resume() => IsRunning = true;
    public void Pause() => IsRunning = false;

    public abstract void Tick(float deltaTime);
}

public class CountdownTimer : Timer {
    public CountdownTimer(float value) : base(value) { }

    public override void Tick(float deltaTime) {
        if (IsRunning && Time > 0) {
            Time -= deltaTime;
        }

        if (IsRunning && Time <= 0) {
            Stop();
        }
    }

    public bool IsFinished => Time <= 0;

    public void Reset() => Time = initialTime;

    public void Reset(float newTime) {
        initialTime = newTime;
        Reset();
    }
}

public class StopwatchTimer : Timer {
    public StopwatchTimer() : base(0) { }

    public override void Tick(float deltaTime) {
        if (IsRunning) {
            Time += deltaTime;
        }
    }

    public void Reset() => Time = 0;

    public float GetTime() => Time;
}
```

```zOverallAssets\Decals\DecalColliderSync.cs
using UnityEngine;
using UnityEngine.Rendering.Universal;

[ExecuteAlways]
public class DecalColliderSync : MonoBehaviour
{
    public BoxCollider TargetCollider; // assign your child BoxCollider in the Inspector
    public Vector3 Padding = new Vector3(0.001f, 0.001f, 0.001f); // tiny pad to avoid clipping

    private void Reset()
    {
        if (TargetCollider == null) TargetCollider = GetComponentInChildren<BoxCollider>();
    }

    private void LateUpdate()
    {
        var projector = GetComponent<DecalProjector>();
        if (!projector || !TargetCollider) return;

        // URP DecalProjector exposes size (Width, Height, Depth) as a Vector3
        Vector3 size = projector.size + Padding;
        TargetCollider.size = size;

        // Keep the collider centered on the projector pivot
        // Child collider Transform should be localPosition = projector.pivot
        TargetCollider.transform.localPosition = projector.pivot;
        TargetCollider.transform.localRotation = Quaternion.identity;
        TargetCollider.transform.localScale = Vector3.one;
    }
}
```

```zOverallAssets\Fonts\Editor\Fnt2TMPro\CustomFntParse.cs
using UnityEngine;
using System.Xml;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace litefeelcustom
{
    public struct Kerning
    {
        public int first;
        public int second;
        public int amount;
    }

    public class RawCharacterInfo
    {
        public int ID, X, Y, Width, Height, Xoffset, Yoffset, Xadvance, Page;
        public RawCharacterInfo(int id, int x, int y, int width, int height, int xoffset, int yoffset, int xadvance, int page)
        {
            ID = id;
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Xoffset = xoffset;
            Yoffset = yoffset;
            Xadvance = xadvance;
            Page = page;
        }
    }


    public class FntParse
    {
        public int textureWidth;
        public int textureHeight;
        public string[] textureNames;

        public string fontName;
        public int fontSize;
        public int lineHeight;
        public int lineBaseHeight;

        public CharacterInfo[] charInfos { get; private set; }

        public RawCharacterInfo[] rawCharInfos { get; private set; }
        public Kerning[] kernings { get; private set; }

        public static FntParse GetFntParse(ref string text)
        {
            FntParse parse = null;
            if (text.StartsWith("info"))
            {
                parse = new FntParse();
                parse.DoTextParse(ref text);
            }
            else if (text.StartsWith("<"))
            {
                parse = new FntParse();
                parse.DoXMLPase(ref text);
            }
            return parse;
        }

        #region xml
        public void DoXMLPase(ref string content)
        {
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(content);

            XmlNode info = xml.GetElementsByTagName("info")[0];
            XmlNode common = xml.GetElementsByTagName("common")[0];
            XmlNodeList pages = xml.GetElementsByTagName("pages")[0].ChildNodes;
            XmlNodeList chars = xml.GetElementsByTagName("chars")[0].ChildNodes;


            fontName = info.Attributes.GetNamedItem("face").InnerText;
            fontSize = ToInt(info, "size");

            lineHeight = ToInt(common, "lineHeight");
            lineBaseHeight = ToInt(common, "base");
            textureWidth = ToInt(common, "scaleW");
            textureHeight = ToInt(common, "scaleH");
            int pageNum = ToInt(common, "pages");
            textureNames = new string[pageNum];

            for (int i = 0; i < pageNum; i++)
            {
                XmlNode page = pages[i];
                int pageId = ToInt(page, "id");
                textureNames[pageId] = page.Attributes.GetNamedItem("file").InnerText;
            }

            charInfos = new CharacterInfo[chars.Count];
            rawCharInfos = new RawCharacterInfo[chars.Count];

            for (int i = 0; i < chars.Count; i++)
            {
                XmlNode charNode = chars[i];
                charInfos[i] = CreateCharInfo(
                    ToInt(charNode, "id"),
                    ToInt(charNode, "x"),
                    ToInt(charNode, "y"),
                    ToInt(charNode, "width"),
                    ToInt(charNode, "height"),
                    ToInt(charNode, "xoffset"),
                    ToInt(charNode, "yoffset"),
                    ToInt(charNode, "xadvance"),
                    ToInt(charNode, "page"));
                rawCharInfos[i] = new RawCharacterInfo(
                    ToInt(charNode, "id"),
                    ToInt(charNode, "x"),
                    ToInt(charNode, "y"),
                    ToInt(charNode, "width"),
                    ToInt(charNode, "height"),
                    ToInt(charNode, "xoffset"),
                    ToInt(charNode, "yoffset"),
                    ToInt(charNode, "xadvance"),
                    ToInt(charNode, "page")
                );
            }

            // kernings
            XmlNode kerningsNode = xml.GetElementsByTagName("kernings")[0];
            if (kerningsNode != null && kerningsNode.HasChildNodes)
            {
                XmlNodeList kerns = kerningsNode.ChildNodes;
                kernings = new Kerning[kerns.Count];
                for (int i = 0; i < kerns.Count; i++)
                {
                    XmlNode kerningNode = kerns[i];
                    kernings[i] = new Kerning();
                    kernings[i].first = ToInt(kerningNode, "first");
                    kernings[i].second = ToInt(kerningNode, "second");
                    kernings[i].amount = ToInt(kerningNode, "amount");
                }
            }
        }


        private static int ToInt(XmlNode node, string name)
        {
            return int.Parse(node.Attributes.GetNamedItem(name).InnerText);
        }
        #endregion

        #region text
        private Regex pattern;
        public void DoTextParse(ref string content)
        {
            // letter=" "       // \S+=".+?"
            // letter="x"       // \S+=".+?"
            // letter="""       // \S+=".+?"
            // letter=""        // \S+
            // char             // \S+
            pattern = new Regex(@"\S+="".+?""|\S+");
            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            ReadTextInfo(ref lines[0]);
            ReadTextCommon(ref lines[1]);

            for (int j = 0; j < textureNames.Length; j++)
            {
                ReadTextPage(ref lines[j + 2]);
            }

            // don't use count of chars, count is incorrect if has space 
            //ReadTextCharCount(ref lines[3]);
            List<CharacterInfo> list = new List<CharacterInfo>();
            List<RawCharacterInfo> rlist = new List<RawCharacterInfo>();
            int i = 2 + textureNames.Length;
            int l = lines.Length;
            for (; i < l; i++)
            {
                if (!ReadTextChar(i - 4, ref lines[i], ref list, ref rlist))
                    break;
            }
            charInfos = list.ToArray();
            rawCharInfos = rlist.ToArray();

            // skip empty line
            for (; i < l; i++)
            {
                if (lines[i].Length > 0)
                    break;
            }

            // kernings
            if (i < l)
            {
                int count = 0;
                if (ReadTextCount(ref lines[i++], out count))
                {
                    int start = i;
                    kernings = new Kerning[count];
                    for (; i < l; i++)
                    {
                        if (!ReadTextKerning(i - start, ref lines[i], ref list))
                            break;
                    }
                };
            }
        }

        private void ReadTextInfo(ref string line)
        {
            string[] keys;
            string[] values;
            SplitParts(line, out keys, out values);
            for (int i = keys.Length - 1; i >= 0; i--)
            {
                switch (keys[i])
                {
                    case "face": fontName = values[i]; break;
                    case "size": fontSize = int.Parse(values[i]); break;
                }
            }
        }

        private void ReadTextCommon(ref string line)
        {
            string[] keys;
            string[] values;
            SplitParts(line, out keys, out values);
            for (int i = keys.Length - 1; i >= 0; i--)
            {
                switch (keys[i])
                {
                    case "lineHeight": lineHeight = int.Parse(values[i]); break;
                    case "base": lineBaseHeight = int.Parse(values[i]); break;
                    case "scaleW": textureWidth = int.Parse(values[i]); break;
                    case "scaleH": textureHeight = int.Parse(values[i]); break;
                    case "pages": textureNames = new string[int.Parse(values[i])]; break;
                }
            }
        }

        private void ReadTextPage(ref string line)
        {
            string[] keys;
            string[] values;
            SplitParts(line, out keys, out values);
            string textureName = null;
            int pageId = -1;
            for (int i = keys.Length - 1; i >= 0; i--)
            {
                switch (keys[i])
                {
                    case "file": textureName = values[i]; break;
                    case "id": pageId = int.Parse(values[i]); break;
                }
            }
            textureNames[pageId] = textureName;
        }

        private bool ReadTextCount(ref string line, out int count)
        {
            string[] keys;
            string[] values;
            SplitParts(line, out keys, out values);
            count = 0;
            for (int i = keys.Length - 1; i >= 0; i--)
            {
                switch (keys[i])
                {
                    case "count":
                        count = int.Parse(values[i]);
                        return true;
                }
            }
            return false;
        }

        private bool ReadTextChar(int idx, ref string line, ref List<CharacterInfo> list, ref List<RawCharacterInfo> rlist)
        {
            if (!line.StartsWith("char")) return false;
            string[] keys;
            string[] values;
            SplitParts(line, out keys, out values);
            int id = 0, x = 0, y = 0, w = 0, h = 0, xo = 0, yo = 0, xadvance = 0;
            for (int i = keys.Length - 1; i >= 0; i--)
            {
                switch (keys[i])
                {
                    case "id": id = int.Parse(values[i]); break;
                    case "x": x = int.Parse(values[i]); break;
                    case "y": y = int.Parse(values[i]); break;
                    case "width": w = int.Parse(values[i]); break;
                    case "height": h = int.Parse(values[i]); break;
                    case "xoffset": xo = int.Parse(values[i]); break;
                    case "yoffset": yo = int.Parse(values[i]); break;
                    case "xadvance": xadvance = int.Parse(values[i]); break;
                }
            }
            list.Add(CreateCharInfo(id, x, y, w, h, xo, yo, xadvance));
            rlist.Add(new RawCharacterInfo(id, x, y, w, h, xo, yo, xadvance, 0));
            return true;
        }

        private bool ReadTextKerning(int idx, ref string line, ref List<CharacterInfo> list)
        {
            if (!line.StartsWith("kerning")) return false;
            string[] keys;
            string[] values;
            SplitParts(line, out keys, out values);
            Kerning kerning = new Kerning();
            for (int i = keys.Length - 1; i >= 0; i--)
            {
                switch (keys[i])
                {
                    case "first": kerning.first = int.Parse(values[i]); break;
                    case "second": kerning.second = int.Parse(values[i]); break;
                    case "amount": kerning.amount = int.Parse(values[i]); break;
                }
            }
            kernings[idx] = kerning;
            return true;
        }

        private bool SplitParts(string line, out string[] keys, out string[] values)
        {
            MatchCollection parts = pattern.Matches(line);
            int count = parts.Count;
            keys = new string[count - 1];
            values = new string[count - 1];
            for (int i = count - 2; i >= 0; i--)
            {
                string part = parts[i + 1].Value;
                int pos = part.IndexOf('=');
                keys[i] = part.Substring(0, pos);
                values[i] = part.Substring(pos + 1).Trim('"');
            }
            return true;
        }

        #endregion

        private CharacterInfo CreateCharInfo(int id, int x, int y, int w, int h, int xo, int yo, int xadvance, int page = 0)
        {
            Rect uv = new Rect();
            uv.x = (float)x / textureWidth + page;
            uv.y = (float)y / textureHeight;
            uv.width = (float)w / textureWidth;
            uv.height = (float)h / textureHeight;
            uv.y = 1f - uv.y - uv.height;

            Rect vert = new Rect();
            vert.x = xo;
#if UNITY_5_0 || UNITY_5_1 || UNITY_5_2
            // unity 5.0 can not support baseline for 
            vert.y = yo;
#else
            vert.y = yo - lineBaseHeight;
#endif
            vert.width = w;
            vert.height = h;
            vert.y = -vert.y;
            vert.height = -vert.height;

            CharacterInfo charInfo = new CharacterInfo();
            charInfo.index = id;

#if UNITY_5_3_OR_NEWER || UNITY_5_3 || UNITY_5_2
            charInfo.uvBottomLeft = new Vector2(uv.xMin, uv.yMin);
            charInfo.uvBottomRight = new Vector2(uv.xMax, uv.yMin);
            charInfo.uvTopLeft = new Vector2(uv.xMin, uv.yMax);
            charInfo.uvTopRight = new Vector2(uv.xMax, uv.yMax);

            charInfo.minX = (int)vert.xMin;
            charInfo.maxX = (int)vert.xMax;
            charInfo.minY = (int)vert.yMax;
            charInfo.maxY = (int)vert.yMin;

            charInfo.bearing = (int)vert.x;
            charInfo.advance = xadvance;
#else
#pragma warning disable 618
            charInfo.uv = uv;
            charInfo.vert = vert;
            charInfo.width = xadvance;
#pragma warning restore 618
#endif
            return charInfo;
        }
    }

}
```

```zOverallAssets\Fonts\Editor\Fnt2TMPro\Fnt2TMPro.cs
using UnityEngine;
using UnityEditor;
using UnityEngine.TextCore;

using TMPro;
using litefeelcustom;

namespace Fnt2TMPro.EditorUtilities
{
    public class Fnt2TMPro : EditorWindow
    {
        [MenuItem("Window/Bitmap Font Converter")]

        public static void ShowWindow()
        {
            EditorWindow.GetWindow(typeof(Fnt2TMPro), false, "Bitmap Font Converter");
        }
        private Texture2D m_Texture2D;
        private TextAsset m_SourceFontFile;
        private TMP_FontAsset m_DestinationFontFile;
        void PatchGlyph(RawCharacterInfo character, int textureHeight, int textureWidth, ref Glyph g)
        {
            var scaleH = textureWidth / textureHeight > 1 ? textureWidth / textureHeight : 1;
            var scaleW = textureHeight / textureWidth > 1 ? textureHeight / textureWidth : 1;
            g.glyphRect = new GlyphRect(
                character.X * scaleW,
                (textureHeight - character.Y - character.Height) * scaleH,
                character.Width * scaleW,
                character.Height * scaleH
            );
            g.metrics = new GlyphMetrics(
                character.Width,
                character.Height,
                character.Xoffset,
                -character.Yoffset,
                character.Xadvance
            );
        }
        void UpdateFont(TMP_FontAsset fontFile)
        {
            var fontText = m_SourceFontFile.text;
            var fnt = FntParse.GetFntParse(ref fontText);

            for (int i = 0; i < fontFile.characterTable.Count; i++)
            {
                var unicode = fontFile.characterTable[i].unicode;
                var glyphIndex = fontFile.characterTable[i].glyphIndex;
                for (int j = 0; j < fnt.charInfos.Length; j++)
                {
                    if (unicode == fnt.charInfos[j].index)
                    {
                        var glyph = fontFile.glyphLookupTable[glyphIndex];
                        PatchGlyph(fnt.rawCharInfos[j],
                            fnt.textureHeight,
                            fnt.textureWidth,
                            ref glyph);
                        fontFile.glyphLookupTable[glyphIndex] = glyph;
                        break;
                    }
                }
            }

            var newFaceInfo = fontFile.faceInfo;
            newFaceInfo.baseline = fnt.lineBaseHeight;
            newFaceInfo.lineHeight = fnt.lineHeight;
            newFaceInfo.ascentLine = fnt.lineHeight;
            newFaceInfo.pointSize = fnt.fontSize;

            var fontType = typeof(TMP_FontAsset);
            var faceInfoProperty = fontType.GetProperty("faceInfo");
            faceInfoProperty.SetValue(fontFile, newFaceInfo);

            fontFile.material.SetTexture("_MainTex", m_Texture2D);
            fontFile.atlasTextures[0] = m_Texture2D;
        }

        void OnGUI()
        {
            EditorGUILayout.BeginHorizontal();
            m_Texture2D = EditorGUILayout.ObjectField("Font Texture",
                m_Texture2D, typeof(Texture2D), false) as Texture2D;
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            m_SourceFontFile = EditorGUILayout.ObjectField("Source Font File",
                m_SourceFontFile, typeof(TextAsset), false) as TextAsset;
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            m_DestinationFontFile = EditorGUILayout.ObjectField("Destination Font File",
                m_DestinationFontFile, typeof(TMP_FontAsset), false) as TMP_FontAsset;
            EditorGUILayout.EndHorizontal();

            if (GUILayout.Button("Convert"))
            {
                UpdateFont(m_DestinationFontFile);
            }
        }
    }
}
```

```zOverallAssets\scripts\FPSCounter.cs
using UnityEngine;
using UnityEngine.UI;

public class FPSCounter : MonoBehaviour
{
    private float _deltaTime = 0.0f;
    private GUIStyle _style;
    private Rect _rect;

    private void Start()
    {
        int w = Screen.width, h = Screen.height;
        _rect = new Rect(10, 10, w, h * 2 / 100);
        _style = new GUIStyle
        {
            alignment = TextAnchor.UpperLeft,
            fontSize = h * 2 / 50,
            normal = { textColor = Color.white }
        };
    }

    private void Update()
    {
        _deltaTime += (Time.unscaledDeltaTime - _deltaTime) * 0.1f;
    }

    private void OnGUI()
    {
        float fps = 1.0f / _deltaTime;
        string text = $"FPS: {fps:F1}";
        GUI.Label(_rect, text, _style);
    }
}
```

```zOverallAssets\scripts\GameObjectExtensions.cs
using UnityEngine;
using System.Linq;

// See https://github.com/adammyhre/Unity-Utils for more extension methods
public static class GameObjectExtensions {
    /// <summary>
    /// Returns the object itself if it exists, null otherwise.
    /// </summary>
    /// <remarks>
    /// This method helps differentiate between a null reference and a destroyed Unity object. Unity's "== null" check
    /// can incorrectly return true for destroyed objects, leading to misleading behaviour. The OrNull method use
    /// Unity's "null check", and if the object has been marked for destruction, it ensures an actual null reference is returned,
    /// aiding in correctly chaining operations and preventing NullReferenceExceptions.
    /// </remarks>
    /// <typeparam name="T">The type of the object.</typeparam>
    /// <param name="obj">The object being checked.</param>
    /// <returns>The object itself if it exists and not destroyed, null otherwise.</returns>
    public static T OrNull<T>(this T obj) where T : Object => obj ? obj : null;
}
```

```zOverallAssets\scripts\NoteDescription.cs
using UnityEngine;

public class NoteDescription : MonoBehaviour
{
    [TextAreaAttribute]
    public string Description;
}
```

```zOverallAssets\scripts\Selection Base.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[SelectionBase]
public class SelectionBase : MonoBehaviour
{

}
```

```zOverallAssets\scripts\Timer.cs
using System;

namespace OverallTimers
{
    public abstract class Timer
    {
        protected float initialTime;
        public float Time { get; set; }
        public bool IsRunning { get; protected set; }

        public float Progress => Time / initialTime;

        public Action OnTimerStart = delegate { };
        public Action OnTimerStop = delegate { };

        protected Timer(float value)
        {
            initialTime = value;
            IsRunning = false;
        }

        public void Start()
        {
            Time = initialTime;
            if (!IsRunning)
            {
                IsRunning = true;
                OnTimerStart.Invoke();
            }
        }

        public void Stop()
        {
            if (IsRunning)
            {
                IsRunning = false;
                OnTimerStop.Invoke();
            }
        }

        public void Resume() => IsRunning = true;
        public void Pause() => IsRunning = false;

        public abstract void Tick(float deltaTime);
    }

    public class CountdownTimer : Timer
    {
        public CountdownTimer(float value) : base(value)
        {
        }

        public override void Tick(float deltaTime)
        {
            if (IsRunning && Time > 0)
            {
                Time -= deltaTime;
            }

            if (IsRunning && Time <= 0)
            {
                Stop();
            }
        }

        public bool IsFinished => Time <= 0;

        public void Reset() => Time = initialTime;

        public void Reset(float newTime)
        {
            initialTime = newTime;
            Reset();
        }
    }

    public class StopwatchTimer : Timer
    {
        public StopwatchTimer() : base(0)
        {
        }

        public override void Tick(float deltaTime)
        {
            if (IsRunning)
            {
                Time += deltaTime;
            }
        }

        public void Reset() => Time = 0;

        public float GetTime() => Time;
    }
}
```

```zOverallAssets\scripts\UpdateTextBasedOnSlider.cs
using System.Globalization;
using UnityEngine;
using TMPro;
using UnityEngine.UI;

public class UpdateTextBasedOnSlider : MonoBehaviour
{
    TextMeshProUGUI _text;
    [SerializeField] Slider slider;
    
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        _text = GetComponent<TextMeshProUGUI>();

        if (slider == null)
        {
            Debug.LogError("slider is null!!!!");
            return;
        }
        
        UpdateText(slider.value);
        slider.onValueChanged.AddListener(UpdateText);
    }

    public void UpdateText(float value)
    {
        _text.text = value.ToString(CultureInfo.CurrentCulture);
    }
}
```

```zOverallAssets\scripts\Vector3Extensions.cs
using UnityEngine;

// See https://github.com/adammyhre/Unity-Utils for more extension methods
public static class Vector3Extensions {
    /// <summary>
    /// Sets any x y z values of a Vector3
    /// </summary>
    public static Vector3 With(this Vector3 vector, float? x = null, float? y = null, float? z = null) {
        return new Vector3(x ?? vector.x, y ?? vector.y, z ?? vector.z);
    }
}
```

```zOverallAssets\scripts\YDeprecated.cs
using UnityEngine;

public class YDeprecated : MonoBehaviour
{
    public string Explanation = "";
    [Header("Everything MarkedBy This Is Deprecated By Yonatan")]
    public string MoveTo = "";
}
```

```zOverallAssets\scripts\debugging\BetterNullRef.cs
// BetterNullRef.cs
// Drop-in tool for Unity to enhance NullReferenceException logs
// Place in Assets/Scripts/ or any runtime folder

using System.IO;
using System.Text.RegularExpressions;
using UnityEngine;

[DefaultExecutionOrder(-10000)]
public class BetterNullRef : MonoBehaviour
{
    private static string _lastExceptionKey;
    private const bool EnabledInEditor = true;
    private const bool EnabledInBuild = false;

    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
    private static void Initialize()
    {
#if UNITY_EDITOR
        if (!EnabledInEditor) return;
#else
        if (!EnabledInBuild) return;
#endif

        Application.logMessageReceived += (condition, stackTrace, type) =>
        {
            if (type != LogType.Exception || !condition.StartsWith("NullReferenceException")) return;

            string exceptionKey = condition + stackTrace;
            if (exceptionKey == _lastExceptionKey) return; // prevent duplicate
            _lastExceptionKey = exceptionKey;

            if (TryBuildBetterNREMessage(stackTrace, out string summary, out string pathLine))
            {
                Debug.LogError("\uD83D\uDD34 [BetterNRE] " + summary + $"\n{pathLine}");
            }
        };
    }

    private static bool TryBuildBetterNREMessage(string stackTrace, out string summary, out string pathLine)
    {
        summary = null;
        pathLine = null;

        var lines = stackTrace.Split('\n');
        foreach (var line in lines)
        {
            var match = Regex.Match(line.Trim(), @"^([\w\.]+)\.(\w+)\s*\(.*\)\s+\(at\s+(.+):(\d+)\)$");
            if (!match.Success) continue;

            string className = match.Groups[1].Value;
            string methodName = match.Groups[2].Value;
            string filePath = match.Groups[3].Value;
            int lineNumber = int.Parse(match.Groups[4].Value);

            if (!File.Exists(filePath)) return false;
            var sourceLines = File.ReadAllLines(filePath);
            if (lineNumber <= 0 || lineNumber > sourceLines.Length) return false;

            string codeLine = sourceLines[lineNumber - 1].Trim();
            string guess = GuessNullCause(codeLine);

            summary =
                $"NullReferenceException in {className}.{methodName} at {Path.GetFileName(filePath)}:{lineNumber} \u2192 \uD83D\uDCA5 `{guess}` likely null\n" +
                $"   \uD83E\uDDEE {codeLine}";

            string relativePath = filePath.Replace(Application.dataPath, "Assets").Replace("\\", "/");
            pathLine = $"<a href=\"{relativePath}\" line=\"{lineNumber}\">{relativePath}:{lineNumber}</a>";
            return true;
        }

        return false;
    }

    private static string GuessNullCause(string line)
    {
        int conditionStart = line.IndexOf('(');
        int conditionEnd = line.LastIndexOf(')');
        if (conditionStart >= 0 && conditionEnd > conditionStart)
            line = line.Substring(conditionStart + 1, conditionEnd - conditionStart - 1);

        var matches = Regex.Matches(line, @"([\w\d_]+(\.[\w\d_]+)+)");
        if (matches.Count == 0) return "unknown expression";

        var longest = "";
        foreach (Match m in matches)
            if (m.Value.Length > longest.Length)
                longest = m.Value;

        return longest;
    }
}
```

```zOverallAssets\scripts\Editor\CheckForEditorScripts.cs
using UnityEditor;
using UnityEngine;

public class CheckForEditorScripts : MonoBehaviour
{
    [MenuItem("Tools/Check for Editor Scripts in Scene")]
    static void CheckForEditorScriptsFunc()
    {
        foreach (var comp in GameObject.FindObjectsByType<MonoBehaviour>(FindObjectsSortMode.None))
        {
            if (comp == null) continue;
            var asm = comp.GetType().Assembly.FullName;
            if (asm.Contains("Editor"))
                Debug.LogWarning($"Editor script on {comp.gameObject.name}", comp.gameObject);
        }
    }

    [MenuItem("Tools/Find InputAction by GUID")]
    static void FindInputAsset()
    {
        string guid = "ca9f5fa95ffab41fb9a615ab714db018";
        string path = AssetDatabase.GUIDToAssetPath(guid);
        Debug.Log("InputAction path: " + path);
        var obj = AssetDatabase.LoadAssetAtPath<Object>(path);
        Selection.activeObject = obj;
    }
}
```

```zOverallAssets\scripts\Editor\SceneAssetInspector.cs
using UnityEditor;
using UnityEngine;
using System.IO;

public class SceneAssetInspector
{
    [MenuItem("Tools/Log Raw Scene File References")]
    static void LogSceneReferences()
    {
        string path = "Assets/GAMES/FallingRuins/Shooter.unity";
        var text = File.ReadAllText(path);
        File.WriteAllText("SceneRawLog.txt", text);
        Debug.Log("Raw scene content dumped to SceneRawLog.txt");
    }
}
```

```zOverallAssets\scripts\Editor\SceneDebugBuildLogger.cs
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
using UnityEngine;
using System.IO;
using UnityEditor.SceneManagement;

class SceneDebugBuildLogger : IPreprocessBuildWithReport
{
    public int callbackOrder => 0;
    private static string logPath = "BuildLogs/SceneScanLog.txt";

    public void OnPreprocessBuild(BuildReport report)
    {
        Directory.CreateDirectory("BuildLogs");
        using (StreamWriter writer = new StreamWriter(logPath, false))
        {
            writer.WriteLine("==== SCENE DEBUG START ====");
            foreach (var scene in EditorBuildSettings.scenes)
            {
                if (!scene.enabled) continue;
                writer.WriteLine($"Scene: {scene.path}");

                var openedScene = EditorSceneManager.OpenScene(scene.path, OpenSceneMode.Single);
                foreach (var root in openedScene.GetRootGameObjects())
                {
                    try
                    {
                        LogGameObjectRecursive(root, 0, writer);
                    }
                    catch (System.Exception ex)
                    {
                        writer.WriteLine($"[ERROR] Exception on {root.name}: {ex.Message}");
                    }
                }
            }
            writer.WriteLine("==== SCENE DEBUG END ====");
        }

        Debug.Log($"Scene scan written to {Path.GetFullPath(logPath)}");
    }

    void LogGameObjectRecursive(GameObject go, int indent, StreamWriter writer)
    {
        var prefix = new string(' ', indent * 2);
        writer.WriteLine($"{prefix}- {go.name}");

        foreach (var comp in go.GetComponents<Component>())
        {
            if (comp == null)
                writer.WriteLine($"{prefix}  * Missing component on {go.name}");
            else
                writer.WriteLine($"{prefix}  * Component: {comp.GetType()}");
        }

        foreach (Transform child in go.transform)
            LogGameObjectRecursive(child.gameObject, indent + 1, writer);
    }
}
```

```zOverallAssets\scripts\Editor\SceneSanity.cs
// Editor folder
using UnityEditor;
using UnityEngine;

public class SceneSanity : MonoBehaviour
{
    [MenuItem("Tools/Check Scene Sanity")]
    static void Check()
    {
        foreach (var t in FindObjectsByType<Transform>(FindObjectsSortMode.None))
        {
            if (HasLoop(t))
                Debug.LogError($"Loop found: {t.GetHierarchy()}");
            foreach (var c in t.GetComponents<Component>())
                if (c == null)
                    Debug.LogError($"Missing script on {t.GetHierarchy()}");
        }
        Debug.Log("Scene scan complete");
    }

    static bool HasLoop(Transform root)
    {
        var p = root.parent;
        while (p)
        {
            if (p == root) return true;
            p = p.parent;
        }
        return false;
    }
}

```

```zOverallAssets\scripts\Editor\SceneSanityV2.cs
// Assets/Editor/SceneSanityV2.cs
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;

public static class SceneSanityV2
{
    [MenuItem("Tools/Check Scene Sanity (v2)")]
    static void Check()
    {
        int missing = 0, loops = 0, deep = 0, maxDepth = 0;
        foreach (var t in Object.FindObjectsByType<Transform>(FindObjectsInactive.Include, FindObjectsSortMode.None))
        {
            // ----- missing scripts -----
            foreach (var c in t.GetComponents<Component>())
                if (c == null)
                {
                    Debug.LogError($"Missing script  {t.GetHierarchy()}");
                    missing++;
                }

            // ----- parent-loop check -----
            if (HasLoop(t))
            {
                Debug.LogError($"Hierarchy loop  {t.GetHierarchy()}");
                loops++;
            }

            // ----- depth check -----
            int d = Depth(t);
            maxDepth = Mathf.Max(maxDepth, d);
            if (d > 128)   // Unitys recursion limit is ~256, play safe at 128
            {
                Debug.LogError($"Depth {d}  {t.GetHierarchy()}");
                deep++;
            }
        }

        Debug.Log($"Scene scan complete  Missing:{missing}  Loops:{loops}  Deep:{deep}  MaxDepth:{maxDepth}");
    }

    static bool HasLoop(Transform root)
    {
        var seen = new HashSet<Transform>();
        var p = root;
        while (p)
        {
            if (!seen.Add(p)) return true;
            p = p.parent;
        }
        return false;
    }

    static int Depth(Transform t)
    {
        int d = 0;
        while (t.parent) { d++; t = t.parent; }
        return d;
    }

    public static string GetHierarchy(this Transform t)
    {
        string path = t.name;
        while (t.parent != null)
        {
            t = t.parent;
            path = t.name + "/" + path;
        }
        return path;
    }
}
```

```zOverallAssets\version verifier\VersionTracker.cs
using UnityEngine;

[CreateAssetMenu(fileName = "RuinsVersion", menuName = "Tools/Ruins Version")]
public class VersionTracker : ScriptableObject
{
    public int version;
}
```

```zOverallAssets\version verifier\VersionUpdater.cs
using UnityEditor;
using UnityEngine;

[InitializeOnLoad]
public static class VersionUpdater
{
    static VersionUpdater()
    {
        return;
        string path = "Assets/GameSystems/zOverallAssets/version verifier/RuinsVersion.asset";
        var versionAsset = AssetDatabase.LoadAssetAtPath<VersionTracker>(path);

        if (versionAsset == null)
        {
            versionAsset = ScriptableObject.CreateInstance<VersionTracker>();
            versionAsset.version = 1;
            AssetDatabase.CreateAsset(versionAsset, path);
            AssetDatabase.SaveAssets();
            Debug.Log("[VersionUpdater] Created new version tracker");
        }
        else
        {
            versionAsset.version++;
            EditorUtility.SetDirty(versionAsset);
            AssetDatabase.SaveAssets();
            Debug.Log($"[VersionUpdater] Version incremented to {versionAsset.version}");
        }
    }
}
```

